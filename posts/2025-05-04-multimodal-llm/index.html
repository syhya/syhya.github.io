<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Multimodal Large Language Models | Yue Shui Blog</title><meta name=keywords content="Multimodal,MLLMs,ViT,CLIP,BLIP,LLaVA,OpenAI,Qwen-VL,Kimi-VL"><meta name=description content="Humans interact with the world through multiple senses (vision, hearing, touch, etc.), with each sensory channel offering unique advantages in representing and communicating specific concepts. This multimodal interaction fosters our deep understanding of the world. One of the core goals in the field of artificial intelligence is to develop general-purpose assistants that can effectively follow multimodal instructions (such as visual and linguistic ones), enabling them to perform various real-world tasks like humans. In recent years, with the release of models like GPT-4o (OpenAI, 2024), Gemini 2.5 Pro (DeepMind, 2025), and o3/o4-mini (OpenAI, 2025), Multimodal Large Language Models (MLLMs) have made significant progress. They can not only understand information from multiple modalities like images, videos, and audio but also perform complex reasoning and generation."><meta name=author content="Yue Shui"><link rel=canonical href=https://syhya.github.io/posts/2025-05-04-multimodal-llm/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3dc782d653c34c6a0c8f1a261092c93b4c57a4549c8e3b36275bd5d52648e773.css integrity="sha256-PceC1lPDTGoMjxomEJLJO0xXpFScjjs2J1vV1SZI53M=" rel="preload stylesheet" as=style><link rel=icon href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://syhya.github.io/posts/2025-05-04-multimodal-llm/><link rel=alternate hreflang=zh href=https://syhya.github.io/zh/posts/2025-05-04-multimodal-llm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>window.MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SZ2660B91F"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SZ2660B91F")}</script><meta property="og:url" content="https://syhya.github.io/posts/2025-05-04-multimodal-llm/"><meta property="og:site_name" content="Yue Shui Blog"><meta property="og:title" content="Multimodal Large Language Models"><meta property="og:description" content="Humans interact with the world through multiple senses (vision, hearing, touch, etc.), with each sensory channel offering unique advantages in representing and communicating specific concepts. This multimodal interaction fosters our deep understanding of the world. One of the core goals in the field of artificial intelligence is to develop general-purpose assistants that can effectively follow multimodal instructions (such as visual and linguistic ones), enabling them to perform various real-world tasks like humans. In recent years, with the release of models like GPT-4o (OpenAI, 2024), Gemini 2.5 Pro (DeepMind, 2025), and o3/o4-mini (OpenAI, 2025), Multimodal Large Language Models (MLLMs) have made significant progress. They can not only understand information from multiple modalities like images, videos, and audio but also perform complex reasoning and generation."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-04T12:00:00+08:00"><meta property="article:modified_time" content="2025-08-25T17:41:19+08:00"><meta property="article:tag" content="Multimodal"><meta property="article:tag" content="MLLMs"><meta property="article:tag" content="ViT"><meta property="article:tag" content="CLIP"><meta property="article:tag" content="BLIP"><meta property="article:tag" content="LLaVA"><meta property="og:image" content="https://syhya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://syhya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Multimodal Large Language Models"><meta name=twitter:description content="Humans interact with the world through multiple senses (vision, hearing, touch, etc.), with each sensory channel offering unique advantages in representing and communicating specific concepts. This multimodal interaction fosters our deep understanding of the world. One of the core goals in the field of artificial intelligence is to develop general-purpose assistants that can effectively follow multimodal instructions (such as visual and linguistic ones), enabling them to perform various real-world tasks like humans. In recent years, with the release of models like GPT-4o (OpenAI, 2024), Gemini 2.5 Pro (DeepMind, 2025), and o3/o4-mini (OpenAI, 2025), Multimodal Large Language Models (MLLMs) have made significant progress. They can not only understand information from multiple modalities like images, videos, and audio but also perform complex reasoning and generation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://syhya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Multimodal Large Language Models","item":"https://syhya.github.io/posts/2025-05-04-multimodal-llm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Multimodal Large Language Models","name":"Multimodal Large Language Models","description":"Humans interact with the world through multiple senses (vision, hearing, touch, etc.), with each sensory channel offering unique advantages in representing and communicating specific concepts. This multimodal interaction fosters our deep understanding of the world. One of the core goals in the field of artificial intelligence is to develop general-purpose assistants that can effectively follow multimodal instructions (such as visual and linguistic ones), enabling them to perform various real-world tasks like humans. In recent years, with the release of models like GPT-4o (OpenAI, 2024), Gemini 2.5 Pro (DeepMind, 2025), and o3/o4-mini (OpenAI, 2025), Multimodal Large Language Models (MLLMs) have made significant progress. They can not only understand information from multiple modalities like images, videos, and audio but also perform complex reasoning and generation.\n","keywords":["Multimodal","MLLMs","ViT","CLIP","BLIP","LLaVA","OpenAI","Qwen-VL","Kimi-VL"],"articleBody":"Humans interact with the world through multiple senses (vision, hearing, touch, etc.), with each sensory channel offering unique advantages in representing and communicating specific concepts. This multimodal interaction fosters our deep understanding of the world. One of the core goals in the field of artificial intelligence is to develop general-purpose assistants that can effectively follow multimodal instructions (such as visual and linguistic ones), enabling them to perform various real-world tasks like humans. In recent years, with the release of models like GPT-4o (OpenAI, 2024), Gemini 2.5 Pro (DeepMind, 2025), and o3/o4-mini (OpenAI, 2025), Multimodal Large Language Models (MLLMs) have made significant progress. They can not only understand information from multiple modalities like images, videos, and audio but also perform complex reasoning and generation.\nNotations The following table lists the key mathematical symbols used in this article and their meanings to help you read more easily.\nSymbol Description \\( I, \\mathbf{X}_v \\) Image input, \\( I \\) usually refers to the raw image matrix \\( \\in \\mathbb{R}^{H \\times W \\times C} \\) \\( T, \\mathbf{X}_c, \\mathbf{X}_q, \\mathbf{X}_a, \\mathbf{X}_{\\text{instruct}} \\) Text input, specifically could refer to image caption (\\( \\mathbf{X}_c \\)), user question (\\( \\mathbf{X}_q \\)), model answer (\\( \\mathbf{X}_a \\)), or instruction (\\( \\mathbf{X}_{\\text{instruct}} \\)) \\( V, \\mathbf{Z}_v \\) Raw image features or embedding sequence output by the image encoder \\( L, \\mathbf{H}_q, \\mathbf{H}_a \\) Text features or embedding sequence output by the text encoder \\( \\mathbf{H}_v \\) Visual token sequence input to the LLM after processing by a projection layer \\( Z \\) Query embeddings output by Q-Former, serving as a compressed representation of visual information \\( P_Z \\) Soft Visual Prompt derived from the Q-Former output \\( I_e, T_e \\) Image and text embeddings in CLIP’s shared multimodal embedding space \\( z_p \\) Embedding vector of a single image patch after linear projection in ViT \\( x_{class} \\) Embedding of the learnable [class] token used for classification tasks in ViT \\( x_i \\) The \\( i \\)-th element or token in a sequence (e.g., word \\( w_i \\) in a text sequence) \\( E_{img}, g(\\cdot) \\) Image encoder model (e.g., ViT) \\( E_{text}, f_{\\phi}(\\cdot) \\) Text encoder or LLM \\( E, \\mathbf{W}, \\mathbf{W}_i, \\mathbf{W}_t \\) Linear projection matrix, used for feature transformation or modality alignment \\( E_{pos} \\) Positional encoding vector, used to provide sequence position information to the Transformer \\( Q, K, V \\) Query, Key, Value matrices in the attention mechanism \\( W_Q, W_K, W_V \\) Learnable projection matrices used to compute Q, K, V from input \\( \\theta, \\phi \\) Set of trainable parameters for the entire model or a specific part (e.g., LLM \\( \\phi \\)) \\( P \\) Side length of an image patch defined in the ViT model \\( N \\) Batch Size, usually refers to the number of samples in a batch \\( N_{patches} \\) Number of image patches the ViT model divides an image into \\( D \\) Main dimension of embedding vectors in the model \\( d, d_k \\) Dimension of the key vector in the attention mechanism, used for scaling the dot product \\( T_{turns} \\) Total number of conversation turns in multi-turn dialogue data \\( \\mathcal{L} \\) Loss function, the objective optimized by the model (e.g., \\( \\mathcal{L}_{ITC}, \\mathcal{L}_{ITM}, \\mathcal{L}_{LM}, \\mathcal{L}_{CLIP}, \\mathcal{L}_{siglip} \\)) \\( \\tau \\) Learnable parameter, such as temperature in contrastive loss or KL regularization weight in reinforcement learning \\( \\lambda \\) Hyperparameter, such as the weight of different loss terms or length penalty factor in reinforcement learning \\( y \\) Target label or category (e.g., ITM loss); or the final answer generated by the model (e.g., Kimi-VL RL) \\( x \\) Input data, context, or question \\( z \\) Intermediate reasoning steps or chain-of-thought generated by the model \\( y^* \\) Reference answer or ground truth answer $\\operatorname{sim}(u, v) = s(u, v)$ Similarity calculation between vectors \\( u \\) and \\( v \\), usually cosine similarity \\( \\mathbb{E} \\) Mathematical expectation KL KL Divergence (Kullback–Leibler Divergence), used to measure the difference between two probability distributions \\( \\pi_{\\theta} \\) Policy model, outputs actions or text sequences based on parameters \\( \\theta \\) \\( r \\) Reward function, evaluates the quality of the generated output Multimodal Fundamentals Before diving into specific technologies, let’s understand some basic concepts of multimodality.\nWhat is Multimodality? Multimodality refers to the use of multiple different types of data or information channels (modalities) to represent and process information. Humans are inherently multimodal beings; we perceive and understand the world through vision, hearing, touch, smell and taste. In the field of artificial intelligence, multimodal learning aims to build models capable of processing and correlating information from different modalities (such as text, images, videos, audio, etc.).\nFig. 1. Multimodality Data. (Image source: GPT-4o Image Generation)\nCommon Modalities:\nText: Natural language text, the primary means of information transmission and knowledge expression. Image: Static visual information, containing rich details of scenes, objects, and textures. Video: Dynamic visual information, composed of sequential image frames, often accompanied by audio. Video contains not only spatial information but also temporal information. Audio: Sound information, including speech, music, and environmental sounds. Others: Tabular data, 3D point clouds, sensor data (e.g., radar, LiDAR), biological signals (e.g., EEG, ECG), etc. Why Do We Need Multimodal AI? More Comprehensive World Understanding: The real world is multimodal. A single modality often provides only partial information. For example, text descriptions alone may struggle to fully convey a complex scene, whereas combining images or videos offers more intuitive and richer information. Multimodal models can integrate information from different sources to form a more comprehensive and accurate understanding. Enhanced Task Performance: In many tasks, combining information from multiple modalities can significantly improve performance. For instance, in Visual Question Answering (VQA), the model needs to understand both the image content and the text question to provide the correct answer. In video captioning, combining visual frames and audio information can generate more vivid and accurate descriptions. More Natural Interaction: Multimodal AI makes human-computer interaction more natural and flexible. Users can interact with AI systems through various means like voice, text, and images, and the AI system can respond in multiple modalities (e.g., generating text replies with images, or generating voice answers). Unlocking New Application Scenarios: Multimodal capabilities have given rise to many new applications, such as autonomous driving (fusing data from cameras, radar, LiDAR), medical diagnosis (combining medical images and patient records), content creation (text-to-image, text-to-video), virtual assistants, robot interaction, etc. Promoting Accessibility: Multimodal technology can assist individuals with sensory impairments. For example, image captioning can help visually impaired people understand image content, while speech recognition and synthesis can aid those with hearing or speech impairments in communication. Common Multimodal Tasks The following table lists some common multimodal tasks, which typically require processing and generating information by combining multiple modalities.\nTask Name Description Visual Question Answering (VQA) Generate text answers based on an image and a related question. Image/Video Captioning Generate natural language descriptions for images or videos. Text-to-X Generation Generate corresponding image, video, or audio content from text descriptions. Cross-Modal Retrieval Use one modality (e.g., text) to query relevant data in another modality (e.g., image). Multimodal Sentiment Analysis Determine sentiment by combining information from text, audio, video, etc. Visual Reasoning Perform logical judgment and relationship inference based on image or video content. Visual Language Navigation (VLN) Guide an agent to navigate in a visual environment based on natural language instructions. Multimodal Machine Translation (MMT) Utilize relevant image information to assist text translation and resolve ambiguity. Audio-Visual Speech Recognition (AVSR) Perform speech recognition by combining audio signals and visual information of the speaker’s lip movements. Visual Grounding Associate words or phrases in text with corresponding regions or objects in images or videos. Key Technologies The development of multimodal large models is driven by a series of technologies. The figure below visually illustrates the related technologies for multimodal understanding and generation. The author will introduce some key models and methods among them.\nFig. 2. The general model architecture of MM-LLMs and the implementation choices for each component. (Image source: Zhang et al., 2024)\nVision Transformer (ViT) Vision Transformer (ViT) (Dosovitskiy et al., 2020) successfully applied the Transformer architecture to the field of computer vision, becoming the preferred visual encoder for many advanced MLLMs today.\nFig. 3. ViT model overview. (Image source: Dosovitskiy et al., 2020)\nCore Idea: ViT treats an image as a sequence of Image Patches and then uses the Transformer’s self-attention mechanism to process these patches, thereby capturing global dependencies.\nWorkflow:\nPatch Embedding: Divide the input image \\( I \\in \\mathbb{R}^{H \\times W \\times C} \\) into \\( N_{patches} \\) fixed-size non-overlapping image patches \\( x_p \\in \\mathbb{R}^{P^2 \\times C} \\), where \\( (H, W) \\) is the image resolution, \\( C \\) is the number of channels, \\( P \\) is the size of each patch, and \\( N_{patches} = HW/P^2 \\) is the number of patches. Linear Projection: Flatten each patch \\( x_p \\) into a 1D vector and map it to a \\( D \\)-dimensional embedding space using a learnable linear projection matrix \\( E \\), resulting in patch embeddings \\( z_p = x_p E \\). Position Embedding: To preserve the spatial position information of the patches, ViT adds learnable Position Embeddings \\( E_{pos} \\) to the patch embeddings. \\[ z_0 = [x_{class}; z_p^1; z_p^2; \\dots; z_p^{N_{patches}}] + E_{pos}, \\quad E \\in \\mathbb{R}^{(P^2 \\cdot C) \\times D}, E_{pos} \\in \\mathbb{R}^{(N_{patches}+1) \\times D} \\] Often, a learnable [class] token embedding \\( x_{class} \\) is also added. Its corresponding vector at the Transformer’s output is used for image classification tasks. Transformer Encoder: Feed the sequence of patch embeddings with added position encodings into a standard Transformer encoder. The encoder consists of multiple layers of Multi-Head Self-Attention (MSA) and Feed Forward Network (FFN). MSA: Captures global dependencies between image patches. For an input sequence \\( Z_{l-1} \\), the self-attention is computed as: \\[ \\text{Attention}(Q, K, V) = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)V \\] where \\( Q = Z_{l-1}W_Q, K = Z_{l-1}W_K, V = Z_{l-1}W_V \\) are the query, key, and value matrices, and \\( d_k \\) is the dimension of the key vectors. Multi-head attention splits \\( Q, K, V \\) into multiple heads, computes attention in parallel, and then concatenates the results. FFN: Typically consists of two linear layers and a non-linear activation function (e.g., GELU). The computation in each layer can be represented as: \\[ Z'_l = \\text{MSA}(\\text{LN}(Z_{l-1})) + Z_{l-1} \\] \\[ Z_l = \\text{FFN}(\\text{LN}(Z'_l)) + Z'_l \\] where LN denotes Layer Normalization. Output: The output \\( Z_L \\) of the Transformer encoder serves as the image’s feature representation \\( V \\). Fig. 4. Performance versus pre-training compute for different architectures: Vision Transformers, ResNets, and hybrids. Vision Transformers generally outperform ResNets with the same computational budget. Hybrids improve upon pure Transformers for smaller model sizes, but the gap vanishes for larger models. (Image source: Dosovitskiy et al., 2020)\nCompared to traditional Convolutional Neural Networks (CNNs), ViT offers the following advantages:\nGlobal Dependency Modeling: Self-attention directly connects any two patches, explicitly capturing long-range spatial relationships, making it better at integrating semantic information across the entire image than traditional CNNs. Strong Transferability from Large-Scale Pre-training: After pre-training on massive datasets like JFT-300M or ImageNet-22K, ViT can be easily transferred to over 20 downstream tasks such as classification, detection, and segmentation, with performance scaling almost linearly with model/data size. Simple Architecture, Easy to Scale and Parallelize: The pure Transformer stack is easy to scale in three dimensions: depth, width, and input resolution. Computations consist mainly of matrix multiplications and Softmax, naturally suited for large-batch parallel processing and mixed-precision training on GPUs/TPUs. As research progresses, ViT itself is continuously being optimized to meet the demands of MLLMs:\nNative Dynamic Resolution: Traditional ViTs typically require a fixed input resolution. Models like Qwen2-VL and Kimi-VL have introduced the capability to handle dynamic resolutions. They often remove absolute position embeddings in ViT and instead use 2D rotary position embeddings to encode two-dimensional spatial information. This allows the model to process images of arbitrary resolutions and aspect ratios, converting them into variable-length visual token sequences, better preserving detailed information. Kimi-VL’s MoonViT also borrows the image packing technique from NaViT, packing sequences of image patches with different resolutions into the Transformer, improving training efficiency. Window Attention: To reduce the quadratic computational complexity of self-attention when processing high-resolution images, Qwen2.5-VL employs window attention in most layers of its ViT. Attention computation is restricted within local windows, making the complexity linear with respect to the number of patches, significantly improving efficiency while maintaining global information interaction through a few full attention layers. Architecture Alignment with LLM: Models like Qwen2.5-VL and Kimi-VL have also fine-tuned their ViT architectures to be closer to LLM designs, such as using RMSNorm for normalization and SwiGLU as the activation function, to enhance computational efficiency and cross-modal compatibility. CLIP CLIP (Contrastive Language-Image Pre-training) (Radford et al., 2021) is a landmark work in the multimodal field. It proposed a simple yet effective method for learning the association between images and text, laying the foundation for many subsequent MLLMs.\nCore Idea: CLIP aims to learn a Multimodal Embedding Space where matched image-text pairs have high similarity, and mismatched pairs have low similarity. It achieves this through Contrastive Learning, leveraging natural language supervision.\nArchitecture: CLIP consists of two main parts:\nImage Encoder: Can be a ResNet or ViT, responsible for encoding the input image \\( I \\) into image features \\( V \\). Text Encoder: Typically a Transformer, responsible for encoding the input text \\( T \\) into text features \\( L \\). Linear Projection Layer: Projects the image features \\( V \\) and text features \\( L \\) into the shared multimodal embedding space, obtaining \\( I_e = V W_i \\) and \\( T_e = L W_t \\), where \\( W_i \\) and \\( W_t \\) are learnable projection matrices. Fig. 5. CLIP Architecture Overview. CLIP jointly trains an image encoder and a text encoder to predict the correct pairings of a batch of (image, text) training examples. At test time the learned text encoder synthesizes a zero-shot linear classifier by embedding the names or descriptions of the target dataset’s classes. (Image source: Radford et al., 2021)\nTraining Data: CLIP’s success is largely attributed to its massive pre-training dataset, WIT (WebImageText). The research team collected 400 million (image, text) pairs from the internet. They built the dataset by searching for approximately 500,000 query terms (derived from Wikipedia vocabulary, high-frequency bigrams, Wikipedia article titles, and WordNet synsets), limiting the number of samples per query to a maximum of 20,000 to balance the data distribution. This approach of using native web image-text pairs is called natural language supervision, which avoids expensive manual annotation and allows for easy scaling of data size.\nContrastive Loss: The core of CLIP is the contrastive learning objective. Given a batch of \\( N \\) (image, text) pairs \\( \\{(I_1, T_1), \\dots, (I_N, T_N)\\} \\), the model’s goal is to predict which of the \\( N \\times N \\) possible pairings are the true pairings.\nCompute all image embeddings \\( \\{I_{e,1}, \\dots, I_{e,N}\\} \\) and text embeddings \\( \\{T_{e,1}, \\dots, T_{e,N}\\} \\). L2 normalization is typically applied, dividing each image or text embedding by its own L2 norm (Euclidean norm). Calculate the Cosine Similarity between all \\( N^2 \\) pairs \\( (I_{e,i}, T_{e,j}) \\). \\[ \\text{logits}_{i,j} = \\text{sim}(I_{e,i}, T_{e,j}) \\cdot \\exp(\\tau) = \\frac{I_{e,i} \\cdot T_{e,j}}{\\|I_{e,i}\\| \\|T_{e,j}\\|} \\cdot \\exp(\\tau) \\] where \\( \\tau \\) is a learnable temperature parameter used to scale the range of the logits. Compute the Symmetric Cross-Entropy Loss. The problem is treated as two classification tasks: For each image \\( I_i \\), find the matching text \\( T_i \\) among the \\( N \\) texts. The loss is \\( \\mathcal{L}_{\\text{image}} \\). For each text \\( T_j \\), find the matching image \\( I_j \\) among the \\( N \\) images. The loss is \\( \\mathcal{L}_{\\text{text}} \\). The total loss is: \\[ \\mathcal{L}_{CLIP} = \\frac{1}{2} (\\mathcal{L}_{\\text{image}} + \\mathcal{L}_{\\text{text}}) \\] where, \\[ \\mathcal{L}_{\\text{image}} = -\\frac{1}{N} \\sum_{i=1}^N \\log \\frac{\\exp(\\text{sim}(I_{e,i}, T_{e,i}) / \\tau)}{\\sum_{j=1}^N \\exp(\\text{sim}(I_{e,i}, T_{e,j}) / \\tau)} \\] \\[ \\mathcal{L}_{\\text{text}} = -\\frac{1}{N} \\sum_{j=1}^N \\log \\frac{\\exp(\\text{sim}(I_{e,j}, T_{e,j}) / \\tau)}{\\sum_{i=1}^N \\exp(\\text{sim}(I_{e,i}, T_{e,j}) / \\tau)} \\] This loss function encourages the similarity of positive pairs (matching image-text) to be higher than that of negative pairs (mismatched image-text). CLIP Core Pseudocode # image_encoder - ResNet or Vision Transformer # text_encoder - CBOW or Text Transformer # I[n, h, w, c] - minibatch of aligned images # T[n, l] - minibatch of aligned texts # W_i[d_i, d_e] - learned proj of image to embed # W_t[d_t, d_e] - learned proj of text to embed # t - learned temperature parameter (tau in text) # extract feature representations of each modality I_f = image_encoder(I) #[n, d_i] T_f = text_encoder(T) #[n, d_t] # joint multimodal embedding [n, d_e] # l2_normalize projects the embeddings onto the unit hypersphere I_e = l2_normalize(np.dot(I_f, W_i), axis=1) T_e = l2_normalize(np.dot(T_f, W_t), axis=1) # scaled pairwise cosine similarities [n, n] # The temperature parameter t scales the logits # Note: using dot product on normalized vectors is equivalent to cosine similarity logits = np.dot(I_e, T_e.T) * np.exp(t) # symmetric loss function # labels are the indices [0, 1, ..., n-1] indicating the correct pairings labels = np.arange(n) # Calculate cross-entropy loss for image-to-text classification # (Predict correct text for each image) loss_i = cross_entropy_loss(logits, labels, axis=1) # axis=1 for softmax over columns # Calculate cross-entropy loss for text-to-image classification # (Predict correct image for each text) loss_t = cross_entropy_loss(logits, labels, axis=0) # axis=0 for softmax over rows # Final loss is the average of the two losses loss = (loss_i + loss_t)/2 Zero-Shot Transfer: CLIP’s powerful capability lies in its zero-shot transfer performance. For a new image classification task, without any fine-tuning, CLIP can make predictions as follows:\nObtain all class names for the task (e.g., “cat”, “dog”). Use Prompt Engineering to structure the class names into sentences, like “A photo of a {label}.” This helps bridge the distribution gap between the pre-training data (often sentences) and downstream tasks (often word labels). The CLIP paper found that using prompt templates and ensembling multiple prompts significantly improves performance (nearly 5% gain on ImageNet). Use CLIP’s text encoder to compute the text embeddings for each constructed sentence. These embeddings form the weight vectors of the zero-shot classifier. For a new image to be classified, use CLIP’s image encoder to compute its image embedding. Calculate the cosine similarity between this image embedding and all class text embeddings. The class with the highest similarity is predicted as the result. Fig. 6. Prompt engineering and ensembling improve zero-shot performance. Compared to the baseline of using contextless class names, prompt engineering and ensembling boost zero-shot classification performance by almost 5 points on average across 36 datasets. This improvement is similar to the gain from using 4 times more compute with the baseline zero-shot method but is ‘free’ when amortized over many predictions. (Image source: Radford et al., 2021)\nImpact of CLIP: CLIP demonstrated that powerful, transferable visual representations can be learned through large-scale natural language supervision and contrastive learning. Its learned multimodal embedding space and strong image encoder have been widely adopted in subsequent MLLMs (like Flamingo, BLIP-2, LLaVA) and text-to-image models (like DALL-E 2, Stable Diffusion).\nCLIP primarily focuses on learning aligned representations but has limited capabilities in generative tasks. Subsequent work began exploring unified model architectures capable of both understanding and generation.\nBLIP BLIP (Bootstrapping Language-Image Pre-training) (Li et al., 2022) aimed to address the limitations of existing Vision-Language Pre-training (VLP) methods in terms of both models and data: models often excel at either understanding or generation, but not both; data relies on massive and noisy web image-text pairs.\nBLIP proposed the Multimodal Encoder-Decoder (MED) architecture, designed to unify understanding and generation tasks. It combines the advantages of CLIP’s contrastive learning and autoregressive generation, capable of handling multimodal data.\nFig. 7. BLIP Pre-training Model Architecture and Objectives (same parameters have the same color). We propose multimodal mixture of encoder-decoder (MED), a unified vision-language model which can operate in one of the three functionalities. (Image source: Li et al., 2022)\nImage Encoder: Uses ViT. Text Encoder/Decoder: Based on the BERT architecture but modified to accommodate multimodal tasks and different functional modes. Unimodal Encoder: Standard ViT and BERT, processing images and text separately. Image-grounded Text Encoder: Inserts Cross-Attention (CA) layers between the Self-Attention (SA) layer and the Feed-Forward Network (FFN) layer in each Transformer block of the text encoder to inject visual information. A [Encode] token is prepended to the text input, and its output embedding serves as the multimodal representation of the image-text pair. Image-grounded Text Decoder: Replaces the bidirectional SA layers in the encoder with Causal Self-Attention layers for autoregressive generation. Shares the CA and FFN layers with the encoder. Uses a [Decode] token as the sequence start symbol. Pre-training Objectives: BLIP jointly optimizes three objectives:\nImage-Text Contrastive (ITC) Loss: Similar to CLIP, uses the unimodal encoders to align the feature spaces of images and text. BLIP adopts the momentum encoder and soft label strategy proposed by ALBEF (Li et al., 2021) to improve contrastive learning. $$L_{ITC} = \\frac{1}{2N} \\sum_{i=1}^{N} \\left( -\\log \\frac{\\exp(s(v_i, t_i)/\\tau)}{\\sum_{j=1}^{N} \\exp(s(v_i, t_j)/\\tau)} -\\log \\frac{\\exp(s(v_i, t_i)/\\tau)}{\\sum_{j=1}^{N} \\exp(s(v_j, t_i)/\\tau)} \\right)$$ where $v_i, t_j$ are image and text features, $s$ is the similarity function, and $\\tau$ is the temperature parameter.\nImage-Text Matching (ITM) Loss: Uses the image-grounded text encoder to learn fine-grained image-text alignment. This is a binary classification task predicting whether an image-text pair is matched or mismatched. A hard negative mining strategy is employed. $$L_{ITM} = -\\mathbb{E}_{(I,T)\\sim D} [y \\log p_{match} + (1-y) \\log(1 - p_{match})]$$ where $y$ is the label and $p_{match}$ is the matching probability.\nLanguage Modeling (LM) Loss: Uses the image-grounded text decoder to generate text descriptions based on the image. A standard cross-entropy loss (with label smoothing) is used. $$L_{L M}=-\\mathbb{E}_{(I, T) \\sim D} \\sum_{k=1}^L \\log P\\left(w_k \\mid I, w_{\\lt k} ; \\theta\\right)$$ where $w_k$ is a word in the text sequence and $\\theta$ are the model parameters.\nTotal Loss Function: These three losses are typically optimized jointly (e.g., summed with equal weights): $$L_{BLIP} = L_{ITC} + L_{ITM} + L_{LM}$$Parameter Sharing: For efficiency and the benefits of multi-task learning, the text encoder and decoder share all parameters except for the SA layers (i.e., embedding layer, CA layers, FFN layers).\nCapFilt (Captioning and Filtering) is an innovative dataset bootstrapping method used to generate high-quality synthetic captions for unlabeled web images and filter out noisy data (including original web text and synthetic text).\nFig. 8. BLIP Learning Framework. We introduce a captioner to produce synthetic captions for web images, and a filter to remove noisy image-text pairs. (Image source: Li et al., 2022)\nInitialization: Initialize two modules using a pre-trained MED model: a Captioner (image-grounded text decoder) and a Filter (image-grounded text encoder). Fine-tuning: Fine-tune the Captioner (using LM loss) and Filter (using ITC and ITM losses) separately on a high-quality human-annotated dataset (e.g., COCO). This is a lightweight process. Generation and Filtering: The Captioner generates synthetic captions \\( T_s \\) for web images \\( I_w \\). The Filter determines whether the original web text \\( T_w \\) and the synthetic text \\( T_s \\) match the image \\( I_w \\). Texts predicted as mismatched are considered noise and removed. Bootstrapped Dataset: Combine the filtered high-quality image-text pairs (from original web data and synthetic data) with human-annotated data to form a new bootstrapped dataset. Re-Pre-training: Pre-train a new BLIP model from scratch using the bootstrapped dataset. Effect: CapFilt significantly improved the model’s performance on various downstream tasks (like retrieval, captioning, VQA), demonstrating the effectiveness of improving noisy data quality through bootstrapping. BLIP also showcased the flexibility of a unified model for both understanding and generation tasks.\nBLIP-2 BLIP-2 (Li et al., 2023) addresses the high cost of VLP training by proposing an efficient pre-training strategy: freeze pre-trained image encoders and large language models, training only a lightweight bridging module, the Q-Former.\nCore Contributions:\nLeveraging Frozen Models: Avoids end-to-end training of the entire large model, significantly reducing computational costs and leveraging the capabilities of powerful pre-trained unimodal models. Q-Former (Querying Transformer): Proposed a lightweight Transformer structure as a trainable bridge connecting the frozen image encoder and the frozen LLM. Two-Stage Pre-training: Designed a two-stage strategy to effectively bridge the modality gap: Stage 1: Vision-Language Representation Learning: Bootstrapped from a frozen image encoder. Stage 2: Vision-to-Language Generative Learning: Bootstrapped from a frozen LLM. Architecture (Q-Former):\nQ-Former is a lightweight Transformer with 188M parameters. It uses a set of Learnable Query Embeddings (e.g., 32 vectors of 768 dimensions) as input. These query vectors interact with each other through Self-Attention layers. They interact with the image features output by the frozen image encoder through Cross-Attention layers to extract visual information. The output of the query vectors \\( Z \\) (e.g., \\( 32 \\times 768 \\) dimensions) has a much lower dimension than the original image features, acting as an Information Bottleneck, forcing the Q-Former to extract the visual information most relevant to the language model. Q-Former internally contains two sub-modules, an image Transformer and a text Transformer, which share self-attention layers. Fig. 9. (Left) Model architecture of Q-Former and BLIP-2’s first-stage vision-language representation learning objectives. (Right) The self-attention masking strategy for each objective to control query-text interaction. (Image source: Li et al., 2023)\nTwo-Stage Pre-training:\nStage 1 (Representation Learning):\nConnect the Q-Former to a frozen image encoder (e.g., CLIP ViT-L/14, EVA-CLIP ViT-g/14). Pre-train using image-text pairs, aiming for the Q-Former’s query vectors to learn to extract visual representations most relevant to the text. Jointly optimize three objectives similar to BLIP (sharing input format and model parameters, but freezing the image encoder and training only the Q-Former): Image-Text Contrastive (ITC) Loss: Align the Q-Former’s output query representations \\( z \\) and text representations \\( t \\). Uses In-batch Negatives. $$L_{ITC} = \\frac{1}{2N} \\sum_{i=1}^{N} \\left( -\\log \\frac{\\exp(s(z_i, t_i)/\\tau)}{\\sum_{j=1}^{N} \\exp(s(z_i, t_j)/\\tau)} -\\log \\frac{\\exp(s(z_i, t_i)/\\tau)}{\\sum_{j=1}^{N} \\exp(s(z_j, t_i)/\\tau)} \\right)$$ Image-Text Matching (ITM) Loss: Predict whether an image-text pair matches. Uses the Q-Former’s output multimodal query representation for classification. $$L_{ITM} = -\\mathbb{E}_{(I,T)\\sim D} [y \\log p_{match} + (1-y) \\log(1 - p_{match})]$$ Image-grounded Text Generation (ITG) Loss: Train the Q-Former to generate text. The query vectors need to capture all information required for text generation and pass it to the text tokens via self-attention layers. $$L_{ITG} = -\\mathbb{E}_{(I,T)\\sim D} \\sum_{k=1}^{L} \\log P(w_k | Z_q, w_{\\lt k}; \\theta_{Q-Former})$$ where $Z_q$ is the query output of the Q-Former. Different self-attention masks are used to control query-text interaction for different objectives. Stage 1 Total Loss Function: $$L_{Stage1} = L_{ITC} + L_{ITM} + L_{ITG}$$ Stage 2 (Generative Learning):\nConnect the Q-Former pre-trained in Stage 1 (and its connected frozen image encoder) to a frozen LLM (e.g., OPT series, FlanT5 series). Use a Fully Connected (FC) Layer to linearly project the Q-Former’s output query embeddings \\( Z \\) to the same dimension as the LLM’s text embeddings, obtaining soft visual prompts $P_Z$. Prepend the projected query embeddings as Soft Visual Prompts to the LLM’s input text embeddings. Training Objective: Train the Q-Former (and the FC layer) so that its output visual representations can be understood by the frozen LLM and used for text generation. For Decoder-only LLMs (e.g., OPT): Use standard language modeling loss, i.e., generate subsequent text based on the visual prompt. For Encoder-Decoder LLMs (e.g., FlanT5): Use prefix language modeling loss, splitting the text into prefix and suffix. The visual prompt and prefix are input to the Encoder, and the Decoder generates the suffix. $$L_{Stage2} = L_{LM} = -\\mathbb{E}_{(I, T_{prompt}, T_{gen})\\sim D} \\sum_{k=1}^{M} \\log P_{LLM}(w_k | P_Z, T_{prompt}, w_{\\lt k}; \\theta_{LLM\\_frozen})$$ where $\\theta_{L L M_{-} \\text {frozen }}$ are the parameters of the frozen LLM, used only for forward propagation and not involved in gradient updates. Fig. 10. BLIP-2’s second-stage vision-to-language generative pre-training, which bootstraps from frozen large language models (LLMs). (Top) Bootstrapping a decoder-based LLM (e.g. OPT). (Bottom) Bootstrapping an encoder-decoder-based LLM (e.g. FlanT5). (Image source: Li et al., 2023)\nEffects and Advantages:\nEfficiency: Since only the lightweight Q-Former is trained, the pre-training cost is much lower than end-to-end training of large models. High Performance: Achieved SOTA levels on tasks like VQA, Captioning, and Retrieval, even surpassing models with significantly more parameters (like Flamingo). Versatility: Can easily connect to different frozen image encoders and LLMs, leveraging the latest advancements in respective fields. Zero-Shot Capability: Leveraging powerful frozen LLMs (especially instruction-tuned FlanT5), BLIP-2 demonstrated impressive zero-shot instruction-based image-to-text generation capabilities, performing various visual-language tasks based on natural language instructions (e.g., visual dialogue, visual knowledge reasoning). LLaVA LLaVA (Large Language and Vision Assistant) (Liu et al., 2023) is a significant work in the open-source community for Visual Instruction Tuning, being the first to attempt extending the instruction tuning concept from NLP to the multimodal domain.\nCore Contributions:\nProposed Visual Instruction Tuning: Explored applying instruction tuning to language-image multimodal models, aiming to build general-purpose visual assistants. GPT-Assisted Data Generation: Facing the lack of visual instruction data, innovatively used a language-only model GPT-4 to generate multimodal language-image instruction-following data containing visual content. Built LLaVA Model: Proposed an end-to-end trained architecture connecting a pre-trained visual encoder (CLIP ViT-L/14) and a large language model (LLM, Vicuna). Created Evaluation Benchmark: Constructed LLaVA-Bench, comprising diverse and challenging tasks to evaluate the instruction-following capabilities of multimodal models. Open Source Contribution: Released the GPT-4 generated visual instruction data, model code, and pre-trained weights, greatly promoting community research in this direction. GPT-Assisted Visual Instruction Data Generation:\nThe key challenge LLaVA addressed was the lack of large-scale, high-quality visual instruction-following data. The researchers proposed a method using existing multimodal large models like GPT-4 to generate such data based on existing image-text pairs, essentially a form of knowledge distillation from the closed-source GPT-4 model.\nChallenge Faced: Simply extending image-caption pairs into the format (Instruction: Describe the image, Image -\u003e Answer: Caption) is cheap but lacks diversity in instructions and responses, as well as deep reasoning. Solution: Use GPT-4 as a “teacher model”. Since these models only accept text input, the researchers conveyed image content through Symbolic Representations: Captions: Provide overall or multi-faceted descriptions of the image scene. Bounding Boxes: Provide class concepts and spatial location information of objects in the image (e.g., person: [0.681, 0.242, 0.774, 0.694]). Prompting and In-context Learning: Input the symbolic representations (descriptions and bounding boxes) of the image to GPT-4. To guide GPT-4 to generate output in specific formats and content, the researchers manually designed a small number of high-quality Seed Examples, leveraging GPT-4’s In-context Learning ability for few-shot inference. Generating Three Types of Data (based on COCO images): Through carefully designed prompts, GPT-4 was guided to generate three types of instruction data: Conversation: Generate multi-turn dialogues simulating interaction between a human and an assistant about image content, including questions about object recognition, counting, localization, actions, relationships, etc. Detailed Description: Generate comprehensive, detailed descriptions of the image based on specific instructions (e.g., “Describe the image below in detail”). Complex Reasoning: Generate questions and answers requiring logical reasoning based on image content or combined with background knowledge (e.g., “What challenges might the person in the picture be facing?”). Fig. 11. One example to illustrate the instruction-following data. (Image source: Liu et al., 2023)\nDataset: A total of 158K unique language-image instruction samples were collected, specifically including: 58K conversation samples, 23K detailed description samples, and 77K complex reasoning samples. Experiments found that data generated by GPT-4 was generally of higher quality than that from ChatGPT. Fig. 12. LLaVA network architecture. (Image source: Liu et al., 2023)\nLLaVA’s architecture is designed to effectively combine the capabilities of pre-trained visual models and LLMs, as shown in the figure above.\nVisual Encoder \\( g(\\cdot) \\): Uses a frozen CLIP ViT-L/14 model. For an input image \\( \\mathbf{X}_{\\mathrm{v}} \\), it extracts visual features \\( \\mathbf{Z}_{\\mathrm{v}} = g(\\mathbf{X}_{\\mathrm{v}}) \\). The paper mentions experimenting with grid features from before and after the last Transformer layer.\nProjection Layer: Uses a trainable linear projection matrix \\( \\mathbf{W} \\) to map the visual features \\( \\mathbf{Z}_{\\mathrm{v}} \\) into the word embedding space of the language model. $$ \\mathbf{H}_{\\mathrm{v}} = \\mathbf{W} \\cdot \\mathbf{Z}_{\\mathrm{v}} $$ Here, \\( \\mathbf{H}_{\\mathrm{v}} \\) is a sequence of visual tokens whose dimension matches the LLM’s word embedding dimension. This simple linear projection is lightweight and efficient, facilitating rapid data-centric experiments. More complex connection methods (like gated cross-attention in Flamingo or Q-Former in BLIP-2) could be explored in future work.\nLarge Language Model (LLM) \\( f_{\\phi}(\\cdot) \\): Uses Vicuna, with its parameters denoted as \\( \\phi \\). The LLM receives the visual tokens \\( \\mathbf{H}_{\\mathrm{v}} \\) and the text instruction \\( \\mathbf{X}_{\\text{instruct}} \\), and autoregressively generates the answer \\( \\mathbf{X}_{\\mathrm{a}} \\).\nTwo-Stage Training:\nLLaVA employs a two-stage instruction fine-tuning process.\nStage 1: Feature Alignment Pre-training:\nGoal: Align the visual features \\( \\mathbf{H}_{\\mathrm{v}} \\) with the LLM’s word embedding space, which can be viewed as training a compatible “visual tokenizer” for the frozen LLM. Data: Used a filtered subset of the CC3M dataset (approx. 595K image-text pairs). These pairs were simply converted into instruction data: for an image \\( \\mathbf{X}_{\\mathrm{v}} \\), randomly select a simple descriptive instruction \\( \\mathbf{X}_{\\mathrm{q}} \\) (e.g., “Briefly describe this picture”), and use the original caption \\( \\mathbf{X}_{\\mathrm{c}} \\) as the answer \\( \\mathbf{X}_{\\mathrm{a}} \\). This can be considered a single-turn conversation. Training: Freeze the weights of the visual encoder \\( g(\\cdot) \\) and the LLM \\( f_{\\phi}(\\cdot) \\), and only train the projection layer \\( \\mathbf{W} \\). The training objective is to maximize the likelihood of the answer (i.e., the image caption). Stage 2: Fine-tuning End-to-End:\nGoal: Enhance the model’s instruction-following and conversational abilities on multimodal tasks. Data: Use the previously generated 158K visual instruction data (including conversation, detailed description, and complex reasoning types, sampled uniformly during training). Training: Freeze the visual encoder \\( g(\\cdot) \\), and train both the projection layer \\( \\mathbf{W} \\) and the LLM \\( f_{\\phi}(\\cdot) \\) weights. Training Objective:\nFor each image \\( \\mathbf{X}_{\\mathrm{v}} \\), multi-turn dialogue data \\( \\left(\\mathbf{X}_{\\mathrm{q}}^{1}, \\mathbf{X}_{\\mathrm{a}}^{1}, \\cdots, \\mathbf{X}_{\\mathrm{q}}^{T_{turns}}, \\mathbf{X}_{\\mathrm{a}}^{T_{turns}}\\right) \\) containing \\( T_{turns} \\) turns is generated, where \\( T_{turns} \\) is the total number of conversation turns. This data is organized into a sequence, and all answers \\( \\mathbf{X}_{\\mathrm{a}} \\) are treated as the model’s responses. The input sequence format follows the Vicuna style. In the \\( t \\)-th turn of the conversation, the instruction \\( \\mathbf{X}_{\\text{instruct}}^{t} \\) is defined as:\n$$ \\mathbf{X}_{\\text{instruct}}^{t} = \\left\\{ \\begin{array}{ll} \\text{Randomly choose } [\\mathbf{X}_{\\mathrm{q}}^{1}, \\mathbf{X}_{\\mathrm{v}}] \\text{or } [\\mathbf{X}_{\\mathrm{v}}, \\mathbf{X}_{\\mathrm{q}}^{1}], \u0026 \\text{ if } t=1 \\text{ (the first turn)} \\\\ \\mathbf{X}_{\\mathrm{q}}^{t}, \u0026 \\text{ if } t\u003e1 \\text{ (the remaining turns)} \\end{array} \\right. $$The objective is to predict the answer sequence \\( \\mathbf{X}_{\\mathrm{a}} = (\\mathbf{X}_{\\mathrm{a}}^{1}, \\dots, \\mathbf{X}_{\\mathrm{a}}^{T_{turns}}) \\). The model needs to maximize the probability of generating the correct answer sequence given the image \\( \\mathbf{X}_{\\mathrm{v}} \\) and all instructions \\( \\mathbf{X}_{\\text{instruct}} = (\\mathbf{X}_{\\text{instruct}}^{1}, \\dots, \\mathbf{X}_{\\text{instruct}}^{T_{turns}}) \\). For the complete answer sequence of length \\( L_{seq} \\) (concatenation of all \\( \\mathbf{X}_{\\mathrm{a}} \\) turns), the probability is calculated as follows:\n$$ p\\left(\\mathbf{X}_{\\mathrm{a}} \\mid \\mathbf{X}_{\\mathrm{v}}, \\mathbf{X}_{\\text {instruct }}\\right)=\\prod_{i=1}^{L_{seq}} p_{\\boldsymbol{\\theta}}\\left(x_i \\mid \\mathbf{X}_{\\mathrm{v}}, \\mathbf{X}_{\\text {instruct },\\lt i}, \\mathbf{X}_{\\mathrm{a},\\lt i}\\right) $$where:\n\\( \\boldsymbol{\\theta} \\) are the trainable parameters of the model. In Stage 1, \\( \\boldsymbol{\\theta} = \\{ \\mathbf{W} \\} \\). In Stage 2, \\( \\boldsymbol{\\theta} = \\{ \\mathbf{W}, \\phi \\} \\). \\( x_i \\) is the \\( i \\)-th token in the answer sequence \\( \\mathbf{X}_{\\mathrm{a}} \\). \\( \\mathbf{X}_{\\text{instruct},\\lt i} \\) and \\( \\mathbf{X}_{\\mathrm{a},\\lt i} \\) represent all instruction tokens and generated answer tokens received by the model before predicting \\( x_i \\). The training loss function is the Negative Log-Likelihood of the above probability, and the loss is calculated only on the answer tokens (i.e., tokens in \\( \\mathbf{X}_{\\mathrm{a}} \\)). Effects and Impact:\nLLaVA demonstrated impressive capabilities in multimodal dialogue, sometimes exhibiting behavior similar to multimodal GPT-4 on unseen images and instructions. After fine-tuning on the ScienceQA benchmark, the combination of LLaVA and GPT-4 achieved a state-of-the-art accuracy of 92.53% at the time.\nFig. 13. Accuracy (%) on Science QA dataset. (Image source: Liu et al., 2023)\nLLaVA’s success proved the effectiveness of visual instruction tuning. Its open-sourced data, code, and model greatly facilitated subsequent research on multimodal large models, paving new ways for building general-purpose AI assistants capable of understanding and following visual and language instructions.\nQwen-VL The Qwen-VL (Bai et al., 2023) model is the first open-source large vision-language model developed by the Qwen team. Its architecture consists of three main modules:\nLarge Language Model: Uses the pre-trained Qwen-7B text model as the language decoder. This part is responsible for understanding and generating text, consistent with standard LLM architectures.\nVisual Encoder: Employs a Vision Transformer to extract image features. Specifically, Qwen-VL initializes the visual encoding part using the ViT-bigG model from OpenCLIP. During training and inference, input images are resized to a specific resolution. The visual encoder extracts a set of image features by dividing the image into patches with a stride of 14.\nPosition-aware Vision-Language Adapter: To efficiently fuse long sequences of image features, an adapter is introduced to compress the visual feature sequence to a fixed length. Specifically, this adapter contains a set of randomly initialized learnable query vectors. It computes with the image features output by ViT through a single-layer cross-attention module, compressing the image features into a sequence of fixed length 256.\nThe attention calculation formula is as follows:\n$$ \\text{CrossAttn}(Q, K, V) = \\mathrm{softmax}\\!\\left(\\frac{QK^T}{\\sqrt{d}}\\right)V $$where \\(Q\\) is the matrix of trainable query vectors defined within the adapter, and both \\(K\\) and \\(V\\) directly use the image feature sequence output by the visual encoder (ViT) as keys and values.\nThrough this mechanism, the adapter can select and aggregate the most relevant information from numerous image features based on the learned query vectors. Furthermore, to mitigate the potential loss of spatial position information during image feature compression, 2D absolute position encodings are additionally incorporated into the query-key pairs in the attention calculation, enhancing the perception of the image’s spatial structure.\nFig. 14. The training pipeline of the Qwen-VL series. (Image source: Bai et al., 2023)\nQwen-VL adopts a “three-stage” progressive training strategy to inject visual perception capabilities into the general large model. The first stage freezes the LLM and trains only the visual modules; the second stage unfreezes and performs joint multi-task training; the third stage involves instruction fine-tuning to obtain the chat model. In the figure above, the snowflake ❄ indicates frozen components, and the flame 🔥 indicates components participating in training.\nTraining Strategy: The Qwen-VL series employs a three-stage progressive training flow:\nPure Image-Text Pre-training Stage:\nFix the language model (7B) parameters, training only the visual encoder and VL adapter. Use approximately 1.4 billion pairs of weakly labeled image-text data (77.3% English, 22.7% Chinese). Images are uniformly scaled to a lower resolution (e.g., 224×224) for efficiency. Use autoregressive language modeling to train the model to generate image descriptions. After about 50,000 steps (1.5 billion samples), preliminary image-text alignment capability is achieved (Qwen-VL). Multi-task Joint Training Stage:\nUnfreeze the language model, training it end-to-end together with the visual part. Increase the input image resolution (e.g., 448×448 or higher). Incorporate various fine-grained visual tasks (e.g., image captioning, visual question answering, content localization, OCR recognition, etc.), covering 7 major task categories. Training data mixes datasets from multiple sources, adding about 24.8 million OCR data points and 7.8 million pure text data points. All task data are randomly mixed for training, with each sample prefixed by a task identifier and padded to a sequence length of 2048. The model significantly improves capabilities in image understanding, cross-modal retrieval, localization, reading, etc. Supervised Fine-tuning (SFT) Stage:\nFine-tune on multimodal instruction data (approx. 350K samples) to obtain the dialogue-enhanced version, Qwen-VL-Chat. Specifically design complex data for multi-image reasoning, fine-grained localization, and multi-turn interaction tasks. During fine-tuning, freeze the visual encoder again, fine-tuning only the language model and the adapter. The final model exhibits excellent multimodal dialogue, instruction following, and complex reasoning abilities. Qwen2-VL Qwen2-VL (Wang et al., 2024) is an upgraded version of Qwen-VL, making advancements in handling variable-resolution visual inputs and fusing multimodal positional information.\nFig. 15. Qwen2-VL is capable of accurately identifying and comprehending the content within images, regardless of their clarity, resolution, or extreme aspect ratios.: (Wang et al., 2024)\nAs seen in the figure above, Qwen2-VL can accurately identify and understand content within images of varying resolutions and aspect ratios. It primarily employs the following techniques:\nNative Dynamic Resolution: Inspired by NaViT (Dehghani et al., 2023), the model can process images of arbitrary resolutions and dynamically convert them into variable-length visual token sequences.\nRemoves absolute position embeddings from ViT and introduces 2D Rotary Position Embedding (2D-RoPE) (Su et al., 2024; Su, 2021) to encode 2D spatial information. During inference, variable-resolution images are processed in packed batches, limiting the total token length to manage memory usage. After ViT output, an MLP compresses adjacent \\( 2 \\times 2 \\) tokens into one, reducing the sequence length input to the LLM. Visual tokens are wrapped with \u003c|vision_start|\u003e and \u003c|vision_end|\u003e. Multimodal Rotary Position Embedding (M-RoPE): Proposed a novel position embedding method that can uniformly handle positional information for text, images, and videos.\nDecomposes RoPE into three components: Temporal, Height, and Width. Text: All three components use the same position ID, equivalent to 1D-RoPE. Image: Temporal ID is constant; Height and Width IDs are assigned based on the token’s 2D position in the image. Video: Temporal ID increases with frame number; Height and Width IDs are assigned as in images. Multimodal Input: Position IDs for different modalities increase sequentially. Advantage: Uniformly encodes multimodal positional information, reduces the magnitude of image/video position IDs, facilitating extrapolation to longer sequences during inference. Fig. 16. Illustration of M-RoPE. By decomposing rotary embedding into temporal, height, and width components, M-RoPE can explicitly model the positional information of text, images, and video in LLM. (Image source: Wang et al., 2024)\nUnified Image and Video Understanding: Adopts a mixed training paradigm and specific architectural designs (like 3D convolution for video processing) to handle both images and videos simultaneously. Trains on a mixture of image and video data. Videos are sampled at 2 FPS. Integrates 3D convolution in ViT to process video input (handling \\( 2 \\times 14 \\times 14 \\) 3D patches), reducing the number of tokens. Images are treated as two identical video frames. Dynamically adjusts video frame resolution, limiting the total number of tokens per video segment (e.g., to 16384). Training: Follows Qwen-VL’s three-stage training: ViT pre-training -\u003e Full model pre-training -\u003e LLM instruction fine-tuning. Pre-training data includes image-text pairs, OCR, interleaved image-text documents, VQA, video dialogue, image knowledge, etc. Instruction fine-tuning uses the ChatML format. Released models in 2B, 8B, and 72B sizes, exploring the scaling laws of MLLMs.\nEffect: Qwen2-VL demonstrates outstanding performance in understanding images of various resolutions and aspect ratios, long video understanding (over 20 minutes), and visual agent capabilities.\nQwen2.5-VL Qwen2.5-VL (Bai et al., 2025) further optimizes efficiency and temporal modeling capabilities based on Qwen2-VL.\nFig. 17. The Qwen2.5-VL framework demonstrates the integration of a vision encoder and a language model decoder to process multimodal inputs. The vision encoder is designed to handle inputs at their native resolution and supports dynamic FPS sampling. TMRoPE aligns time IDs with absolute time along the temporal dimension. (Image source: Bai et al., 2025)\nModel Optimization:\nQwen2.5-VL incorporates several optimizations over Qwen2-VL, primarily including:\nEfficient ViT Architecture: Introduces Window Attention mechanism in the Vision Transformer, restricting attention computation in most layers to local windows (e.g., $8 \\times 8$ patches). This makes the computational complexity grow linearly with the number of image patches, significantly improving efficiency for high-resolution image processing. Meanwhile, global attention is performed only in a few layers (e.g., every 8 layers) to retain overall context information.\nDynamic FPS Sampling \u0026 Video Processing: Introduces Dynamic FPS (Frames Per Second) sampling mechanism, extending the dynamic resolution concept to the temporal dimension, enhancing the model’s adaptability to videos with varying frame rates. For video processing, it maintains the 3D patch structure ($2 \\times 14 \\times 14$) and combines dynamic FPS with time-aware encoding to optimize overall temporal modeling.\nStronger Data \u0026 Task Capability Support: The model is pre-trained and fine-tuned on large-scale (4.1T tokens), high-quality datasets, with a focus on enhancing document parsing (tables, charts, formulas, sheet music, etc.), object localization (supporting point and box annotations), long video understanding (hour-level), and Agent multi-task capabilities, broadening the application boundaries of multimodal understanding.\nData Augmentation:\nFull Document Parsing Data: Constructed HTML-formatted data containing tables, charts, formulas, images, sheet music, chemical formulas, including layout bounding boxes and coordinates. Localization Data: Expanded bounding box and point localization data covering over 10,000 categories, and synthesized hard examples containing non-existent objects and multiple instances of objects. Tools like Grounding DINO and SAM were used for data synthesis. OCR Data: Increased multilingual OCR data (covering major European languages, Japanese, Korean, Arabic, Vietnamese, etc.), including various scenarios like handwriting, dense text, web pages, formulas, charts, and tables. Video Data: Added dense captioning data for long videos (over half an hour) and trained using dynamic FPS sampling. Timestamp annotations include both seconds and HMSF formats. Agent Data: Collected screenshots and action trajectories from mobile, web, and desktop environments, unified into a function call format, and synthesized CoT reasoning processes. Effect: Qwen2.5-VL achieved SOTA performance on document understanding, fine-grained localization, long video understanding, and Agent tasks. The 72B version rivals or even surpasses GPT-4o and Claude 3.5 Sonnet on several benchmarks.\nQwen2.5-Omni Fig. 18. Qwen2.5-Omni is an end-to-end multimodal model designed to perceive diverse modalities, including text, images, audio, and video, while simultaneously generating text and natural speech responses in a streaming manner. (Image source: Qwen Team, 2025)\nQwen2.5-Omni (Qwen Team, 2025) is an end-to-end multimodal model similar to GPT-4o (OpenAI, 2024), supporting input processing across all modalities including text, image, audio, and video, and capable of simultaneously streaming text and natural speech output.\nAs shown in the figure below, Qwen2.5-Omni adopts the Thinker-Talker architecture, with key features including:\nFig. 19. Qwen2.5-Omni Overview. Adopts Thinker-Talker architecture. Thinker is tasked with text generation while Talker focuses on generating streaming speech tokens by receiving high-level representations directly from Thinker. (Image source: Qwen Team, 2025)\nUnified Multimodal Processing and Temporal Modeling:\nOmni-modal Perception: A single model can simultaneously process text, image, audio, and video inputs, achieving unified multimodal understanding. Fig. 20. An illustration of Time-aligned Multimodal RoPE (TMRoPE). (Image source: Qwen Team, 2025)\nTime-aligned Multimodal RoPE (TMRoPE): Further optimizes TMRoPE based on Qwen2.5-VL. Through a Time-interleaving structure, video and audio frames are chunked every 2 seconds and arranged chronologically, with video preceding audio within each chunk. All modalities are aligned using absolute timestamps (40ms granularity) and position encoding (TMRoPE), enabling precise audio-video synchronization.\nInput Processing Details: Text uses the Qwen tokenizer; audio is sampled at 16kHz, represented as 128-channel Mel spectrograms (25ms window, 10ms step), with each frame approx. 40ms, processed by the Qwen2-Audio encoder; images/videos are processed via Qwen2.5-VL’s ViT architecture, with video supporting dynamic FPS sampling.\nThinker-Talker Architecture Design and Functional Decoupling:\nProposes the innovative Thinker-Talker architecture, decoupling text generation and speech generation to avoid mutual interference while allowing end-to-end joint training. Thinker: Based on Qwen2.5’s Transformer decoder, processes multimodal input, generates high-level hidden representations (containing semantic and prosodic information) and text token outputs. Talker: A dual-track autoregressive Transformer decoder, receives hidden representations and text tokens from the Thinker, combined with the ability to disambiguate speech, autoregressively generates discrete speech tokens. Thinker and Talker share historical context, supporting end-to-end training, enhancing speech generation consistency and context retention. Efficient Streaming Capability:\nInput Streaming: Audio and visual encoders use Block-wise Processing, supporting streaming input and Prefilling. Output Streaming: Discrete speech tokens generated by the Talker are fed in real-time to a Streaming Audio Codec. The codec employs Sliding Window Block Attention (looking back 2 blocks, looking ahead 1 block) based on a Diffusion Transformer (DiT) to control the receptive field, enabling streaming generation. Uses Flow Matching (Lipman et al., 2022) to convert discrete tokens into Mel spectrograms, which are then streamed into an improved BigVGAN (Lee et al., 2022) to convert spectrograms into audio waveforms, effectively reducing first-packet latency and improving generation real-time performance. Training: Consists of three stages: Encoder-LLM alignment -\u003e Full model multimodal pre-training -\u003e Long context pre-training (32k). The Talker undergoes separate three-stage training: Context learning -\u003e DPO (optimizing stability) -\u003e Multi-speaker instruction fine-tuning (improving naturalness).\nEffect: Qwen2.5-Omni performs comparably or better than Qwen2.5-VL (vision) and Qwen2-Audio (audio) of similar scale on respective unimodal benchmarks. Achieves SOTA on multimodal fusion benchmarks like OmniBench. Speech instruction following capability is close to text instructions. Speech generation robustness and naturalness surpass most existing models.\nKimi-VL Kimi-VL (Kimi Team, 2025) is an open-source efficient Mixture-of-Experts (MoE) vision-language model.\nFig. 21. Model architecture of Kimi-VL and Kimi-VL-Thinking, consisting of a MoonViT that allows native-resolution images, an MLP projector, and a Mixture-of-Experts (MoE) language decoder. (Image source: Kimi Team, 2025)\nArchitecture Details:\nEfficient MoE Architecture: The language model part uses an MoE architecture (based on Moonlight, similar to DeepSeek-V3 architecture), with a total of 16B parameters, activating only 2.8B parameters per inference (e.g., activating 2/8 experts per layer). This significantly reduces computational cost while maintaining model performance. Supports a maximum context window of 128K tokens, suitable for long documents, long videos, etc.\nNative Resolution Vision Encoder: Proposes a 400M parameter vision encoder, MoonViT, supporting native resolution processing for images without scaling or padding, maximally preserving image details. The architecture is based on ViT and incorporates the following techniques:\nNaViT Patch n’ Pack strategy: Enables efficient batch processing of variable-length image sequences. Interpolated Absolute Position Embeddings: Initialized from SigLIP (Zhai et al. 2023), enhancing positional awareness. 2D Rotary Position Embeddings (2D-RoPE): Enhances spatial structure understanding. Dynamic Resolution Training: Samples images of different sizes during training to improve generalization. Multimodal Fusion Module: Image features output by MoonViT pass through a two-layer MLP Projector containing a Pixel Shuffle operation for spatial compression and format conversion. They are then concatenated with text token-level features and input into the MoE LLM for image-text fusion processing.\nLong Chain-of-Thought Reasoning : Based on the main model, a long-chain thinking training process, including Long CoT SFT and Reinforcement Learning optimization, enhances the model’s performance in multi-turn, multi-step reasoning tasks, supporting complex logical Q\u0026A and scene understanding.\nTraining:\nFig. 22. The pre-training stages of Kimi-VL and Kimi-VL-Thinking, including ViT pre-training, joint pre-training, joint cooling, and joint long-context activation. (Image source: Kimi Team, 2025)\nPre-training (4 stages, 4.4T tokens total): ViT Training (2.1T): Train MoonViT separately (initialized from SigLIP), using contrastive loss SigLIP and cross-entropy caption generation. $$ \\mathcal{L}=\\mathcal{L}_{\\text {siglip }}+\\lambda \\mathcal{L}_{\\text {caption }}, \\text { where } \\lambda=2 $$ Joint Pre-training (1.4T): Jointly train ViT, Projector, LLM (initialized from Moonlight 5.2T checkpoint), mixing text and multimodal data. Joint Cooling (0.6T): Continue joint training with high-quality text and multimodal data. Joint Long Context Activation (0.3T): Expand context from 8K to 128K using long text, long video, and long document data. Fig. 23. The post-training stages of Kimi-VL and Kimi-VL-Thinking, including two stages of joint SFT in 32K and 128K context, and further long-CoT SFT and RL stages to activate and enhance long thinking abilities. (Image source: Kimi Team, 2025)\nPost-Training: Joint SFT: Use ChatML format, fine-tune on mixed text and multimodal instruction data (first 32K then 128K context). Long CoT SFT: Perform SFT using a small amount of high-quality long CoT data to activate long-chain reasoning capabilities. Reinforcement Learning: Employ the same Online Policy Mirror Descent algorithm used for the KIMI K1.5 model (Kimi Team, 2025) for training. This stage aims to further enhance the model’s complex reasoning and planning abilities (e.g., error identification, backtracking, solution optimization) through reinforcement learning, enabling it to utilize long Chain-of-Thought (long CoT) context for implicit search, thereby approximating the effectiveness of explicit planning algorithms while maintaining the simplicity of autoregressive generation. Core Objective: Optimize the policy model $\\pi_{\\theta}$ such that for a question $x \\in \\mathcal{D}$, the generated chain-of-thought $z$ and final answer $y$ maximize the expected reward based on the ground truth answer $y^$: $$ \\max _{\\theta} \\mathbb{E}_{\\left(x, y^{*}\\right) \\sim \\mathcal{D},(y, z) \\sim \\pi_{\\theta}}\\left[r\\left(x, y, y^{*}\\right)\\right] $$ where $r(x, y, y^)$ is typically a correctness reward of 0 or 1.\nReward Mechanism:\nCorrectness Reward ($r$): Primarily based on the correctness of the final answer $y$, judged according to the task type: For programming problems: Judged by running automatically generated test cases. For math problems: Evaluated using a high-precision Chain-of-Thought reward model (Chain-of-Thought RM, with 98.5% accuracy). For visual problems: Utilizes diverse data sources like real-world images, synthetic visual reasoning data, and text-rendered images, defining rewards based on task objectives. Length Penalty: To address “overthinking” and improve token efficiency, an additional length reward $\\text{len_reward}(i)$ is introduced. For a question $x$, sample $k$ responses $(y_i, z_i)$ ($i=1, \\dots, k$) from the current policy. Let $\\text{len}(i)$ be the token length of response $i$, $\\text{min_len} = \\min_i \\text{len}(i)$, and $\\text{max_len} = \\max_i \\text{len}(i)$. If $\\text{max_len} \u003e \\text{min_len}$, the length reward is: $$ \\text{len_reward}(i) = \\begin{cases} \\lambda \u0026 \\text{if } r(x, y_i, y^*) = 1 \\\\ \\min(0, \\lambda) \u0026 \\text{if } r(x, y_i, y^*) = 0 \\end{cases} $$ where the length penalty factor $\\lambda = 0.5 - \\frac{\\text{len}(i) - \\text{min_len}}{\\text{max_len} - \\text{min_len}}$. The final total reward used for optimization is a weighted sum of the correctness reward and the length reward. This penalty is introduced gradually (warm-up). Training Characteristics:\nAlgorithm: Based on Online Policy Mirror Descent, the training process is iterative. In iteration $i$, the current model $\\pi_{\\theta_i}$ is used as the reference policy to optimize the following objective with relative entropy (KL divergence) regularization: $$ \\max _{\\theta} \\mathbb{E}_{\\left(x, y^{*}\\right) \\sim \\mathcal{D}}\\left[\\mathbb{E}_{(y, z) \\sim \\pi_{\\theta}}\\left[r\\left(x, y, y^{*}\\right)\\right]-\\tau \\operatorname{KL}\\left(\\pi_{\\theta}(x) \\| \\pi_{\\theta_{i}}(x)\\right)\\right] $$ where $\\tau \u003e 0$ controls the regularization strength. Optimization: Actual updates use off-policy data (i.e., sampled from the reference policy $\\pi_{\\theta_i}$) and approximate gradients. For each question $x$, sample $k$ responses $(y_j, z_j)$ from $\\pi_{\\theta_i}$, calculate the empirical average reward $\\bar{r} = \\frac{1}{k}\\sum_{j=1}^{k} r(x, y_j, y^*)$ as a baseline. The gradient of the model parameters $\\theta$ is approximated as: $$ \\frac{1}{k} \\sum_{j=1}^{k}\\left(\\nabla_{\\theta} \\log \\pi_{\\theta}\\left(y_{j}, z_{j} \\mid x\\right)\\left(r\\left(x, y_{j}, y^{*}\\right)-\\bar{r}\\right)-\\frac{\\tau}{2} \\nabla_{\\theta}\\left(\\log \\frac{\\pi_{\\theta}\\left(y_{j}, z_{j} \\mid x\\right)}{\\pi_{\\theta_{i}}\\left(y_{j}, z_{j} \\mid x\\right)}\\right)^{2}\\right) $$ This gradient form resembles policy gradient with baseline but includes an $l_2$ regularization term (gradient of the last term) and uses off-policy samples. The value network is discarded during training to encourage exploration. Sampling Strategy: To improve training efficiency, a combination is used: Curriculum Sampling: Gradually increase the difficulty of training problems from easy to hard. Prioritized Sampling: Prioritize sampling problems with lower historical success rates $s_i$ with probability proportional to $1-s_i$. o3 \u0026 o4-mini OpenAI’s o3 and o4-mini (OpenAI, 2025) are the latest iterations of its o-series reasoning models, characterized by Longer Thinking Time and Full Tool Access.\nCore Contributions:\nEnhanced Reasoning: Models are trained to think longer and deeper (akin to CoT or more complex reasoning processes) before responding, significantly improving performance on complex tasks like coding, math, science, and visual perception. o3 achieves SOTA on benchmarks like Codeforces, SWE-bench, and MMMU.\nFull Tool Access: Models can seamlessly call various tools, such as Web Search, Code Interpreter, GPT‑4o Image Generation, and Function Calling via API. The models are trained to autonomously decide when and how to use these tools to solve problems.\nMultimodal Reasoning: Models can directly integrate images into their chain of thought, enabling deep fusion of visual and textual reasoning, rather than just using images as input. This makes them excel at analyzing charts, diagrams, etc.\nEfficiency vs. Performance Trade-off: o3 is the current most powerful model, suitable for complex queries; o4-mini is optimized for speed and cost, with fewer parameters, but still performs well on math, coding, and visual tasks, especially adept at using tools (e.g., using a Python interpreter in the AIME competition).\nLarge-Scale Reinforcement Learning: The performance improvements of the o-series models are largely attributed to the application of large-scale reinforcement learning (RL), validating the potential of RL in enhancing reasoning capabilities, with performance scaling with increased compute.\nFig. 24. o3 model demonstrates its multimodal CoT capability by analyzing a user-uploaded image, identifying the ship, and using tools (web search) to find information, ultimately answering the ship’s name and its next port of call. (Image source: OpenAI, 2025)\nWorking Mechanism:\nLonger Thinking Time: Borrows the idea of “trading compute for performance” (Snell et al., 2024), improving performance on complex tasks by increasing computation at inference time (e.g., multiple sampling, using longer reasoning chains, search algorithms like MCTS), which might be more effective than simply increasing model parameters. The models are internally designed to perform multi-step reasoning or more complex computations. Users can adjust the model’s thinking time by selecting different reasoning effort settings (e.g., o4-mini-high).\nTool Use: Models learn tool usage strategies through RL or instruction fine-tuning. When faced with a problem, the model will:\nPlan: Analyze the problem, determine if tools are needed and which ones. Execute: Call the selected tools (e.g., perform a web search for latest information, run code for calculations). Integrate: Incorporate the results returned by the tools into its reasoning process to generate the final answer. This process can be multi-turn and iterative; the model can adjust its strategy based on the information returned by tools (e.g., performing a secondary search). Multimodal Chain-of-Thought (MCoT): Models can directly reference and analyze image content within their internal reasoning steps, such as identifying data points in a chart, understanding the steps in a flowchart, or interpreting details in a photograph. Interested readers can refer to the MCoT Survey (Wang et al., 2025) which introduces its extension to scenarios involving various modalities like images, videos, audio, 3D, tables/charts, etc.\nEffect:\nFig. 25. To highlight visual reasoning improvement versus our previous multimodal models, OpenAI tested o3 and o4-mini on a diverse set of human exams and ML benchmarks. These new visual reasoning models significantly outperform their predecessors on all multimodal tasks we tested. (Image source: OpenAI, 2025)\no3 and o4-mini demonstrate SOTA or near-SOTA performance on multiple benchmarks, especially on tasks requiring deep reasoning and tool assistance. Expert evaluations show they produce fewer serious errors compared to their predecessors o1/o3-mini, provide more useful and verifiable answers, and interact more naturally.\nSummary Multimodal Large Language Models are advancing towards being more comprehensive, intelligent, and efficient. They can not only understand and generate content across multiple modalities like text, images, videos, and audio, but also perform complex reasoning, planning, and tool invocation. In the future, we can expect further breakthroughs in MLLMs regarding efficiency optimization, deeper cross-modal fusion and reasoning, stronger temporal and spatial understanding capabilities, as well as safety and controllability.\nReferences [1] OpenAI. “Hello gpt-4o.” OpenAI Blog (2024).\n[2] DeepMind. “Gemini 2.5 Pro” DeepMind Blog (2025).\n[3] OpenAI. “Introducing OpenAI o3 and o4-mini.” OpenAI Blog (2025).\n[4] Zhang, Duzhen, et al. “Mm-llms: Recent advances in multimodal large language models.” arXiv preprint arXiv:2401.13601 (2024).\n[5] Dosovitskiy, Alexey, et al. “An image is worth 16x16 words: Transformers for image recognition at scale.” arXiv preprint arXiv:2010.11929 (2020).\n[6] Radford, Alec, et al. “Learning transferable visual models from natural language supervision.” International conference on machine learning. PMLR, 2021.\n[7] Li, Junnan, et al. “Blip: Bootstrapping language-image pre-training for unified vision-language understanding and generation.” International conference on machine learning. PMLR, 2022.\n[8] Li, Junnan, et al. “Align before fuse: Vision and language representation learning with momentum distillation.” Advances in neural information processing systems 34 (2021): 9694-9705.\n[9] Li, Junnan, et al. “Blip-2: Bootstrapping language-image pre-training with frozen image encoders and large language models.” International conference on machine learning. PMLR, 2023.\n[10] Liu, Haotian, et al. “Visual instruction tuning.” arXiv preprint arXiv:2304.08485 (2023).\n[11] Bai, Jinze, et al. “Qwen-vl: A frontier large vision-language model with versatile abilities.” arXiv preprint arXiv:2308.12966 1.2 (2023): 3.\n[12] Wang, Peng, et al. “Qwen2-vl: Enhancing vision-language model’s perception of the world at any resolution.” arXiv preprint arXiv:2409.12191 (2024).\n[13] Dehghani, Mostafa, et al. “Patch n’ pack: NaViT, a vision transformer for any aspect ratio and resolution.” Advances in Neural Information Processing Systems 36 (2023): 2252-2274.\n[14] Su, Jianlin, et al. “Roformer: Enhanced transformer with rotary position embedding.” Neurocomputing 568 (2024): 127063.\n[15] Su, Jianlin. “Transformer升级之路：4、二维位置的旋转位置编码.” (Path to Upgrading Transformers: 4. Rotary Position Embedding for 2D Positions) 科学空间 (Scientific Spaces) (blog) (2021).\n[16] Bai, Shuai, et al. “Qwen2.5-VL Technical Report.” arXiv preprint arXiv:2502.13923 (2025).\n[17] Xu, Jin, et al. “Qwen2.5-Omni Technical Report.” arXiv preprint arXiv:2503.20215 (2025).\n[18] Lipman, Yaron, et al. “Flow matching for generative modeling.” arXiv preprint arXiv:2210.02747 (2022).\n[19] Lee, Sang-gil, et al. “Bigvgan: A universal neural vocoder with large-scale training.” arXiv preprint arXiv:2206.04658 (2022).\n[20] Kimi Team. “Kimi-VL Technical Report.” arXiv preprint arXiv:2504.07491 (2025).\n[21] Zhai, Xiaohua, et al. “Sigmoid loss for language image pre-training.” Proceedings of the IEEE/CVF international conference on computer vision. 2023.\n[22] Kimi Team. “Kimi k1. 5: Scaling reinforcement learning with llms.” arXiv preprint arXiv:2501.12599 (2025).\n[23] Snell, Charlie, et al. “Scaling llm test-time compute optimally can be more effective than scaling model parameters.” arXiv preprint arXiv:2408.03314 (2024).\n[24] Wang, Yaoting, et al. “Multimodal chain-of-thought reasoning: A comprehensive survey.” arXiv preprint arXiv:2503.12605 (2025).\nCitation Citation: When reprinting or citing the content of this article, please indicate the original author and source.\nCited as:\nYue Shui. (May 2025). Multimodal Large Language Models. https://syhya.github.io/posts/2025-05-04-multimodal-llm/\nOr\n@article{yue_shui_multimodal_llm_2025, title = \"Multimodal Large Language Models\", author = \"Yue Shui\", journal = \"syhya.github.io\", year = \"2025\", month = \"May\", url = \"https://syhya.github.io/posts/2025-05-04-multimodal-llm/\" } ","wordCount":"10182","inLanguage":"en","image":"https://syhya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-05-04T12:00:00+08:00","dateModified":"2025-08-25T17:41:19+08:00","author":{"@type":"Person","name":"Yue Shui"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://syhya.github.io/posts/2025-05-04-multimodal-llm/"},"publisher":{"@type":"Organization","name":"Yue Shui Blog","logo":{"@type":"ImageObject","url":"https://syhya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://syhya.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://syhya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://syhya.github.io/zh/ title=简体中文 aria-label=简体中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://syhya.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://syhya.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://syhya.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://syhya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://syhya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Multimodal Large Language Models</h1><div class=post-meta><span title='2025-05-04 12:00:00 +0800 +0800'>2025-05-04</span>&nbsp;·&nbsp;48 min&nbsp;·&nbsp;10182 words&nbsp;·&nbsp;Yue Shui&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://syhya.github.io/zh/posts/2025-05-04-multimodal-llm/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#notations>Notations</a></li><li><a href=#multimodal-fundamentals>Multimodal Fundamentals</a><ul><li><a href=#what-is-multimodality>What is Multimodality?</a></li><li><a href=#why-do-we-need-multimodal-ai>Why Do We Need Multimodal AI?</a></li><li><a href=#common-multimodal-tasks>Common Multimodal Tasks</a></li></ul></li><li><a href=#key-technologies>Key Technologies</a><ul><li><a href=#vision-transformer-vit>Vision Transformer (ViT)</a></li><li><a href=#clip>CLIP</a></li><li><a href=#blip>BLIP</a></li><li><a href=#blip-2>BLIP-2</a></li><li><a href=#llava>LLaVA</a></li><li><a href=#qwen-vl>Qwen-VL</a></li><li><a href=#qwen2-vl>Qwen2-VL</a></li><li><a href=#qwen25-vl>Qwen2.5-VL</a></li><li><a href=#qwen25-omni>Qwen2.5-Omni</a></li><li><a href=#kimi-vl>Kimi-VL</a></li><li><a href=#o3--o4-mini>o3 & o4-mini</a></li></ul></li><li><a href=#summary>Summary</a></li><li><a href=#references>References</a></li><li><a href=#citation>Citation</a></li></ul></nav></div></details></div><div class=post-content><p>Humans interact with the world through multiple senses (vision, hearing, touch, etc.), with each sensory channel offering unique advantages in representing and communicating specific concepts. This multimodal interaction fosters our deep understanding of the world. One of the core goals in the field of artificial intelligence is to develop general-purpose assistants that can effectively follow multimodal instructions (such as visual and linguistic ones), enabling them to perform various real-world tasks like humans. In recent years, with the release of models like GPT-4o (<a href=https://openai.com/index/hello-gpt-4o/>OpenAI, 2024</a>), Gemini 2.5 Pro (<a href=https://deepmind.google/technologies/gemini/pro/>DeepMind, 2025</a>), and o3/o4-mini (<a href=https://openai.com/index/introducing-o3-and-o4-mini/>OpenAI, 2025</a>), <strong>Multimodal Large Language Models (MLLMs)</strong> have made significant progress. They can not only understand information from multiple modalities like images, videos, and audio but also perform complex reasoning and generation.</p><h2 id=notations>Notations<a hidden class=anchor aria-hidden=true href=#notations>#</a></h2><p>The following table lists the key mathematical symbols used in this article and their meanings to help you read more easily.</p><table><thead><tr><th style=text-align:left>Symbol</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left>\( I, \mathbf{X}_v \)</td><td style=text-align:left>Image input, \( I \) usually refers to the raw image matrix \( \in \mathbb{R}^{H \times W \times C} \)</td></tr><tr><td style=text-align:left>\( T, \mathbf{X}_c, \mathbf{X}_q, \mathbf{X}_a, \mathbf{X}_{\text{instruct}} \)</td><td style=text-align:left>Text input, specifically could refer to image caption (\( \mathbf{X}_c \)), user question (\( \mathbf{X}_q \)), model answer (\( \mathbf{X}_a \)), or instruction (\( \mathbf{X}_{\text{instruct}} \))</td></tr><tr><td style=text-align:left>\( V, \mathbf{Z}_v \)</td><td style=text-align:left>Raw image features or embedding sequence output by the image encoder</td></tr><tr><td style=text-align:left>\( L, \mathbf{H}_q, \mathbf{H}_a \)</td><td style=text-align:left>Text features or embedding sequence output by the text encoder</td></tr><tr><td style=text-align:left>\( \mathbf{H}_v \)</td><td style=text-align:left>Visual token sequence input to the LLM after processing by a projection layer</td></tr><tr><td style=text-align:left>\( Z \)</td><td style=text-align:left>Query embeddings output by Q-Former, serving as a compressed representation of visual information</td></tr><tr><td style=text-align:left>\( P_Z \)</td><td style=text-align:left>Soft Visual Prompt derived from the Q-Former output</td></tr><tr><td style=text-align:left>\( I_e, T_e \)</td><td style=text-align:left>Image and text embeddings in CLIP&rsquo;s shared multimodal embedding space</td></tr><tr><td style=text-align:left>\( z_p \)</td><td style=text-align:left>Embedding vector of a single image patch after linear projection in ViT</td></tr><tr><td style=text-align:left>\( x_{class} \)</td><td style=text-align:left>Embedding of the learnable <code>[class]</code> token used for classification tasks in ViT</td></tr><tr><td style=text-align:left>\( x_i \)</td><td style=text-align:left>The \( i \)-th element or token in a sequence (e.g., word \( w_i \) in a text sequence)</td></tr><tr><td style=text-align:left>\( E_{img}, g(\cdot) \)</td><td style=text-align:left>Image encoder model (e.g., ViT)</td></tr><tr><td style=text-align:left>\( E_{text}, f_{\phi}(\cdot) \)</td><td style=text-align:left>Text encoder or LLM</td></tr><tr><td style=text-align:left>\( E, \mathbf{W}, \mathbf{W}_i, \mathbf{W}_t \)</td><td style=text-align:left>Linear projection matrix, used for feature transformation or modality alignment</td></tr><tr><td style=text-align:left>\( E_{pos} \)</td><td style=text-align:left>Positional encoding vector, used to provide sequence position information to the Transformer</td></tr><tr><td style=text-align:left>\( Q, K, V \)</td><td style=text-align:left>Query, Key, Value matrices in the attention mechanism</td></tr><tr><td style=text-align:left>\( W_Q, W_K, W_V \)</td><td style=text-align:left>Learnable projection matrices used to compute Q, K, V from input</td></tr><tr><td style=text-align:left>\( \theta, \phi \)</td><td style=text-align:left>Set of trainable parameters for the entire model or a specific part (e.g., LLM \( \phi \))</td></tr><tr><td style=text-align:left>\( P \)</td><td style=text-align:left>Side length of an image patch defined in the ViT model</td></tr><tr><td style=text-align:left>\( N \)</td><td style=text-align:left>Batch Size, usually refers to the number of samples in a batch</td></tr><tr><td style=text-align:left>\( N_{patches} \)</td><td style=text-align:left>Number of image patches the ViT model divides an image into</td></tr><tr><td style=text-align:left>\( D \)</td><td style=text-align:left>Main dimension of embedding vectors in the model</td></tr><tr><td style=text-align:left>\( d, d_k \)</td><td style=text-align:left>Dimension of the key vector in the attention mechanism, used for scaling the dot product</td></tr><tr><td style=text-align:left>\( T_{turns} \)</td><td style=text-align:left>Total number of conversation turns in multi-turn dialogue data</td></tr><tr><td style=text-align:left>\( \mathcal{L} \)</td><td style=text-align:left>Loss function, the objective optimized by the model (e.g., \( \mathcal{L}_{ITC}, \mathcal{L}_{ITM}, \mathcal{L}_{LM}, \mathcal{L}_{CLIP}, \mathcal{L}_{siglip} \))</td></tr><tr><td style=text-align:left>\( \tau \)</td><td style=text-align:left>Learnable parameter, such as temperature in contrastive loss or KL regularization weight in reinforcement learning</td></tr><tr><td style=text-align:left>\( \lambda \)</td><td style=text-align:left>Hyperparameter, such as the weight of different loss terms or length penalty factor in reinforcement learning</td></tr><tr><td style=text-align:left>\( y \)</td><td style=text-align:left>Target label or category (e.g., ITM loss); or the final answer generated by the model (e.g., Kimi-VL RL)</td></tr><tr><td style=text-align:left>\( x \)</td><td style=text-align:left>Input data, context, or question</td></tr><tr><td style=text-align:left>\( z \)</td><td style=text-align:left>Intermediate reasoning steps or chain-of-thought generated by the model</td></tr><tr><td style=text-align:left>\( y^* \)</td><td style=text-align:left>Reference answer or ground truth answer</td></tr><tr><td style=text-align:left>$\operatorname{sim}(u, v) = s(u, v)$</td><td style=text-align:left>Similarity calculation between vectors \( u \) and \( v \), usually cosine similarity</td></tr><tr><td style=text-align:left>\( \mathbb{E} \)</td><td style=text-align:left>Mathematical expectation</td></tr><tr><td style=text-align:left>KL</td><td style=text-align:left>KL Divergence (Kullback–Leibler Divergence), used to measure the difference between two probability distributions</td></tr><tr><td style=text-align:left>\( \pi_{\theta} \)</td><td style=text-align:left>Policy model, outputs actions or text sequences based on parameters \( \theta \)</td></tr><tr><td style=text-align:left>\( r \)</td><td style=text-align:left>Reward function, evaluates the quality of the generated output</td></tr></tbody></table><h2 id=multimodal-fundamentals>Multimodal Fundamentals<a hidden class=anchor aria-hidden=true href=#multimodal-fundamentals>#</a></h2><p>Before diving into specific technologies, let&rsquo;s understand some basic concepts of multimodality.</p><h3 id=what-is-multimodality>What is Multimodality?<a hidden class=anchor aria-hidden=true href=#what-is-multimodality>#</a></h3><p><strong>Multimodality</strong> refers to the use of multiple different types of data or information channels (modalities) to represent and process information. Humans are inherently multimodal beings; we perceive and understand the world through <strong>vision, hearing, touch, smell and taste</strong>. In the field of artificial intelligence, multimodal learning aims to build models capable of processing and correlating information from different modalities (such as text, images, videos, audio, etc.).</p><figure class=align-center><img loading=lazy src=multimodality_data.png#center alt="Fig. 1. Multimodality Data. (Image source: GPT-4o Image Generation)" width=60%><figcaption><p>Fig. 1. Multimodality Data. (Image source: <a href=https://chatgpt.com/s/m_6814c5d31e288191a5409a7420ee30f4>GPT-4o Image Generation</a>)</p></figcaption></figure><p><strong>Common Modalities:</strong></p><ul><li><strong>Text:</strong> Natural language text, the primary means of information transmission and knowledge expression.</li><li><strong>Image:</strong> Static visual information, containing rich details of scenes, objects, and textures.</li><li><strong>Video:</strong> Dynamic visual information, composed of sequential image frames, often accompanied by audio. Video contains not only spatial information but also temporal information.</li><li><strong>Audio:</strong> Sound information, including speech, music, and environmental sounds.</li><li><strong>Others:</strong> Tabular data, <a href=https://zh.wikipedia.org/wiki/%E9%BB%9E%E9%9B%B2>3D point clouds</a>, sensor data (e.g., radar, LiDAR), biological signals (e.g., <a href=https://en.wikipedia.org/wiki/Electroencephalography>EEG</a>, <a href=https://en.wikipedia.org/wiki/Electrocardiography>ECG</a>), etc.</li></ul><h3 id=why-do-we-need-multimodal-ai>Why Do We Need Multimodal AI?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-multimodal-ai>#</a></h3><ol><li><strong>More Comprehensive World Understanding:</strong> The real world is multimodal. A single modality often provides only partial information. For example, text descriptions alone may struggle to fully convey a complex scene, whereas combining images or videos offers more intuitive and richer information. Multimodal models can integrate information from different sources to form a more comprehensive and accurate understanding.</li><li><strong>Enhanced Task Performance:</strong> In many tasks, combining information from multiple modalities can significantly improve performance. For instance, in Visual Question Answering (VQA), the model needs to understand both the image content and the text question to provide the correct answer. In video captioning, combining visual frames and audio information can generate more vivid and accurate descriptions.</li><li><strong>More Natural Interaction:</strong> Multimodal AI makes human-computer interaction more natural and flexible. Users can interact with AI systems through various means like voice, text, and images, and the AI system can respond in multiple modalities (e.g., generating text replies with images, or generating voice answers).</li><li><strong>Unlocking New Application Scenarios:</strong> Multimodal capabilities have given rise to many new applications, such as autonomous driving (fusing data from cameras, radar, LiDAR), medical diagnosis (combining medical images and patient records), content creation (text-to-image, text-to-video), virtual assistants, robot interaction, etc.</li><li><strong>Promoting Accessibility:</strong> Multimodal technology can assist individuals with sensory impairments. For example, image captioning can help visually impaired people understand image content, while speech recognition and synthesis can aid those with hearing or speech impairments in communication.</li></ol><h3 id=common-multimodal-tasks>Common Multimodal Tasks<a hidden class=anchor aria-hidden=true href=#common-multimodal-tasks>#</a></h3><p>The following table lists some common multimodal tasks, which typically require processing and generating information by combining multiple modalities.</p><table><thead><tr><th style=text-align:left>Task Name</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><a href=https://paperswithcode.com/task/visual-question-answering>Visual Question Answering (VQA)</a></td><td style=text-align:left>Generate text answers based on an image and a related question.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/image-captioning>Image/Video Captioning</a></td><td style=text-align:left>Generate natural language descriptions for images or videos.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/text-to-image-generation>Text-to-X Generation</a></td><td style=text-align:left>Generate corresponding image, video, or audio content from text descriptions.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/cross-modal-retrieval>Cross-Modal Retrieval</a></td><td style=text-align:left>Use one modality (e.g., text) to query relevant data in another modality (e.g., image).</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/multimodal-sentiment-analysis>Multimodal Sentiment Analysis</a></td><td style=text-align:left>Determine sentiment by combining information from text, audio, video, etc.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/visual-reasoning>Visual Reasoning</a></td><td style=text-align:left>Perform logical judgment and relationship inference based on image or video content.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/vision-language-navigation>Visual Language Navigation (VLN)</a></td><td style=text-align:left>Guide an agent to navigate in a visual environment based on natural language instructions.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/multimodal-machine-translation>Multimodal Machine Translation (MMT)</a></td><td style=text-align:left>Utilize relevant image information to assist text translation and resolve ambiguity.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/audio-visual-speech-recognition>Audio-Visual Speech Recognition (AVSR)</a></td><td style=text-align:left>Perform speech recognition by combining audio signals and visual information of the speaker&rsquo;s lip movements.</td></tr><tr><td style=text-align:left><a href=https://paperswithcode.com/task/visual-grounding>Visual Grounding</a></td><td style=text-align:left>Associate words or phrases in text with corresponding regions or objects in images or videos.</td></tr></tbody></table><h2 id=key-technologies>Key Technologies<a hidden class=anchor aria-hidden=true href=#key-technologies>#</a></h2><p>The development of multimodal large models is driven by a series of technologies. The figure below visually illustrates the related technologies for multimodal understanding and generation. The author will introduce some key models and methods among them.</p><figure class=align-center><img loading=lazy src=MLLMs_arch.png#center alt="Fig. 2. The general model architecture of MM-LLMs and the implementation choices for each component. (Image source: Zhang et al., 2024)" width=100%><figcaption><p>Fig. 2. The general model architecture of MM-LLMs and the implementation choices for each component. (Image source: <a href=https://arxiv.org/pdf/2401.13601>Zhang et al., 2024</a>)</p></figcaption></figure><h3 id=vision-transformer-vit>Vision Transformer (ViT)<a hidden class=anchor aria-hidden=true href=#vision-transformer-vit>#</a></h3><p><strong>Vision Transformer (ViT)</strong> (<a href=https://arxiv.org/abs/2010.11929>Dosovitskiy et al., 2020</a>) successfully applied the Transformer architecture to the field of computer vision, becoming the preferred visual encoder for many advanced MLLMs today.</p><figure class=align-center><img loading=lazy src=vit_overview.png#center alt="Fig. 3. ViT model overview. (Image source: Dosovitskiy et al., 2020)" width=100%><figcaption><p>Fig. 3. ViT model overview. (Image source: <a href=https://arxiv.org/abs/2010.11929>Dosovitskiy et al., 2020</a>)</p></figcaption></figure><p><strong>Core Idea:</strong> ViT treats an image as a sequence of <strong>Image Patches</strong> and then uses the Transformer&rsquo;s self-attention mechanism to process these patches, thereby capturing global dependencies.</p><p><strong>Workflow:</strong></p><ol><li><strong>Patch Embedding:</strong> Divide the input image \( I \in \mathbb{R}^{H \times W \times C} \) into \( N_{patches} \) fixed-size non-overlapping image patches \( x_p \in \mathbb{R}^{P^2 \times C} \), where \( (H, W) \) is the image resolution, \( C \) is the number of channels, \( P \) is the size of each patch, and \( N_{patches} = HW/P^2 \) is the number of patches.</li><li><strong>Linear Projection:</strong> Flatten each patch \( x_p \) into a 1D vector and map it to a \( D \)-dimensional embedding space using a learnable linear projection matrix \( E \), resulting in patch embeddings \( z_p = x_p E \).</li><li><strong>Position Embedding:</strong> To preserve the spatial position information of the patches, ViT adds learnable Position Embeddings \( E_{pos} \) to the patch embeddings.
\[ z_0 = [x_{class}; z_p^1; z_p^2; \dots; z_p^{N_{patches}}] + E_{pos}, \quad E \in \mathbb{R}^{(P^2 \cdot C) \times D}, E_{pos} \in \mathbb{R}^{(N_{patches}+1) \times D} \]
Often, a learnable <code>[class]</code> token embedding \( x_{class} \) is also added. Its corresponding vector at the Transformer&rsquo;s output is used for image classification tasks.</li><li><strong>Transformer Encoder:</strong> Feed the sequence of patch embeddings with added position encodings into a standard Transformer encoder. The encoder consists of multiple layers of <strong>Multi-Head Self-Attention (MSA)</strong> and <strong>Feed Forward Network (FFN)</strong>.<ul><li><strong>MSA:</strong> Captures global dependencies between image patches. For an input sequence \( Z_{l-1} \), the self-attention is computed as:
\[ \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V \]
where \( Q = Z_{l-1}W_Q, K = Z_{l-1}W_K, V = Z_{l-1}W_V \) are the query, key, and value matrices, and \( d_k \) is the dimension of the key vectors. Multi-head attention splits \( Q, K, V \) into multiple heads, computes attention in parallel, and then concatenates the results.</li><li><strong>FFN:</strong> Typically consists of two linear layers and a non-linear activation function (e.g., GELU).
The computation in each layer can be represented as:
\[ Z'_l = \text{MSA}(\text{LN}(Z_{l-1})) + Z_{l-1} \]
\[ Z_l = \text{FFN}(\text{LN}(Z'_l)) + Z'_l \]
where LN denotes Layer Normalization.</li></ul></li><li><strong>Output:</strong> The output \( Z_L \) of the Transformer encoder serves as the image&rsquo;s feature representation \( V \).</li></ol><figure class=align-center><img loading=lazy src=vit_bit_hybrid_compare.png#center alt="Fig. 4. Performance versus pre-training compute for different architectures: Vision Transformers, ResNets, and hybrids. Vision Transformers generally outperform ResNets with the same computational budget. Hybrids improve upon pure Transformers for smaller model sizes, but the gap vanishes for larger models. (Image source: Dosovitskiy et al., 2020)" width=100%><figcaption><p>Fig. 4. Performance versus pre-training compute for different architectures: Vision Transformers, ResNets, and hybrids. Vision Transformers generally outperform ResNets with the same computational budget. Hybrids improve upon pure Transformers for smaller model sizes, but the gap vanishes for larger models. (Image source: <a href=https://arxiv.org/abs/2010.11929>Dosovitskiy et al., 2020</a>)</p></figcaption></figure><p>Compared to traditional Convolutional Neural Networks (CNNs), ViT offers the following advantages:</p><ol><li><strong>Global Dependency Modeling</strong>: Self-attention directly connects any two patches, explicitly capturing long-range spatial relationships, making it better at integrating semantic information across the entire image than traditional CNNs.</li><li><strong>Strong Transferability from Large-Scale Pre-training</strong>: After pre-training on massive datasets like JFT-300M or ImageNet-22K, ViT can be easily transferred to over 20 downstream tasks such as classification, detection, and segmentation, with performance scaling almost linearly with model/data size.</li><li><strong>Simple Architecture, Easy to Scale and Parallelize</strong>: The pure Transformer stack is easy to scale in three dimensions: depth, width, and input resolution. Computations consist mainly of matrix multiplications and Softmax, naturally suited for large-batch parallel processing and mixed-precision training on GPUs/TPUs.</li></ol><p>As research progresses, ViT itself is continuously being optimized to meet the demands of MLLMs:</p><ol><li><strong>Native Dynamic Resolution:</strong> Traditional ViTs typically require a fixed input resolution. Models like Qwen2-VL and Kimi-VL have introduced the capability to handle dynamic resolutions. They often remove absolute position embeddings in ViT and instead use 2D rotary position embeddings to encode two-dimensional spatial information. This allows the model to process images of arbitrary resolutions and aspect ratios, converting them into variable-length visual token sequences, better preserving detailed information. Kimi-VL&rsquo;s MoonViT also borrows the image packing technique from NaViT, packing sequences of image patches with different resolutions into the Transformer, improving training efficiency.</li><li><strong>Window Attention:</strong> To reduce the quadratic computational complexity of self-attention when processing high-resolution images, Qwen2.5-VL employs window attention in most layers of its ViT. Attention computation is restricted within local windows, making the complexity linear with respect to the number of patches, significantly improving efficiency while maintaining global information interaction through a few full attention layers.</li><li><strong>Architecture Alignment with LLM:</strong> Models like Qwen2.5-VL and Kimi-VL have also fine-tuned their ViT architectures to be closer to LLM designs, such as using RMSNorm for normalization and SwiGLU as the activation function, to enhance computational efficiency and cross-modal compatibility.</li></ol><h3 id=clip>CLIP<a hidden class=anchor aria-hidden=true href=#clip>#</a></h3><p><strong>CLIP (Contrastive Language-Image Pre-training)</strong> (<a href=https://arxiv.org/abs/2103.00020>Radford et al., 2021</a>) is a landmark work in the multimodal field. It proposed a simple yet effective method for learning the association between images and text, laying the foundation for many subsequent MLLMs.</p><p><strong>Core Idea:</strong> CLIP aims to learn a <strong>Multimodal Embedding Space</strong> where matched image-text pairs have high similarity, and mismatched pairs have low similarity. It achieves this through <strong>Contrastive Learning</strong>, leveraging natural language supervision.</p><p><strong>Architecture:</strong> CLIP consists of two main parts:</p><ol><li><strong>Image Encoder:</strong> Can be a ResNet or ViT, responsible for encoding the input image \( I \) into image features \( V \).</li><li><strong>Text Encoder:</strong> Typically a Transformer, responsible for encoding the input text \( T \) into text features \( L \).</li><li><strong>Linear Projection Layer:</strong> Projects the image features \( V \) and text features \( L \) into the shared multimodal embedding space, obtaining \( I_e = V W_i \) and \( T_e = L W_t \), where \( W_i \) and \( W_t \) are learnable projection matrices.</li></ol><figure class=align-center><img loading=lazy src=clip.png#center alt="Fig. 5. CLIP Architecture Overview. CLIP jointly trains an image encoder and a text encoder to predict the correct pairings of a batch of (image, text) training examples. At test time the learned text encoder synthesizes a zero-shot linear classifier by embedding the names or descriptions of the target dataset&rsquo;s classes. (Image source: Radford et al., 2021)" width=100%><figcaption><p>Fig. 5. CLIP Architecture Overview. CLIP jointly trains an image encoder and a text encoder to predict the correct pairings of a batch of (image, text) training examples. At test time the learned text encoder synthesizes a zero-shot linear classifier by embedding the names or descriptions of the target dataset&rsquo;s classes. (Image source: <a href=https://arxiv.org/abs/2103.00020>Radford et al., 2021</a>)</p></figcaption></figure><p><strong>Training Data:</strong> CLIP&rsquo;s success is largely attributed to its massive pre-training dataset, <strong>WIT (WebImageText)</strong>. The research team collected 400 million (image, text) pairs from the internet. They built the dataset by searching for approximately 500,000 query terms (derived from Wikipedia vocabulary, high-frequency bigrams, Wikipedia article titles, and WordNet synsets), limiting the number of samples per query to a maximum of 20,000 to balance the data distribution. This approach of using native web image-text pairs is called <strong>natural language supervision</strong>, which avoids expensive manual annotation and allows for easy scaling of data size.</p><p><strong>Contrastive Loss:</strong> The core of CLIP is the contrastive learning objective. Given a batch of \( N \) (image, text) pairs \( \{(I_1, T_1), \dots, (I_N, T_N)\} \), the model&rsquo;s goal is to predict which of the \( N \times N \) possible pairings are the true pairings.</p><ol><li>Compute all image embeddings \( \{I_{e,1}, \dots, I_{e,N}\} \) and text embeddings \( \{T_{e,1}, \dots, T_{e,N}\} \). <strong>L2 normalization</strong> is typically applied, dividing each image or text embedding by its own L2 norm (Euclidean norm).</li><li>Calculate the <strong>Cosine Similarity</strong> between all \( N^2 \) pairs \( (I_{e,i}, T_{e,j}) \).
\[ \text{logits}_{i,j} = \text{sim}(I_{e,i}, T_{e,j}) \cdot \exp(\tau) = \frac{I_{e,i} \cdot T_{e,j}}{\|I_{e,i}\| \|T_{e,j}\|} \cdot \exp(\tau) \]
where \( \tau \) is a learnable <strong>temperature parameter</strong> used to scale the range of the logits.</li><li>Compute the <strong>Symmetric Cross-Entropy Loss</strong>. The problem is treated as two classification tasks:<ul><li>For each image \( I_i \), find the matching text \( T_i \) among the \( N \) texts. The loss is \( \mathcal{L}_{\text{image}} \).</li><li>For each text \( T_j \), find the matching image \( I_j \) among the \( N \) images. The loss is \( \mathcal{L}_{\text{text}} \).
The total loss is:
\[ \mathcal{L}_{CLIP} = \frac{1}{2} (\mathcal{L}_{\text{image}} + \mathcal{L}_{\text{text}}) \]
where,
\[ \mathcal{L}_{\text{image}} = -\frac{1}{N} \sum_{i=1}^N \log \frac{\exp(\text{sim}(I_{e,i}, T_{e,i}) / \tau)}{\sum_{j=1}^N \exp(\text{sim}(I_{e,i}, T_{e,j}) / \tau)} \]
\[ \mathcal{L}_{\text{text}} = -\frac{1}{N} \sum_{j=1}^N \log \frac{\exp(\text{sim}(I_{e,j}, T_{e,j}) / \tau)}{\sum_{i=1}^N \exp(\text{sim}(I_{e,i}, T_{e,j}) / \tau)} \]
This loss function encourages the similarity of positive pairs (matching image-text) to be higher than that of negative pairs (mismatched image-text).</li></ul></li></ol><p><details><summary markdown=span><strong>CLIP Core Pseudocode</strong></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># image_encoder - ResNet or Vision Transformer</span>
</span></span><span class=line><span class=cl><span class=c1># text_encoder - CBOW or Text Transformer</span>
</span></span><span class=line><span class=cl><span class=c1># I[n, h, w, c] - minibatch of aligned images</span>
</span></span><span class=line><span class=cl><span class=c1># T[n, l] - minibatch of aligned texts</span>
</span></span><span class=line><span class=cl><span class=c1># W_i[d_i, d_e] - learned proj of image to embed</span>
</span></span><span class=line><span class=cl><span class=c1># W_t[d_t, d_e] - learned proj of text to embed</span>
</span></span><span class=line><span class=cl><span class=c1># t - learned temperature parameter (tau in text)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># extract feature representations of each modality</span>
</span></span><span class=line><span class=cl><span class=n>I_f</span> <span class=o>=</span> <span class=n>image_encoder</span><span class=p>(</span><span class=n>I</span><span class=p>)</span> <span class=c1>#[n, d_i]</span>
</span></span><span class=line><span class=cl><span class=n>T_f</span> <span class=o>=</span> <span class=n>text_encoder</span><span class=p>(</span><span class=n>T</span><span class=p>)</span> <span class=c1>#[n, d_t]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># joint multimodal embedding [n, d_e]</span>
</span></span><span class=line><span class=cl><span class=c1># l2_normalize projects the embeddings onto the unit hypersphere</span>
</span></span><span class=line><span class=cl><span class=n>I_e</span> <span class=o>=</span> <span class=n>l2_normalize</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>dot</span><span class=p>(</span><span class=n>I_f</span><span class=p>,</span> <span class=n>W_i</span><span class=p>),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>T_e</span> <span class=o>=</span> <span class=n>l2_normalize</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>dot</span><span class=p>(</span><span class=n>T_f</span><span class=p>,</span> <span class=n>W_t</span><span class=p>),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># scaled pairwise cosine similarities [n, n]</span>
</span></span><span class=line><span class=cl><span class=c1># The temperature parameter t scales the logits</span>
</span></span><span class=line><span class=cl><span class=c1># Note: using dot product on normalized vectors is equivalent to cosine similarity</span>
</span></span><span class=line><span class=cl><span class=n>logits</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>dot</span><span class=p>(</span><span class=n>I_e</span><span class=p>,</span> <span class=n>T_e</span><span class=o>.</span><span class=n>T</span><span class=p>)</span> <span class=o>*</span> <span class=n>np</span><span class=o>.</span><span class=n>exp</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># symmetric loss function</span>
</span></span><span class=line><span class=cl><span class=c1># labels are the indices [0, 1, ..., n-1] indicating the correct pairings</span>
</span></span><span class=line><span class=cl><span class=n>labels</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># Calculate cross-entropy loss for image-to-text classification</span>
</span></span><span class=line><span class=cl><span class=c1># (Predict correct text for each image)</span>
</span></span><span class=line><span class=cl><span class=n>loss_i</span> <span class=o>=</span> <span class=n>cross_entropy_loss</span><span class=p>(</span><span class=n>logits</span><span class=p>,</span> <span class=n>labels</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span> <span class=c1># axis=1 for softmax over columns</span>
</span></span><span class=line><span class=cl><span class=c1># Calculate cross-entropy loss for text-to-image classification</span>
</span></span><span class=line><span class=cl><span class=c1># (Predict correct image for each text)</span>
</span></span><span class=line><span class=cl><span class=n>loss_t</span> <span class=o>=</span> <span class=n>cross_entropy_loss</span><span class=p>(</span><span class=n>logits</span><span class=p>,</span> <span class=n>labels</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span> <span class=c1># axis=0 for softmax over rows</span>
</span></span><span class=line><span class=cl><span class=c1># Final loss is the average of the two losses</span>
</span></span><span class=line><span class=cl><span class=n>loss</span> <span class=o>=</span> <span class=p>(</span><span class=n>loss_i</span> <span class=o>+</span> <span class=n>loss_t</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span>
</span></span></code></pre></div></details></p><p><strong>Zero-Shot Transfer:</strong> CLIP&rsquo;s powerful capability lies in its zero-shot transfer performance. For a new image classification task, without any fine-tuning, CLIP can make predictions as follows:</p><ol><li>Obtain all class names for the task (e.g., &ldquo;cat&rdquo;, &ldquo;dog&rdquo;).</li><li>Use <strong>Prompt Engineering</strong> to structure the class names into sentences, like &ldquo;A photo of a {label}.&rdquo; This helps bridge the distribution gap between the pre-training data (often sentences) and downstream tasks (often word labels). The CLIP paper found that using prompt templates and ensembling multiple prompts significantly improves performance (nearly 5% gain on ImageNet).</li><li>Use CLIP&rsquo;s text encoder to compute the text embeddings for each constructed sentence. These embeddings form the <strong>weight vectors</strong> of the zero-shot classifier.</li><li>For a new image to be classified, use CLIP&rsquo;s image encoder to compute its image embedding.</li><li>Calculate the cosine similarity between this image embedding and all class text embeddings.</li><li>The class with the highest similarity is predicted as the result.</li></ol><figure class=align-center><img loading=lazy src=clip_prompt_engineering.png#center alt="Fig. 6. Prompt engineering and ensembling improve zero-shot performance. Compared to the baseline of using contextless class names, prompt engineering and ensembling boost zero-shot classification performance by almost 5 points on average across 36 datasets. This improvement is similar to the gain from using 4 times more compute with the baseline zero-shot method but is &lsquo;free&rsquo; when amortized over many predictions. (Image source: Radford et al., 2021)" width=70%><figcaption><p>Fig. 6. Prompt engineering and ensembling improve zero-shot performance. Compared to the baseline of using contextless class names, prompt engineering and ensembling boost zero-shot classification performance by almost 5 points on average across 36 datasets. This improvement is similar to the gain from using 4 times more compute with the baseline zero-shot method but is &lsquo;free&rsquo; when amortized over many predictions. (Image source: <a href=https://arxiv.org/abs/2103.00020>Radford et al., 2021</a>)</p></figcaption></figure><p><strong>Impact of CLIP:</strong> CLIP demonstrated that powerful, transferable visual representations can be learned through large-scale natural language supervision and contrastive learning. Its learned multimodal embedding space and strong image encoder have been widely adopted in subsequent MLLMs (like Flamingo, BLIP-2, LLaVA) and text-to-image models (like DALL-E 2, Stable Diffusion).</p><p>CLIP primarily focuses on learning aligned representations but has limited capabilities in generative tasks. Subsequent work began exploring unified model architectures capable of both understanding and generation.</p><h3 id=blip>BLIP<a hidden class=anchor aria-hidden=true href=#blip>#</a></h3><p><strong>BLIP (Bootstrapping Language-Image Pre-training)</strong> (<a href=https://arxiv.org/abs/2201.12086>Li et al., 2022</a>) aimed to address the limitations of existing <strong>Vision-Language Pre-training (VLP)</strong> methods in terms of both models and data: models often excel at either understanding or generation, but not both; data relies on massive and noisy web image-text pairs.</p><p>BLIP proposed the <strong>Multimodal Encoder-Decoder (MED)</strong> architecture, designed to unify understanding and generation tasks. It combines the advantages of CLIP&rsquo;s contrastive learning and autoregressive generation, capable of handling multimodal data.</p><figure class=align-center><img loading=lazy src=blip_model_architecture.png#center alt="Fig. 7. BLIP Pre-training Model Architecture and Objectives (same parameters have the same color). We propose multimodal mixture of encoder-decoder (MED), a unified vision-language model which can operate in one of the three functionalities. (Image source: Li et al., 2022)" width=100%><figcaption><p>Fig. 7. BLIP Pre-training Model Architecture and Objectives (same parameters have the same color). We propose multimodal mixture of encoder-decoder (MED), a unified vision-language model which can operate in one of the three functionalities. (Image source: <a href=https://arxiv.org/abs/2201.12086>Li et al., 2022</a>)</p></figcaption></figure><ul><li><strong>Image Encoder:</strong> Uses ViT.</li><li><strong>Text Encoder/Decoder:</strong> Based on the BERT architecture but modified to accommodate multimodal tasks and different functional modes.<ul><li><strong>Unimodal Encoder:</strong> Standard ViT and BERT, processing images and text separately.</li><li><strong>Image-grounded Text Encoder:</strong> Inserts <strong>Cross-Attention (CA)</strong> layers between the Self-Attention (SA) layer and the Feed-Forward Network (FFN) layer in each Transformer block of the text encoder to inject visual information. A <code>[Encode]</code> token is prepended to the text input, and its output embedding serves as the multimodal representation of the image-text pair.</li><li><strong>Image-grounded Text Decoder:</strong> Replaces the bidirectional SA layers in the encoder with <strong>Causal Self-Attention</strong> layers for autoregressive generation. Shares the CA and FFN layers with the encoder. Uses a <code>[Decode]</code> token as the sequence start symbol.</li></ul></li></ul><p><strong>Pre-training Objectives:</strong> BLIP jointly optimizes three objectives:</p><ol><li><p><strong>Image-Text Contrastive (ITC) Loss:</strong> Similar to CLIP, uses the unimodal encoders to align the feature spaces of images and text. BLIP adopts the momentum encoder and soft label strategy proposed by <strong>ALBEF</strong> (<a href=https://arxiv.org/abs/2107.07651>Li et al., 2021</a>) to improve contrastive learning.</p>$$L_{ITC} = \frac{1}{2N} \sum_{i=1}^{N} \left( -\log \frac{\exp(s(v_i, t_i)/\tau)}{\sum_{j=1}^{N} \exp(s(v_i, t_j)/\tau)} -\log \frac{\exp(s(v_i, t_i)/\tau)}{\sum_{j=1}^{N} \exp(s(v_j, t_i)/\tau)} \right)$$<p>where $v_i, t_j$ are image and text features, $s$ is the similarity function, and $\tau$ is the temperature parameter.</p></li><li><p><strong>Image-Text Matching (ITM) Loss:</strong> Uses the image-grounded text encoder to learn fine-grained image-text alignment. This is a binary classification task predicting whether an image-text pair is matched or mismatched. A hard negative mining strategy is employed.</p>$$L_{ITM} = -\mathbb{E}_{(I,T)\sim D} [y \log p_{match} + (1-y) \log(1 - p_{match})]$$<p>where $y$ is the label and $p_{match}$ is the matching probability.</p></li><li><p><strong>Language Modeling (LM) Loss:</strong> Uses the image-grounded text decoder to generate text descriptions based on the image. A standard cross-entropy loss (with label smoothing) is used.</p>$$L_{L M}=-\mathbb{E}_{(I, T) \sim D} \sum_{k=1}^L \log P\left(w_k \mid I, w_{\lt k} ; \theta\right)$$<p>where $w_k$ is a word in the text sequence and $\theta$ are the model parameters.</p></li></ol><p><strong>Total Loss Function:</strong> These three losses are typically optimized jointly (e.g., summed with equal weights):</p>$$L_{BLIP} = L_{ITC} + L_{ITM} + L_{LM}$$<p><strong>Parameter Sharing:</strong> For efficiency and the benefits of multi-task learning, the text encoder and decoder share all parameters except for the SA layers (i.e., embedding layer, CA layers, FFN layers).</p><p><strong>CapFilt (Captioning and Filtering)</strong> is an innovative dataset bootstrapping method used to generate high-quality synthetic captions for unlabeled web images and filter out noisy data (including original web text and synthetic text).</p><figure class=align-center><img loading=lazy src=blip_learning_framework.png#center alt="Fig. 8. BLIP Learning Framework. We introduce a captioner to produce synthetic captions for web images, and a filter to remove noisy image-text pairs. (Image source: Li et al., 2022)" width=100%><figcaption><p>Fig. 8. BLIP Learning Framework. We introduce a captioner to produce synthetic captions for web images, and a filter to remove noisy image-text pairs. (Image source: <a href=https://arxiv.org/abs/2201.12086>Li et al., 2022</a>)</p></figcaption></figure><ol><li><strong>Initialization:</strong> Initialize two modules using a pre-trained MED model: a Captioner (image-grounded text decoder) and a Filter (image-grounded text encoder).</li><li><strong>Fine-tuning:</strong> Fine-tune the Captioner (using LM loss) and Filter (using ITC and ITM losses) separately on a high-quality human-annotated dataset (e.g., COCO). This is a lightweight process.</li><li><strong>Generation and Filtering:</strong><ul><li>The Captioner generates synthetic captions \( T_s \) for web images \( I_w \).</li><li>The Filter determines whether the original web text \( T_w \) and the synthetic text \( T_s \) match the image \( I_w \). Texts predicted as mismatched are considered noise and removed.</li></ul></li><li><strong>Bootstrapped Dataset:</strong> Combine the filtered high-quality image-text pairs (from original web data and synthetic data) with human-annotated data to form a new bootstrapped dataset.</li><li><strong>Re-Pre-training:</strong> Pre-train a new BLIP model from scratch using the bootstrapped dataset.</li></ol><p><strong>Effect:</strong> CapFilt significantly improved the model&rsquo;s performance on various downstream tasks (like retrieval, captioning, VQA), demonstrating the effectiveness of improving noisy data quality through bootstrapping. BLIP also showcased the flexibility of a unified model for both understanding and generation tasks.</p><h3 id=blip-2>BLIP-2<a hidden class=anchor aria-hidden=true href=#blip-2>#</a></h3><p><strong>BLIP-2</strong> (<a href=https://arxiv.org/abs/2301.12597>Li et al., 2023</a>) addresses the high cost of VLP training by proposing an <strong>efficient</strong> pre-training strategy: freeze pre-trained image encoders and large language models, training only a lightweight bridging module, the Q-Former.</p><p><strong>Core Contributions:</strong></p><ol><li><strong>Leveraging Frozen Models:</strong> Avoids end-to-end training of the entire large model, significantly reducing computational costs and leveraging the capabilities of powerful pre-trained unimodal models.</li><li><strong>Q-Former (Querying Transformer):</strong> Proposed a lightweight Transformer structure as a trainable bridge connecting the frozen image encoder and the frozen LLM.</li><li><strong>Two-Stage Pre-training:</strong> Designed a two-stage strategy to effectively bridge the modality gap:<ul><li><strong>Stage 1: Vision-Language Representation Learning:</strong> Bootstrapped from a frozen image encoder.</li><li><strong>Stage 2: Vision-to-Language Generative Learning:</strong> Bootstrapped from a frozen LLM.</li></ul></li></ol><p><strong>Architecture (Q-Former):</strong></p><ul><li>Q-Former is a lightweight Transformer with 188M parameters.</li><li>It uses a set of <strong>Learnable Query Embeddings</strong> (e.g., 32 vectors of 768 dimensions) as input.</li><li>These query vectors interact with each other through <strong>Self-Attention layers</strong>.</li><li>They interact with the image features output by the frozen image encoder through <strong>Cross-Attention layers</strong> to extract visual information.</li><li>The output of the query vectors \( Z \) (e.g., \( 32 \times 768 \) dimensions) has a much lower dimension than the original image features, acting as an <strong>Information Bottleneck</strong>, forcing the Q-Former to extract the visual information most relevant to the language model.</li><li>Q-Former internally contains two sub-modules, an image Transformer and a text Transformer, which share self-attention layers.</li></ul><figure class=align-center><img loading=lazy src=blip2_stage1.png#center alt="Fig. 9. (Left) Model architecture of Q-Former and BLIP-2&rsquo;s first-stage vision-language representation learning objectives. (Right) The self-attention masking strategy for each objective to control query-text interaction. (Image source: Li et al., 2023)" width=100%><figcaption><p>Fig. 9. (Left) Model architecture of Q-Former and BLIP-2&rsquo;s first-stage vision-language representation learning objectives. (Right) The self-attention masking strategy for each objective to control query-text interaction. (Image source: <a href=https://arxiv.org/abs/2301.12597>Li et al., 2023</a>)</p></figcaption></figure><p><strong>Two-Stage Pre-training:</strong></p><ol><li><p><strong>Stage 1 (Representation Learning):</strong></p><ul><li>Connect the Q-Former to a <strong>frozen image encoder</strong> (e.g., CLIP ViT-L/14, EVA-CLIP ViT-g/14).</li><li>Pre-train using image-text pairs, aiming for the Q-Former&rsquo;s query vectors to learn to extract visual representations most relevant to the text.</li><li>Jointly optimize three objectives similar to BLIP (sharing input format and model parameters, but <strong>freezing the image encoder and training only the Q-Former</strong>):<ul><li><strong>Image-Text Contrastive (ITC) Loss:</strong> Align the Q-Former&rsquo;s output query representations \( z \) and text representations \( t \). Uses In-batch Negatives.
$$L_{ITC} = \frac{1}{2N} \sum_{i=1}^{N} \left( -\log \frac{\exp(s(z_i, t_i)/\tau)}{\sum_{j=1}^{N} \exp(s(z_i, t_j)/\tau)} -\log \frac{\exp(s(z_i, t_i)/\tau)}{\sum_{j=1}^{N} \exp(s(z_j, t_i)/\tau)} \right)$$</li><li><strong>Image-Text Matching (ITM) Loss:</strong> Predict whether an image-text pair matches. Uses the Q-Former&rsquo;s output multimodal query representation for classification.
$$L_{ITM} = -\mathbb{E}_{(I,T)\sim D} [y \log p_{match} + (1-y) \log(1 - p_{match})]$$</li><li><strong>Image-grounded Text Generation (ITG) Loss:</strong> Train the Q-Former to generate text. The query vectors need to capture all information required for text generation and pass it to the text tokens via self-attention layers.
$$L_{ITG} = -\mathbb{E}_{(I,T)\sim D} \sum_{k=1}^{L} \log P(w_k | Z_q, w_{\lt k}; \theta_{Q-Former})$$
where $Z_q$ is the query output of the Q-Former.</li></ul></li><li>Different self-attention masks are used to control query-text interaction for different objectives.</li><li><strong>Stage 1 Total Loss Function:</strong>
$$L_{Stage1} = L_{ITC} + L_{ITM} + L_{ITG}$$</li></ul></li><li><p><strong>Stage 2 (Generative Learning):</strong></p><ul><li>Connect the <strong>Q-Former pre-trained in Stage 1</strong> (and its connected frozen image encoder) to a <strong>frozen LLM</strong> (e.g., OPT series, FlanT5 series).</li><li>Use a <strong>Fully Connected (FC) Layer</strong> to linearly project the Q-Former&rsquo;s output query embeddings \( Z \) to the same dimension as the LLM&rsquo;s text embeddings, obtaining soft visual prompts $P_Z$.</li><li>Prepend the projected query embeddings as <strong>Soft Visual Prompts</strong> to the LLM&rsquo;s input text embeddings.</li><li><strong>Training Objective:</strong> Train the Q-Former (and the FC layer) so that its output visual representations can be understood by the frozen LLM and used for text generation.<ul><li>For <strong>Decoder-only LLMs (e.g., OPT):</strong> Use standard language modeling loss, i.e., generate subsequent text based on the visual prompt.</li><li>For <strong>Encoder-Decoder LLMs (e.g., FlanT5):</strong> Use prefix language modeling loss, splitting the text into prefix and suffix. The visual prompt and prefix are input to the Encoder, and the Decoder generates the suffix.
$$L_{Stage2} = L_{LM} = -\mathbb{E}_{(I, T_{prompt}, T_{gen})\sim D} \sum_{k=1}^{M} \log P_{LLM}(w_k | P_Z, T_{prompt}, w_{\lt k}; \theta_{LLM\_frozen})$$
where $\theta_{L L M_{-} \text {frozen }}$ are the parameters of the frozen LLM, used only for forward propagation and not involved in gradient updates.</li></ul></li></ul></li></ol><figure class=align-center><img loading=lazy src=blip2_stage2.png#center alt="Fig. 10. BLIP-2&rsquo;s second-stage vision-to-language generative pre-training, which bootstraps from frozen large language models (LLMs). (Top) Bootstrapping a decoder-based LLM (e.g. OPT). (Bottom) Bootstrapping an encoder-decoder-based LLM (e.g. FlanT5). (Image source: Li et al., 2023)" width=90%><figcaption><p>Fig. 10. BLIP-2&rsquo;s second-stage vision-to-language generative pre-training, which bootstraps from frozen large language models (LLMs). (Top) Bootstrapping a decoder-based LLM (e.g. OPT). (Bottom) Bootstrapping an encoder-decoder-based LLM (e.g. FlanT5). (Image source: <a href=https://arxiv.org/abs/2301.12597>Li et al., 2023</a>)</p></figcaption></figure><p><strong>Effects and Advantages:</strong></p><ul><li><strong>Efficiency:</strong> Since only the lightweight Q-Former is trained, the pre-training cost is much lower than end-to-end training of large models.</li><li><strong>High Performance:</strong> Achieved SOTA levels on tasks like VQA, Captioning, and Retrieval, even surpassing models with significantly more parameters (like Flamingo).</li><li><strong>Versatility:</strong> Can easily connect to different frozen image encoders and LLMs, leveraging the latest advancements in respective fields.</li><li><strong>Zero-Shot Capability:</strong> Leveraging powerful frozen LLMs (especially instruction-tuned FlanT5), BLIP-2 demonstrated impressive <strong>zero-shot instruction-based image-to-text generation</strong> capabilities, performing various visual-language tasks based on natural language instructions (e.g., visual dialogue, visual knowledge reasoning).</li></ul><h3 id=llava>LLaVA<a hidden class=anchor aria-hidden=true href=#llava>#</a></h3><p><strong>LLaVA (Large Language and Vision Assistant)</strong> (<a href=https://arxiv.org/abs/2304.08485>Liu et al., 2023</a>) is a significant work in the open-source community for <strong>Visual Instruction Tuning</strong>, being the first to attempt extending the instruction tuning concept from NLP to the multimodal domain.</p><p><strong>Core Contributions:</strong></p><ol><li><strong>Proposed Visual Instruction Tuning:</strong> Explored applying instruction tuning to language-image multimodal models, aiming to build general-purpose visual assistants.</li><li><strong>GPT-Assisted Data Generation:</strong> Facing the lack of visual instruction data, innovatively used a <strong>language-only model GPT-4</strong> to generate multimodal language-image instruction-following data containing visual content.</li><li><strong>Built LLaVA Model:</strong> Proposed an end-to-end trained architecture connecting a pre-trained visual encoder (CLIP ViT-L/14) and a large language model (LLM, Vicuna).</li><li><strong>Created Evaluation Benchmark:</strong> Constructed LLaVA-Bench, comprising diverse and challenging tasks to evaluate the instruction-following capabilities of multimodal models.</li><li><strong>Open Source Contribution:</strong> Released the GPT-4 generated visual instruction data, model code, and pre-trained weights, greatly promoting community research in this direction.</li></ol><p><strong>GPT-Assisted Visual Instruction Data Generation:</strong></p><p>The key challenge LLaVA addressed was the lack of large-scale, high-quality visual instruction-following data. The researchers proposed a method using existing multimodal large models like GPT-4 to generate such data based on existing image-text pairs, essentially a form of <strong>knowledge distillation</strong> from the closed-source GPT-4 model.</p><ol><li><strong>Challenge Faced:</strong> Simply extending image-caption pairs into the format (Instruction: Describe the image, Image -> Answer: Caption) is cheap but lacks diversity in instructions and responses, as well as deep reasoning.</li><li><strong>Solution:</strong> Use GPT-4 as a &ldquo;teacher model&rdquo;. Since these models only accept text input, the researchers conveyed image content through <strong>Symbolic Representations</strong>:<ul><li><strong>Captions:</strong> Provide overall or multi-faceted descriptions of the image scene.</li><li><strong>Bounding Boxes:</strong> Provide class concepts and spatial location information of objects in the image (e.g., <code>person: [0.681, 0.242, 0.774, 0.694]</code>).</li></ul></li><li><strong>Prompting and In-context Learning:</strong> Input the symbolic representations (descriptions and bounding boxes) of the image to GPT-4. To guide GPT-4 to generate output in specific formats and content, the researchers manually designed a small number of high-quality <strong>Seed Examples</strong>, leveraging GPT-4&rsquo;s <strong>In-context Learning</strong> ability for few-shot inference.</li><li><strong>Generating Three Types of Data (based on COCO images):</strong> Through carefully designed prompts, GPT-4 was guided to generate three types of instruction data:<ul><li><strong>Conversation:</strong> Generate multi-turn dialogues simulating interaction between a human and an assistant about image content, including questions about object recognition, counting, localization, actions, relationships, etc.</li><li><strong>Detailed Description:</strong> Generate comprehensive, detailed descriptions of the image based on specific instructions (e.g., &ldquo;Describe the image below in detail&rdquo;).</li><li><strong>Complex Reasoning:</strong> Generate questions and answers requiring logical reasoning based on image content or combined with background knowledge (e.g., &ldquo;What challenges might the person in the picture be facing?&rdquo;).</li></ul></li></ol><figure class=align-center><img loading=lazy src=llava_instruction_data.png#center alt="Fig. 11. One example to illustrate the instruction-following data. (Image source: Liu et al., 2023)" width=100%><figcaption><p>Fig. 11. One example to illustrate the instruction-following data. (Image source: <a href=https://arxiv.org/abs/2304.08485>Liu et al., 2023</a>)</p></figcaption></figure><ol start=5><li><strong>Dataset:</strong> A total of <strong>158K</strong> unique language-image instruction samples were collected, specifically including: <strong>58K</strong> conversation samples, <strong>23K</strong> detailed description samples, and <strong>77K</strong> complex reasoning samples. Experiments found that data generated by GPT-4 was generally of higher quality than that from ChatGPT.</li></ol><figure class=align-center><img loading=lazy src=llava_architecture.png#center alt="Fig. 12. LLaVA network architecture. (Image source: Liu et al., 2023)" width=100%><figcaption><p>Fig. 12. LLaVA network architecture. (Image source: <a href=https://arxiv.org/abs/2304.08485>Liu et al., 2023</a>)</p></figcaption></figure><p>LLaVA&rsquo;s architecture is designed to effectively combine the capabilities of pre-trained visual models and LLMs, as shown in the figure above.</p><ol><li><p><strong>Visual Encoder \( g(\cdot) \):</strong> Uses a <strong>frozen CLIP ViT-L/14</strong> model. For an input image \( \mathbf{X}_{\mathrm{v}} \), it extracts visual features \( \mathbf{Z}_{\mathrm{v}} = g(\mathbf{X}_{\mathrm{v}}) \). The paper mentions experimenting with grid features from before and after the last Transformer layer.</p></li><li><p><strong>Projection Layer:</strong> Uses a <strong>trainable linear projection matrix \( \mathbf{W} \)</strong> to map the visual features \( \mathbf{Z}_{\mathrm{v}} \) into the word embedding space of the language model.</p>$$
\mathbf{H}_{\mathrm{v}} = \mathbf{W} \cdot \mathbf{Z}_{\mathrm{v}}
$$<p>Here, \( \mathbf{H}_{\mathrm{v}} \) is a sequence of visual tokens whose dimension matches the LLM&rsquo;s word embedding dimension. This simple linear projection is lightweight and efficient, facilitating rapid data-centric experiments. More complex connection methods (like gated cross-attention in Flamingo or Q-Former in BLIP-2) could be explored in future work.</p></li><li><p><strong>Large Language Model (LLM) \( f_{\phi}(\cdot) \):</strong> Uses <strong>Vicuna</strong>, with its parameters denoted as \( \phi \). The LLM receives the visual tokens \( \mathbf{H}_{\mathrm{v}} \) and the text instruction \( \mathbf{X}_{\text{instruct}} \), and autoregressively generates the answer \( \mathbf{X}_{\mathrm{a}} \).</p></li></ol><p><strong>Two-Stage Training:</strong></p><p>LLaVA employs a two-stage instruction fine-tuning process.</p><ol><li><p><strong>Stage 1: Feature Alignment Pre-training:</strong></p><ul><li><strong>Goal:</strong> Align the visual features \( \mathbf{H}_{\mathrm{v}} \) with the LLM&rsquo;s word embedding space, which can be viewed as training a compatible &ldquo;visual tokenizer&rdquo; for the frozen LLM.</li><li><strong>Data:</strong> Used a filtered subset of the CC3M dataset (approx. 595K image-text pairs). These pairs were simply converted into instruction data: for an image \( \mathbf{X}_{\mathrm{v}} \), randomly select a simple descriptive instruction \( \mathbf{X}_{\mathrm{q}} \) (e.g., &ldquo;Briefly describe this picture&rdquo;), and use the original caption \( \mathbf{X}_{\mathrm{c}} \) as the answer \( \mathbf{X}_{\mathrm{a}} \). This can be considered a single-turn conversation.</li><li><strong>Training:</strong> <strong>Freeze</strong> the weights of the visual encoder \( g(\cdot) \) and the LLM \( f_{\phi}(\cdot) \), and <strong>only train</strong> the projection layer \( \mathbf{W} \). The training objective is to maximize the likelihood of the answer (i.e., the image caption).</li></ul></li><li><p><strong>Stage 2: Fine-tuning End-to-End:</strong></p><ul><li><strong>Goal:</strong> Enhance the model&rsquo;s instruction-following and conversational abilities on multimodal tasks.</li><li><strong>Data:</strong> Use the previously generated <strong>158K</strong> visual instruction data (including conversation, detailed description, and complex reasoning types, sampled uniformly during training).</li><li><strong>Training:</strong> <strong>Freeze</strong> the visual encoder \( g(\cdot) \), and <strong>train both</strong> the projection layer \( \mathbf{W} \) and the <strong>LLM \( f_{\phi}(\cdot) \) weights</strong>.</li></ul></li></ol><p><strong>Training Objective:</strong></p><p>For each image \( \mathbf{X}_{\mathrm{v}} \), multi-turn dialogue data \( \left(\mathbf{X}_{\mathrm{q}}^{1}, \mathbf{X}_{\mathrm{a}}^{1}, \cdots, \mathbf{X}_{\mathrm{q}}^{T_{turns}}, \mathbf{X}_{\mathrm{a}}^{T_{turns}}\right) \) containing \( T_{turns} \) turns is generated, where \( T_{turns} \) is the total number of conversation turns. This data is organized into a sequence, and all answers \( \mathbf{X}_{\mathrm{a}} \) are treated as the model&rsquo;s responses. The input sequence format follows the Vicuna style. In the \( t \)-th turn of the conversation, the instruction \( \mathbf{X}_{\text{instruct}}^{t} \) is defined as:</p>$$
\mathbf{X}_{\text{instruct}}^{t} = \left\{ \begin{array}{ll} \text{Randomly choose } [\mathbf{X}_{\mathrm{q}}^{1}, \mathbf{X}_{\mathrm{v}}] \text{or } [\mathbf{X}_{\mathrm{v}}, \mathbf{X}_{\mathrm{q}}^{1}], & \text{ if } t=1 \text{ (the first turn)} \\ \mathbf{X}_{\mathrm{q}}^{t}, & \text{ if } t>1 \text{ (the remaining turns)} \end{array} \right.
$$<p>The objective is to predict the answer sequence \( \mathbf{X}_{\mathrm{a}} = (\mathbf{X}_{\mathrm{a}}^{1}, \dots, \mathbf{X}_{\mathrm{a}}^{T_{turns}}) \). The model needs to maximize the probability of generating the correct answer sequence given the image \( \mathbf{X}_{\mathrm{v}} \) and all instructions \( \mathbf{X}_{\text{instruct}} = (\mathbf{X}_{\text{instruct}}^{1}, \dots, \mathbf{X}_{\text{instruct}}^{T_{turns}}) \). For the complete answer sequence of length \( L_{seq} \) (concatenation of all \( \mathbf{X}_{\mathrm{a}} \) turns), the probability is calculated as follows:</p>$$
p\left(\mathbf{X}_{\mathrm{a}} \mid \mathbf{X}_{\mathrm{v}}, \mathbf{X}_{\text {instruct }}\right)=\prod_{i=1}^{L_{seq}} p_{\boldsymbol{\theta}}\left(x_i \mid \mathbf{X}_{\mathrm{v}}, \mathbf{X}_{\text {instruct },\lt i}, \mathbf{X}_{\mathrm{a},\lt i}\right)
$$<p>where:</p><ul><li>\( \boldsymbol{\theta} \) are the trainable parameters of the model.<ul><li>In Stage 1, \( \boldsymbol{\theta} = \{ \mathbf{W} \} \).</li><li>In Stage 2, \( \boldsymbol{\theta} = \{ \mathbf{W}, \phi \} \).</li></ul></li><li>\( x_i \) is the \( i \)-th token in the answer sequence \( \mathbf{X}_{\mathrm{a}} \).</li><li>\( \mathbf{X}_{\text{instruct},\lt i} \) and \( \mathbf{X}_{\mathrm{a},\lt i} \) represent all instruction tokens and generated answer tokens received by the model before predicting \( x_i \).</li><li>The training loss function is the <strong>Negative Log-Likelihood</strong> of the above probability, and the loss is calculated <strong>only on the answer tokens</strong> (i.e., tokens in \( \mathbf{X}_{\mathrm{a}} \)).</li></ul><p><strong>Effects and Impact:</strong></p><p>LLaVA demonstrated impressive capabilities in multimodal dialogue, sometimes exhibiting behavior similar to multimodal GPT-4 on unseen images and instructions. After fine-tuning on the ScienceQA benchmark, the combination of LLaVA and GPT-4 achieved a state-of-the-art accuracy of 92.53% at the time.</p><figure class=align-center><img loading=lazy src=llava_science_qa_accuracy.png#center alt="Fig. 13. Accuracy (%) on Science QA dataset. (Image source: Liu et al., 2023)" width=100%><figcaption><p>Fig. 13. Accuracy (%) on Science QA dataset. (Image source: <a href=https://arxiv.org/abs/2304.08485>Liu et al., 2023</a>)</p></figcaption></figure><p>LLaVA&rsquo;s success proved the effectiveness of visual instruction tuning. Its open-sourced data, code, and model greatly facilitated subsequent research on multimodal large models, paving new ways for building general-purpose AI assistants capable of understanding and following visual and language instructions.</p><h3 id=qwen-vl>Qwen-VL<a hidden class=anchor aria-hidden=true href=#qwen-vl>#</a></h3><p>The <strong>Qwen-VL</strong> (<a href=https://arxiv.org/abs/2308.12966>Bai et al., 2023</a>) model is the first open-source large vision-language model developed by the Qwen team. Its architecture consists of three main modules:</p><ul><li><p><strong>Large Language Model</strong>: Uses the pre-trained Qwen-7B text model as the language decoder. This part is responsible for understanding and generating text, consistent with standard LLM architectures.</p></li><li><p><strong>Visual Encoder</strong>: Employs a Vision Transformer to extract image features. Specifically, Qwen-VL initializes the visual encoding part using the ViT-bigG model from <a href=https://github.com/mlfoundations/open_clip>OpenCLIP</a>. During training and inference, input images are resized to a specific resolution. The visual encoder extracts a set of image features by dividing the image into patches with a stride of 14.</p></li><li><p><strong>Position-aware Vision-Language Adapter</strong>: To efficiently fuse long sequences of image features, an adapter is introduced to compress the visual feature sequence to a fixed length. Specifically, this adapter contains a set of randomly initialized <strong>learnable query vectors</strong>. It computes with the image features output by ViT through a single-layer <strong>cross-attention</strong> module, compressing the image features into a sequence of fixed length 256.</p></li></ul><p>The attention calculation formula is as follows:</p>$$
\text{CrossAttn}(Q, K, V) = \mathrm{softmax}\!\left(\frac{QK^T}{\sqrt{d}}\right)V
$$<p>where \(Q\) is the matrix of trainable query vectors defined within the adapter, and both \(K\) and \(V\) directly use the image feature sequence output by the visual encoder (ViT) as keys and values.</p><p>Through this mechanism, the adapter can select and aggregate the most relevant information from numerous image features based on the learned query vectors. Furthermore, to mitigate the potential loss of spatial position information during image feature compression, <strong>2D absolute position encodings</strong> are additionally incorporated into the query-key pairs in the attention calculation, enhancing the perception of the image&rsquo;s spatial structure.</p><figure class=align-center><img loading=lazy src=qwen_vl_pipeline.png#center alt="Fig. 14. The training pipeline of the Qwen-VL series. (Image source: Bai et al., 2023)" width=100%><figcaption><p>Fig. 14. The training pipeline of the Qwen-VL series. (Image source: <a href=https://arxiv.org/abs/2308.12966>Bai et al., 2023</a>)</p></figcaption></figure><p>Qwen-VL adopts a &ldquo;three-stage&rdquo; progressive training strategy to inject visual perception capabilities into the general large model. The first stage freezes the LLM and trains only the visual modules; the second stage unfreezes and performs joint multi-task training; the third stage involves instruction fine-tuning to obtain the chat model. In the figure above, the snowflake ❄ indicates frozen components, and the flame 🔥 indicates components participating in training.</p><p><strong>Training Strategy:</strong> The Qwen-VL series employs a <strong>three-stage</strong> progressive training flow:</p><ol><li><p><strong>Pure Image-Text Pre-training Stage</strong>:</p><ul><li>Fix the language model (7B) parameters, training only the visual encoder and VL adapter.</li><li>Use approximately 1.4 billion pairs of weakly labeled image-text data (77.3% English, 22.7% Chinese).</li><li>Images are uniformly scaled to a lower resolution (e.g., 224×224) for efficiency.</li><li>Use autoregressive language modeling to train the model to generate image descriptions.</li><li>After about 50,000 steps (1.5 billion samples), preliminary image-text alignment capability is achieved (Qwen-VL).</li></ul></li><li><p><strong>Multi-task Joint Training Stage</strong>:</p><ul><li>Unfreeze the language model, training it end-to-end together with the visual part.</li><li>Increase the input image resolution (e.g., 448×448 or higher).</li><li>Incorporate various fine-grained visual tasks (e.g., image captioning, visual question answering, content localization, OCR recognition, etc.), covering 7 major task categories.</li><li>Training data mixes datasets from multiple sources, adding about 24.8 million OCR data points and 7.8 million pure text data points.</li><li>All task data are randomly mixed for training, with each sample prefixed by a task identifier and padded to a sequence length of 2048.</li><li>The model significantly improves capabilities in image understanding, cross-modal retrieval, localization, reading, etc.</li></ul></li><li><p><strong>Supervised Fine-tuning (SFT) Stage</strong>:</p><ul><li>Fine-tune on multimodal instruction data (approx. 350K samples) to obtain the dialogue-enhanced version, Qwen-VL-Chat.</li><li>Specifically design complex data for multi-image reasoning, fine-grained localization, and multi-turn interaction tasks.</li><li>During fine-tuning, freeze the visual encoder again, fine-tuning only the language model and the adapter.</li><li>The final model exhibits excellent multimodal dialogue, instruction following, and complex reasoning abilities.</li></ul></li></ol><h3 id=qwen2-vl>Qwen2-VL<a hidden class=anchor aria-hidden=true href=#qwen2-vl>#</a></h3><p><strong>Qwen2-VL</strong> (<a href=https://arxiv.org/abs/2409.12191>Wang et al., 2024</a>) is an upgraded version of Qwen-VL, making advancements in handling variable-resolution visual inputs and fusing multimodal positional information.</p><figure class=align-center><img loading=lazy src=qwen2_vl.jpg#center alt="Fig. 15. Qwen2-VL is capable of accurately identifying and comprehending the content within images, regardless of their clarity, resolution, or extreme aspect ratios.: (Wang et al., 2024)" width=100%><figcaption><p>Fig. 15. Qwen2-VL is capable of accurately identifying and comprehending the content within images, regardless of their clarity, resolution, or extreme aspect ratios.: (<a href=https://arxiv.org/abs/2409.12191>Wang et al., 2024</a>)</p></figcaption></figure><p>As seen in the figure above, Qwen2-VL can accurately identify and understand content within images of varying resolutions and aspect ratios. It primarily employs the following techniques:</p><ul><li><p><strong>Native Dynamic Resolution:</strong> Inspired by <strong>NaViT</strong> (<a href=https://arxiv.org/abs/2307.06304>Dehghani et al., 2023</a>), the model can process images of arbitrary resolutions and dynamically convert them into variable-length visual token sequences.</p><ul><li>Removes absolute position embeddings from ViT and introduces <strong>2D Rotary Position Embedding (2D-RoPE)</strong> (<a href=https://arxiv.org/abs/2104.09864>Su et al., 2024</a>; <a href=https://spaces.ac.cn/archives/8397>Su, 2021</a>) to encode 2D spatial information.</li><li>During inference, variable-resolution images are processed in packed batches, limiting the total token length to manage memory usage.</li><li>After ViT output, an MLP compresses adjacent \( 2 \times 2 \) tokens into one, reducing the sequence length input to the LLM. Visual tokens are wrapped with <code>&lt;|vision_start|></code> and <code>&lt;|vision_end|></code>.</li></ul></li><li><p><strong>Multimodal Rotary Position Embedding (M-RoPE):</strong> Proposed a novel position embedding method that can uniformly handle positional information for text, images, and videos.</p><ul><li>Decomposes RoPE into three components: <strong>Temporal</strong>, <strong>Height</strong>, and <strong>Width</strong>.</li><li><strong>Text:</strong> All three components use the same position ID, equivalent to 1D-RoPE.</li><li><strong>Image:</strong> Temporal ID is constant; Height and Width IDs are assigned based on the token&rsquo;s 2D position in the image.</li><li><strong>Video:</strong> Temporal ID increases with frame number; Height and Width IDs are assigned as in images.</li><li><strong>Multimodal Input:</strong> Position IDs for different modalities increase sequentially.</li><li><strong>Advantage:</strong> Uniformly encodes multimodal positional information, reduces the magnitude of image/video position IDs, facilitating extrapolation to longer sequences during inference.</li></ul></li></ul><figure class=align-center><img loading=lazy src=mrope.png#center alt="Fig. 16. Illustration of M-RoPE. By decomposing rotary embedding into temporal, height, and width components, M-RoPE can explicitly model the positional information of text, images, and video in LLM. (Image source: Wang et al., 2024)" width=100%><figcaption><p>Fig. 16. Illustration of M-RoPE. By decomposing rotary embedding into temporal, height, and width components, M-RoPE can explicitly model the positional information of text, images, and video in LLM. (Image source: <a href=https://arxiv.org/abs/2409.12191>Wang et al., 2024</a>)</p></figcaption></figure><ul><li><strong>Unified Image and Video Understanding:</strong> Adopts a mixed training paradigm and specific architectural designs (like 3D convolution for video processing) to handle both images and videos simultaneously.<ul><li>Trains on a mixture of image and video data.</li><li>Videos are sampled at 2 FPS.</li><li>Integrates <strong>3D convolution</strong> in ViT to process video input (handling \( 2 \times 14 \times 14 \) 3D patches), reducing the number of tokens.</li><li>Images are treated as two identical video frames.</li><li>Dynamically adjusts video frame resolution, limiting the total number of tokens per video segment (e.g., to 16384).</li></ul></li></ul><p><strong>Training:</strong> Follows Qwen-VL&rsquo;s three-stage training: ViT pre-training -> Full model pre-training -> LLM instruction fine-tuning. Pre-training data includes image-text pairs, OCR, interleaved image-text documents, VQA, video dialogue, image knowledge, etc. Instruction fine-tuning uses the ChatML format. Released models in 2B, 8B, and 72B sizes, exploring the scaling laws of MLLMs.</p><p><strong>Effect:</strong> Qwen2-VL demonstrates outstanding performance in understanding images of various resolutions and aspect ratios, long video understanding (over 20 minutes), and visual agent capabilities.</p><h3 id=qwen25-vl>Qwen2.5-VL<a hidden class=anchor aria-hidden=true href=#qwen25-vl>#</a></h3><p><strong>Qwen2.5-VL</strong> (<a href=https://arxiv.org/abs/2502.13923>Bai et al., 2025</a>) further optimizes efficiency and temporal modeling capabilities based on Qwen2-VL.</p><figure class=align-center><img loading=lazy src=qwen2.5vl_arc.jpeg#center alt="Fig. 17. The Qwen2.5-VL framework demonstrates the integration of a vision encoder and a language model decoder to process multimodal inputs. The vision encoder is designed to handle inputs at their native resolution and supports dynamic FPS sampling. TMRoPE aligns time IDs with absolute time along the temporal dimension. (Image source: Bai et al., 2025)" width=100%><figcaption><p>Fig. 17. The Qwen2.5-VL framework demonstrates the integration of a vision encoder and a language model decoder to process multimodal inputs. The vision encoder is designed to handle inputs at their native resolution and supports dynamic FPS sampling. TMRoPE aligns time IDs with absolute time along the temporal dimension. (Image source: <a href=https://arxiv.org/abs/2502.13923>Bai et al., 2025</a>)</p></figcaption></figure><p><strong>Model Optimization:</strong></p><p>Qwen2.5-VL incorporates several optimizations over Qwen2-VL, primarily including:</p><ol><li><p><strong>Efficient ViT Architecture:</strong> Introduces <strong>Window Attention</strong> mechanism in the Vision Transformer, restricting attention computation in most layers to local windows (e.g., $8 \times 8$ patches). This makes the computational complexity grow linearly with the number of image patches, significantly improving efficiency for high-resolution image processing. Meanwhile, global attention is performed only in a few layers (e.g., every 8 layers) to retain overall context information.</p></li><li><p><strong>Dynamic FPS Sampling & Video Processing:</strong> Introduces <strong>Dynamic FPS (Frames Per Second) sampling</strong> mechanism, extending the dynamic resolution concept to the temporal dimension, enhancing the model&rsquo;s adaptability to videos with varying frame rates. For video processing, it maintains the 3D patch structure ($2 \times 14 \times 14$) and combines dynamic FPS with time-aware encoding to optimize overall temporal modeling.</p></li><li><p><strong>Stronger Data & Task Capability Support:</strong> The model is pre-trained and fine-tuned on large-scale (4.1T tokens), high-quality datasets, with a focus on enhancing <strong>document parsing</strong> (tables, charts, formulas, sheet music, etc.), <strong>object localization</strong> (supporting point and box annotations), <strong>long video understanding (hour-level)</strong>, and <strong>Agent multi-task capabilities</strong>, broadening the application boundaries of multimodal understanding.</p></li></ol><p><strong>Data Augmentation:</strong></p><ul><li><strong>Full Document Parsing Data:</strong> Constructed HTML-formatted data containing tables, charts, formulas, images, sheet music, chemical formulas, including layout bounding boxes and coordinates.</li><li><strong>Localization Data:</strong> Expanded bounding box and point localization data covering over 10,000 categories, and synthesized hard examples containing non-existent objects and multiple instances of objects. Tools like Grounding DINO and SAM were used for data synthesis.</li><li><strong>OCR Data:</strong> Increased multilingual OCR data (covering major European languages, Japanese, Korean, Arabic, Vietnamese, etc.), including various scenarios like handwriting, dense text, web pages, formulas, charts, and tables.</li><li><strong>Video Data:</strong> Added dense captioning data for long videos (over half an hour) and trained using dynamic FPS sampling. Timestamp annotations include both seconds and HMSF formats.</li><li><strong>Agent Data:</strong> Collected screenshots and action trajectories from mobile, web, and desktop environments, unified into a function call format, and synthesized CoT reasoning processes.</li></ul><p><strong>Effect:</strong> Qwen2.5-VL achieved SOTA performance on document understanding, fine-grained localization, long video understanding, and Agent tasks. The 72B version rivals or even surpasses GPT-4o and Claude 3.5 Sonnet on several benchmarks.</p><h3 id=qwen25-omni>Qwen2.5-Omni<a hidden class=anchor aria-hidden=true href=#qwen25-omni>#</a></h3><figure class=align-center><img loading=lazy src=qwen2.5_omni.png#center alt="Fig. 18. Qwen2.5-Omni is an end-to-end multimodal model designed to perceive diverse modalities, including text, images, audio, and video, while simultaneously generating text and natural speech responses in a streaming manner. (Image source: Qwen Team, 2025)" width=100%><figcaption><p>Fig. 18. Qwen2.5-Omni is an end-to-end multimodal model designed to perceive diverse modalities, including text, images, audio, and video, while simultaneously generating text and natural speech responses in a streaming manner. (Image source: <a href=https://arxiv.org/abs/2504.14786>Qwen Team, 2025</a>)</p></figcaption></figure><p><strong>Qwen2.5-Omni</strong> (<a href=https://arxiv.org/abs/2504.14786>Qwen Team, 2025</a>) is an end-to-end multimodal model similar to GPT-4o (<a href=https://openai.com/index/hello-gpt-4o/>OpenAI, 2024</a>), supporting input processing across all modalities including text, image, audio, and video, and capable of simultaneously <strong>streaming text and natural speech</strong> output.</p><p>As shown in the figure below, Qwen2.5-Omni adopts the <strong>Thinker-Talker</strong> architecture, with key features including:</p><figure class=align-center><img loading=lazy src=qwen2.5_omini_arc.png#center alt="Fig. 19. Qwen2.5-Omni Overview. Adopts Thinker-Talker architecture. Thinker is tasked with text generation while Talker focuses on generating streaming speech tokens by receiving high-level representations directly from Thinker. (Image source: Qwen Team, 2025)" width=80%><figcaption><p>Fig. 19. Qwen2.5-Omni Overview. Adopts Thinker-Talker architecture. Thinker is tasked with text generation while Talker focuses on generating streaming speech tokens by receiving high-level representations directly from Thinker. (Image source: <a href=https://arxiv.org/abs/2504.14786>Qwen Team, 2025</a>)</p></figcaption></figure><ol><li><p><strong>Unified Multimodal Processing and Temporal Modeling:</strong></p><ul><li><strong>Omni-modal Perception:</strong> A single model can simultaneously process text, image, audio, and video inputs, achieving unified multimodal understanding.</li></ul><figure class=align-center><img loading=lazy src=TMRoPE.png#center alt="Fig. 20. An illustration of Time-aligned Multimodal RoPE (TMRoPE). (Image source: Qwen Team, 2025)" width=100%><figcaption><p>Fig. 20. An illustration of Time-aligned Multimodal RoPE (TMRoPE). (Image source: <a href=https://arxiv.org/abs/2504.14786>Qwen Team, 2025</a>)</p></figcaption></figure><ul><li><p><strong>Time-aligned Multimodal RoPE (TMRoPE):</strong> Further optimizes TMRoPE based on Qwen2.5-VL. Through a <strong>Time-interleaving</strong> structure, video and audio frames are chunked every 2 seconds and arranged chronologically, with video preceding audio within each chunk. All modalities are aligned using absolute timestamps (40ms granularity) and position encoding (TMRoPE), enabling precise audio-video synchronization.</p></li><li><p><strong>Input Processing Details:</strong> Text uses the Qwen tokenizer; audio is sampled at 16kHz, represented as 128-channel Mel spectrograms (25ms window, 10ms step), with each frame approx. 40ms, processed by the Qwen2-Audio encoder; images/videos are processed via Qwen2.5-VL&rsquo;s ViT architecture, with video supporting dynamic FPS sampling.</p></li></ul></li><li><p><strong>Thinker-Talker Architecture Design and Functional Decoupling:</strong></p><ul><li>Proposes the innovative Thinker-Talker architecture, decoupling text generation and speech generation to avoid mutual interference while allowing end-to-end joint training.</li><li><strong>Thinker:</strong> Based on Qwen2.5&rsquo;s Transformer decoder, processes multimodal input, generates high-level hidden representations (containing semantic and prosodic information) and text token outputs.</li><li><strong>Talker:</strong> A dual-track autoregressive Transformer decoder, receives hidden representations and text tokens from the Thinker, combined with the ability to disambiguate speech, autoregressively generates discrete speech tokens.</li><li>Thinker and Talker share historical context, supporting end-to-end training, enhancing speech generation consistency and context retention.</li></ul></li><li><p><strong>Efficient Streaming Capability:</strong></p><ul><li><strong>Input Streaming:</strong> Audio and visual encoders use <strong>Block-wise Processing</strong>, supporting streaming input and Prefilling.</li><li><strong>Output Streaming:</strong><ul><li>Discrete speech tokens generated by the Talker are fed in real-time to a <strong>Streaming Audio Codec</strong>.</li><li>The codec employs <strong>Sliding Window Block Attention</strong> (looking back 2 blocks, looking ahead 1 block) based on a <strong>Diffusion Transformer (DiT)</strong> to control the receptive field, enabling streaming generation.</li><li>Uses <strong>Flow Matching</strong> (<a href=https://arxiv.org/abs/2210.02747>Lipman et al., 2022</a>) to convert discrete tokens into Mel spectrograms, which are then streamed into an improved <strong>BigVGAN</strong> (<a href=https://arxiv.org/abs/2206.04658>Lee et al., 2022</a>) to convert spectrograms into audio waveforms, effectively reducing first-packet latency and improving generation real-time performance.</li></ul></li></ul></li></ol><p><strong>Training:</strong> Consists of three stages: Encoder-LLM alignment -> Full model multimodal pre-training -> Long context pre-training (32k). The Talker undergoes separate three-stage training: Context learning -> DPO (optimizing stability) -> Multi-speaker instruction fine-tuning (improving naturalness).</p><p><strong>Effect:</strong> Qwen2.5-Omni performs comparably or better than Qwen2.5-VL (vision) and Qwen2-Audio (audio) of similar scale on respective unimodal benchmarks. Achieves SOTA on multimodal fusion benchmarks like OmniBench. Speech instruction following capability is close to text instructions. Speech generation robustness and naturalness surpass most existing models.</p><h3 id=kimi-vl>Kimi-VL<a hidden class=anchor aria-hidden=true href=#kimi-vl>#</a></h3><p><strong>Kimi-VL</strong> (<a href=https://arxiv.org/pdf/2504.07491>Kimi Team, 2025</a>) is an open-source <strong>efficient Mixture-of-Experts (MoE)</strong> vision-language model.</p><figure class=align-center><img loading=lazy src=kimi_vl_arch.png#center alt="Fig. 21. Model architecture of Kimi-VL and Kimi-VL-Thinking, consisting of a MoonViT that allows native-resolution images, an MLP projector, and a Mixture-of-Experts (MoE) language decoder. (Image source: Kimi Team, 2025)" width=100%><figcaption><p>Fig. 21. Model architecture of Kimi-VL and Kimi-VL-Thinking, consisting of a MoonViT that allows native-resolution images, an MLP projector, and a Mixture-of-Experts (MoE) language decoder. (Image source: <a href=https://arxiv.org/abs/2504.07491>Kimi Team, 2025</a>)</p></figcaption></figure><p><strong>Architecture Details:</strong></p><ol><li><p><strong>Efficient MoE Architecture:</strong>
The language model part uses an MoE architecture (based on Moonlight, similar to DeepSeek-V3 architecture), with a total of <strong>16B</strong> parameters, activating only <strong>2.8B</strong> parameters per inference (e.g., activating 2/8 experts per layer). This significantly reduces computational cost while maintaining model performance. Supports a maximum context window of <strong>128K tokens</strong>, suitable for long documents, long videos, etc.</p></li><li><p><strong>Native Resolution Vision Encoder:</strong>
Proposes a <strong>400M</strong> parameter vision encoder, MoonViT, supporting <strong>native resolution processing</strong> for images without scaling or padding, maximally preserving image details. The architecture is based on ViT and incorporates the following techniques:</p><ul><li><strong>NaViT Patch n&rsquo; Pack strategy</strong>: Enables efficient batch processing of variable-length image sequences.</li><li><strong>Interpolated Absolute Position Embeddings</strong>: Initialized from <strong>SigLIP</strong> (<a href=https://arxiv.org/abs/2303.15343>Zhai et al. 2023</a>), enhancing positional awareness.</li><li><strong>2D Rotary Position Embeddings (2D-RoPE)</strong>: Enhances spatial structure understanding.</li><li><strong>Dynamic Resolution Training</strong>: Samples images of different sizes during training to improve generalization.</li></ul></li><li><p><strong>Multimodal Fusion Module:</strong>
Image features output by MoonViT pass through a <strong>two-layer MLP Projector</strong> containing a <strong>Pixel Shuffle operation</strong> for spatial compression and format conversion. They are then concatenated with text token-level features and input into the MoE LLM for image-text fusion processing.</p></li><li><p><strong>Long Chain-of-Thought Reasoning :</strong>
Based on the main model, a long-chain thinking training process, including <strong>Long CoT SFT</strong> and <strong>Reinforcement Learning optimization</strong>, enhances the model&rsquo;s performance in multi-turn, multi-step reasoning tasks, supporting complex logical Q&amp;A and scene understanding.</p></li></ol><p><strong>Training:</strong></p><figure class=align-center><img loading=lazy src=kimi_vl_pretrain.png#center alt="Fig. 22. The pre-training stages of Kimi-VL and Kimi-VL-Thinking, including ViT pre-training, joint pre-training, joint cooling, and joint long-context activation. (Image source: Kimi Team, 2025)" width=100%><figcaption><p>Fig. 22. The pre-training stages of Kimi-VL and Kimi-VL-Thinking, including ViT pre-training, joint pre-training, joint cooling, and joint long-context activation. (Image source: <a href=https://arxiv.org/abs/2504.07491>Kimi Team, 2025</a>)</p></figcaption></figure><ul><li><strong>Pre-training (4 stages, 4.4T tokens total):</strong><ol><li><strong>ViT Training (2.1T):</strong> Train MoonViT separately (initialized from SigLIP), using contrastive loss SigLIP and cross-entropy caption generation.
$$
\mathcal{L}=\mathcal{L}_{\text {siglip }}+\lambda \mathcal{L}_{\text {caption }}, \text { where } \lambda=2
$$</li><li><strong>Joint Pre-training (1.4T):</strong> Jointly train ViT, Projector, LLM (initialized from Moonlight 5.2T checkpoint), mixing text and multimodal data.</li><li><strong>Joint Cooling (0.6T):</strong> Continue joint training with high-quality text and multimodal data.</li><li><strong>Joint Long Context Activation (0.3T):</strong> Expand context from 8K to 128K using long text, long video, and long document data.</li></ol></li></ul><figure class=align-center><img loading=lazy src=kimi_vl_post_training.png#center alt="Fig. 23. The post-training stages of Kimi-VL and Kimi-VL-Thinking, including two stages of joint SFT in 32K and 128K context, and further long-CoT SFT and RL stages to activate and enhance long thinking abilities. (Image source: Kimi Team, 2025)" width=100%><figcaption><p>Fig. 23. The post-training stages of Kimi-VL and Kimi-VL-Thinking, including two stages of joint SFT in 32K and 128K context, and further long-CoT SFT and RL stages to activate and enhance long thinking abilities. (Image source: <a href=https://arxiv.org/abs/2504.07491>Kimi Team, 2025</a>)</p></figcaption></figure><ul><li><strong>Post-Training:</strong><ol><li><strong>Joint SFT:</strong> Use ChatML format, fine-tune on mixed text and multimodal instruction data (first 32K then 128K context).</li><li><strong>Long CoT SFT:</strong> Perform SFT using a small amount of high-quality long CoT data to activate long-chain reasoning capabilities.</li><li><strong>Reinforcement Learning:</strong> Employ the same Online Policy Mirror Descent algorithm used for the <strong>KIMI K1.5</strong> model (<a href=https://arxiv.org/abs/2501.12599>Kimi Team, 2025</a>) for training. This stage aims to further enhance the model&rsquo;s complex reasoning and planning abilities (e.g., error identification, backtracking, solution optimization) through reinforcement learning, enabling it to utilize long Chain-of-Thought (long CoT) context for implicit search, thereby approximating the effectiveness of explicit planning algorithms while maintaining the simplicity of autoregressive generation.<ul><li><p><strong>Core Objective:</strong> Optimize the policy model $\pi_{\theta}$ such that for a question $x \in \mathcal{D}$, the generated chain-of-thought $z$ and final answer $y$ maximize the expected reward based on the ground truth answer $y^<em>$:
$$
\max _{\theta} \mathbb{E}_{\left(x, y^{*}\right) \sim \mathcal{D},(y, z) \sim \pi_{\theta}}\left[r\left(x, y, y^{*}\right)\right]
$$
where $r(x, y, y^</em>)$ is typically a correctness reward of 0 or 1.</p></li><li><p><strong>Reward Mechanism:</strong></p><ul><li><strong>Correctness Reward ($r$):</strong> Primarily based on the correctness of the final answer $y$, judged according to the task type:<ul><li>For <strong>programming</strong> problems: Judged by running automatically generated test cases.</li><li>For <strong>math</strong> problems: Evaluated using a high-precision Chain-of-Thought reward model (Chain-of-Thought RM, with 98.5% accuracy).</li><li>For <strong>visual</strong> problems: Utilizes diverse data sources like real-world images, synthetic visual reasoning data, and text-rendered images, defining rewards based on task objectives.</li></ul></li><li><strong>Length Penalty:</strong> To address &ldquo;overthinking&rdquo; and improve token efficiency, an additional length reward $\text{len_reward}(i)$ is introduced. For a question $x$, sample $k$ responses $(y_i, z_i)$ ($i=1, \dots, k$) from the current policy. Let $\text{len}(i)$ be the token length of response $i$, $\text{min_len} = \min_i \text{len}(i)$, and $\text{max_len} = \max_i \text{len}(i)$. If $\text{max_len} > \text{min_len}$, the length reward is:
$$
\text{len_reward}(i) = \begin{cases} \lambda & \text{if } r(x, y_i, y^*) = 1 \\ \min(0, \lambda) & \text{if } r(x, y_i, y^*) = 0 \end{cases}
$$
where the length penalty factor $\lambda = 0.5 - \frac{\text{len}(i) - \text{min_len}}{\text{max_len} - \text{min_len}}$. The final total reward used for optimization is a weighted sum of the correctness reward and the length reward. This penalty is introduced gradually (warm-up).</li></ul></li><li><p><strong>Training Characteristics:</strong></p><ul><li><strong>Algorithm:</strong> Based on <strong>Online Policy Mirror Descent</strong>, the training process is iterative. In iteration $i$, the current model $\pi_{\theta_i}$ is used as the reference policy to optimize the following objective with relative entropy (KL divergence) regularization:
$$
\max _{\theta} \mathbb{E}_{\left(x, y^{*}\right) \sim \mathcal{D}}\left[\mathbb{E}_{(y, z) \sim \pi_{\theta}}\left[r\left(x, y, y^{*}\right)\right]-\tau \operatorname{KL}\left(\pi_{\theta}(x) \| \pi_{\theta_{i}}(x)\right)\right]
$$
where $\tau > 0$ controls the regularization strength.</li><li><strong>Optimization:</strong> Actual updates use off-policy data (i.e., sampled from the reference policy $\pi_{\theta_i}$) and approximate gradients. For each question $x$, sample $k$ responses $(y_j, z_j)$ from $\pi_{\theta_i}$, calculate the empirical average reward $\bar{r} = \frac{1}{k}\sum_{j=1}^{k} r(x, y_j, y^*)$ as a baseline. The gradient of the model parameters $\theta$ is approximated as:
$$
\frac{1}{k} \sum_{j=1}^{k}\left(\nabla_{\theta} \log \pi_{\theta}\left(y_{j}, z_{j} \mid x\right)\left(r\left(x, y_{j}, y^{*}\right)-\bar{r}\right)-\frac{\tau}{2} \nabla_{\theta}\left(\log \frac{\pi_{\theta}\left(y_{j}, z_{j} \mid x\right)}{\pi_{\theta_{i}}\left(y_{j}, z_{j} \mid x\right)}\right)^{2}\right)
$$
This gradient form resembles policy gradient with baseline but includes an $l_2$ regularization term (gradient of the last term) and uses off-policy samples. The <strong>value network is discarded</strong> during training to encourage exploration.</li><li><strong>Sampling Strategy:</strong> To improve training efficiency, a combination is used:<ul><li><strong>Curriculum Sampling:</strong> Gradually increase the difficulty of training problems from easy to hard.</li><li><strong>Prioritized Sampling:</strong> Prioritize sampling problems with lower historical success rates $s_i$ with probability proportional to $1-s_i$.</li></ul></li></ul></li></ul></li></ol></li></ul><h3 id=o3--o4-mini>o3 & o4-mini<a hidden class=anchor aria-hidden=true href=#o3--o4-mini>#</a></h3><p>OpenAI&rsquo;s <strong>o3</strong> and <strong>o4-mini</strong> (<a href=https://openai.com/index/introducing-openai-o3-and-o4-mini/>OpenAI, 2025</a>) are the latest iterations of its o-series reasoning models, characterized by <strong>Longer Thinking Time</strong> and <strong>Full Tool Access</strong>.</p><p><strong>Core Contributions:</strong></p><ol><li><p><strong>Enhanced Reasoning:</strong> Models are trained to think longer and deeper (akin to CoT or more complex reasoning processes) before responding, significantly improving performance on complex tasks like coding, math, science, and visual perception. o3 achieves SOTA on benchmarks like Codeforces, SWE-bench, and MMMU.</p></li><li><p><strong>Full Tool Access:</strong> Models can seamlessly call various tools, such as <a href=https://openai.com/index/introducing-chatgpt-search/>Web Search</a>, <a href=https://platform.openai.com/docs/assistants/tools/code-interpreter>Code Interpreter</a>, <a href=https://openai.com/index/introducing-4o-image-generation/>GPT‑4o Image Generation</a>, and <a href=https://platform.openai.com/docs/guides/function-calling>Function Calling</a> via API. The models are trained to autonomously decide when and how to use these tools to solve problems.</p></li><li><p><strong>Multimodal Reasoning:</strong> Models can <strong>directly integrate images into their chain of thought</strong>, enabling deep fusion of visual and textual reasoning, rather than just using images as input. This makes them excel at analyzing charts, diagrams, etc.</p></li><li><p><strong>Efficiency vs. Performance Trade-off:</strong> o3 is the current most powerful model, suitable for complex queries; o4-mini is optimized for speed and cost, with fewer parameters, but still performs well on math, coding, and visual tasks, especially adept at using tools (e.g., using a Python interpreter in the AIME competition).</p></li><li><p><strong>Large-Scale Reinforcement Learning:</strong> The performance improvements of the o-series models are largely attributed to the application of large-scale reinforcement learning (RL), validating the potential of RL in enhancing reasoning capabilities, with performance scaling with increased compute.</p></li></ol><figure class=align-center><img loading=lazy src=thinking_with_images_static.webp#center alt="Fig. 24. o3 model demonstrates its multimodal CoT capability by analyzing a user-uploaded image, identifying the ship, and using tools (web search) to find information, ultimately answering the ship&rsquo;s name and its next port of call. (Image source: OpenAI, 2025)" width=100%><figcaption><p>Fig. 24. o3 model demonstrates its multimodal CoT capability by analyzing a user-uploaded image, identifying the ship, and using tools (web search) to find information, ultimately answering the ship&rsquo;s name and its next port of call. (Image source: <a href=https://openai.com/index/introducing-o3-and-o4-mini/>OpenAI, 2025</a>)</p></figcaption></figure><p><strong>Working Mechanism:</strong></p><ul><li><p><strong>Longer Thinking Time:</strong> Borrows the idea of &ldquo;trading compute for performance&rdquo; (<a href=https://arxiv.org/abs/2408.03314>Snell et al., 2024</a>), improving performance on complex tasks by increasing computation at inference time (e.g., multiple sampling, using longer reasoning chains, search algorithms like MCTS), which might be more effective than simply increasing model parameters. The models are internally designed to perform multi-step reasoning or more complex computations. Users can adjust the model&rsquo;s thinking time by selecting different <strong>reasoning effort</strong> settings (e.g., o4-mini-high).</p></li><li><p><strong>Tool Use:</strong> Models learn tool usage strategies through RL or instruction fine-tuning. When faced with a problem, the model will:</p><ul><li><strong>Plan:</strong> Analyze the problem, determine if tools are needed and which ones.</li><li><strong>Execute:</strong> Call the selected tools (e.g., perform a web search for latest information, run code for calculations).</li><li><strong>Integrate:</strong> Incorporate the results returned by the tools into its reasoning process to generate the final answer.
This process can be multi-turn and iterative; the model can adjust its strategy based on the information returned by tools (e.g., performing a secondary search).</li></ul></li><li><p><strong>Multimodal Chain-of-Thought (MCoT):</strong> Models can directly reference and analyze image content within their internal reasoning steps, such as identifying data points in a chart, understanding the steps in a flowchart, or interpreting details in a photograph. Interested readers can refer to the <strong>MCoT Survey</strong> (<a href=https://arxiv.org/abs/2503.12605>Wang et al., 2025</a>) which introduces its extension to scenarios involving various modalities like images, videos, audio, 3D, tables/charts, etc.</p></li></ul><p><strong>Effect:</strong></p><figure class=align-center><img loading=lazy src=o3_o4_benchmark.png#center alt="Fig. 25. To highlight visual reasoning improvement versus our previous multimodal models, OpenAI tested o3 and o4-mini on a diverse set of human exams and ML benchmarks. These new visual reasoning models significantly outperform their predecessors on all multimodal tasks we tested. (Image source: OpenAI, 2025)" width=100%><figcaption><p>Fig. 25. To highlight visual reasoning improvement versus our previous multimodal models, OpenAI tested o3 and o4-mini on a diverse set of human exams and ML benchmarks. These new visual reasoning models significantly outperform their predecessors on all multimodal tasks we tested. (Image source: <a href=https://openai.com/index/thinking-with-images/>OpenAI, 2025</a>)</p></figcaption></figure><p>o3 and o4-mini demonstrate SOTA or near-SOTA performance on multiple benchmarks, especially on tasks requiring deep reasoning and tool assistance. Expert evaluations show they produce fewer serious errors compared to their predecessors o1/o3-mini, provide more useful and verifiable answers, and interact more naturally.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Multimodal Large Language Models are advancing towards being more comprehensive, intelligent, and efficient. They can not only understand and generate content across multiple modalities like text, images, videos, and audio, but also perform complex reasoning, planning, and tool invocation. In the future, we can expect further breakthroughs in MLLMs regarding efficiency optimization, deeper cross-modal fusion and reasoning, stronger temporal and spatial understanding capabilities, as well as safety and controllability.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] OpenAI. <a href=https://openai.com/index/hello-gpt-4o/>&ldquo;Hello gpt-4o.&rdquo;</a> OpenAI Blog (2024).</p><p>[2] DeepMind. <a href=https://deepmind.google/technologies/gemini/pro/>&ldquo;Gemini 2.5 Pro&rdquo;</a> DeepMind Blog (2025).</p><p>[3] OpenAI. <a href=https://openai.com/index/introducing-o3-and-o4-mini/>&ldquo;Introducing OpenAI o3 and o4-mini.&rdquo;</a> OpenAI Blog (2025).</p><p>[4] Zhang, Duzhen, et al. <a href=https://arxiv.org/abs/2401.13601>&ldquo;Mm-llms: Recent advances in multimodal large language models.&rdquo;</a> arXiv preprint arXiv:2401.13601 (2024).</p><p>[5] Dosovitskiy, Alexey, et al. <a href=https://arxiv.org/abs/2010.11929>&ldquo;An image is worth 16x16 words: Transformers for image recognition at scale.&rdquo;</a> arXiv preprint arXiv:2010.11929 (2020).</p><p>[6] Radford, Alec, et al. <a href=https://arxiv.org/abs/2103.00020>&ldquo;Learning transferable visual models from natural language supervision.&rdquo;</a> International conference on machine learning. PMLR, 2021.</p><p>[7] Li, Junnan, et al. <a href=https://arxiv.org/abs/2201.12086>&ldquo;Blip: Bootstrapping language-image pre-training for unified vision-language understanding and generation.&rdquo;</a> International conference on machine learning. PMLR, 2022.</p><p>[8] Li, Junnan, et al. <a href=https://arxiv.org/abs/2107.07651>&ldquo;Align before fuse: Vision and language representation learning with momentum distillation.&rdquo;</a> Advances in neural information processing systems 34 (2021): 9694-9705.</p><p>[9] Li, Junnan, et al. <a href=https://arxiv.org/abs/2301.12597>&ldquo;Blip-2: Bootstrapping language-image pre-training with frozen image encoders and large language models.&rdquo;</a> International conference on machine learning. PMLR, 2023.</p><p>[10] Liu, Haotian, et al. <a href=https://arxiv.org/abs/2304.08485>&ldquo;Visual instruction tuning.&rdquo;</a> arXiv preprint arXiv:2304.08485 (2023).</p><p>[11] Bai, Jinze, et al. <a href=https://arxiv.org/abs/2308.12966>&ldquo;Qwen-vl: A frontier large vision-language model with versatile abilities.&rdquo;</a> arXiv preprint arXiv:2308.12966 1.2 (2023): 3.</p><p>[12] Wang, Peng, et al. <a href=https://arxiv.org/abs/2409.12191>&ldquo;Qwen2-vl: Enhancing vision-language model&rsquo;s perception of the world at any resolution.&rdquo;</a> arXiv preprint arXiv:2409.12191 (2024).</p><p>[13] Dehghani, Mostafa, et al. <a href=https://arxiv.org/abs/2307.06304>&ldquo;Patch n&rsquo; pack: NaViT, a vision transformer for any aspect ratio and resolution.&rdquo;</a> Advances in Neural Information Processing Systems 36 (2023): 2252-2274.</p><p>[14] Su, Jianlin, et al. <a href=https://arxiv.org/abs/2104.09864>&ldquo;Roformer: Enhanced transformer with rotary position embedding.&rdquo;</a> Neurocomputing 568 (2024): 127063.</p><p>[15] Su, Jianlin. <a href=https://spaces.ac.cn/archives/8397>&ldquo;Transformer升级之路：4、二维位置的旋转位置编码.&rdquo; (Path to Upgrading Transformers: 4. Rotary Position Embedding for 2D Positions)</a> <em>科学空间 (Scientific Spaces)</em> (blog) (2021).</p><p>[16] Bai, Shuai, et al. <a href=https://arxiv.org/abs/2502.13923>&ldquo;Qwen2.5-VL Technical Report.&rdquo;</a> arXiv preprint arXiv:2502.13923 (2025).</p><p>[17] Xu, Jin, et al. <a href=https://arxiv.org/abs/2503.20215>&ldquo;Qwen2.5-Omni Technical Report.&rdquo;</a> arXiv preprint arXiv:2503.20215 (2025).</p><p>[18] Lipman, Yaron, et al. <a href=https://arxiv.org/abs/2210.02747>&ldquo;Flow matching for generative modeling.&rdquo;</a> arXiv preprint arXiv:2210.02747 (2022).</p><p>[19] Lee, Sang-gil, et al. <a href=https://arxiv.org/abs/2206.04658>&ldquo;Bigvgan: A universal neural vocoder with large-scale training.&rdquo;</a> arXiv preprint arXiv:2206.04658 (2022).</p><p>[20] Kimi Team. <a href=https://arxiv.org/abs/2504.07491>&ldquo;Kimi-VL Technical Report.&rdquo;</a> arXiv preprint arXiv:2504.07491 (2025).</p><p>[21] Zhai, Xiaohua, et al. <a href=https://arxiv.org/abs/2303.15343>&ldquo;Sigmoid loss for language image pre-training.&rdquo;</a> Proceedings of the IEEE/CVF international conference on computer vision. 2023.</p><p>[22] Kimi Team. <a href=https://arxiv.org/abs/2501.12599>&ldquo;Kimi k1. 5: Scaling reinforcement learning with llms.&rdquo;</a> arXiv preprint arXiv:2501.12599 (2025).</p><p>[23] Snell, Charlie, et al. <a href=https://arxiv.org/abs/2408.03314>&ldquo;Scaling llm test-time compute optimally can be more effective than scaling model parameters.&rdquo;</a> arXiv preprint arXiv:2408.03314 (2024).</p><p>[24] Wang, Yaoting, et al. <a href=https://arxiv.org/abs/2503.12605>&ldquo;Multimodal chain-of-thought reasoning: A comprehensive survey.&rdquo;</a> arXiv preprint arXiv:2503.12605 (2025).</p><h2 id=citation>Citation<a hidden class=anchor aria-hidden=true href=#citation>#</a></h2><blockquote><p><strong>Citation</strong>: When reprinting or citing the content of this article, please indicate the original author and source.</p></blockquote><p><strong>Cited as:</strong></p><blockquote><p>Yue Shui. (May 2025). Multimodal Large Language Models.
<a href=https://syhya.github.io/posts/2025-05-04-multimodal-llm/>https://syhya.github.io/posts/2025-05-04-multimodal-llm/</a></p></blockquote><p>Or</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bibtex data-lang=bibtex><span class=line><span class=cl><span class=nc>@article</span><span class=p>{</span><span class=nl>yue_shui_multimodal_llm_2025</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>title</span>   <span class=p>=</span> <span class=s>&#34;Multimodal Large Language Models&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>author</span>  <span class=p>=</span> <span class=s>&#34;Yue Shui&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>journal</span> <span class=p>=</span> <span class=s>&#34;syhya.github.io&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>year</span>    <span class=p>=</span> <span class=s>&#34;2025&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>month</span>   <span class=p>=</span> <span class=s>&#34;May&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>url</span>     <span class=p>=</span> <span class=s>&#34;https://syhya.github.io/posts/2025-05-04-multimodal-llm/&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://syhya.github.io/tags/multimodal/>Multimodal</a></li><li><a href=https://syhya.github.io/tags/mllms/>MLLMs</a></li><li><a href=https://syhya.github.io/tags/vit/>ViT</a></li><li><a href=https://syhya.github.io/tags/clip/>CLIP</a></li><li><a href=https://syhya.github.io/tags/blip/>BLIP</a></li><li><a href=https://syhya.github.io/tags/llava/>LLaVA</a></li><li><a href=https://syhya.github.io/tags/openai/>OpenAI</a></li><li><a href=https://syhya.github.io/tags/qwen-vl/>Qwen-VL</a></li><li><a href=https://syhya.github.io/tags/kimi-vl/>Kimi-VL</a></li></ul><nav class=paginav><a class=prev href=https://syhya.github.io/posts/2025-05-17-vllm/><span class=title>« Prev</span><br><span>vLLM: High-Throughput, Memory-Efficient LLM Serving</span>
</a><a class=next href=https://syhya.github.io/posts/2025-04-18-deepseek-v2-v3/><span class=title>Next »</span><br><span>DeepSeek-V2 vs V3</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on x" href="https://x.com/intent/tweet/?text=Multimodal%20Large%20Language%20Models&amp;url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f&amp;hashtags=Multimodal%2cMLLMs%2cViT%2cCLIP%2cBLIP%2cLLaVA%2cOpenAI%2cQwen-VL%2cKimi-VL"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f&amp;title=Multimodal%20Large%20Language%20Models&amp;summary=Multimodal%20Large%20Language%20Models&amp;source=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f&title=Multimodal%20Large%20Language%20Models"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on whatsapp" href="https://api.whatsapp.com/send?text=Multimodal%20Large%20Language%20Models%20-%20https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on telegram" href="https://telegram.me/share/url?text=Multimodal%20Large%20Language%20Models&amp;url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Multimodal Large Language Models on ycombinator" href="https://news.ycombinator.com/submitlink?t=Multimodal%20Large%20Language%20Models&u=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-05-04-multimodal-llm%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://syhya.github.io/>Yue Shui Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>