<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基于深度学习的股票价格预测和量化策略 | Yue Shui 博客</title><meta name=keywords content="Deep learning,AI,RNN,LSTM,BiLSTM,GRU,LightGBM,Neural Networks,Stock Prediction,Financial Modeling,Machine Learning,Quantitative Investment,Portfolio Management,Financial Engineering,Algorithmic Trading,Time Series"><meta name=description content="摘要
股票市场是金融市场的重要组成部分，近些年来，股票市场蓬勃发展，股票价格预测和量化投资策略研究吸引了许多领域的研究学者。其中最近几年随着人工智能和机器学习的发展，学者们从传统的统计学模型迁移到了人工智能算法，尤其是在深度学习热潮掀起后，神经网络在股票价格预测和量化投资策略研究中取得了不错的效果。深度学习的目标是学习多层次的特征，通过组合低级特征构建抽象的高级特征，从而挖掘数据的分布式特征表示，基于此进行复杂的非线性建模，从而实现预测任务。其中 RNN 被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价，交易信息都是序列数据，因此之前有很多研究者，基于 RNN 来预测股票价格。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题，之后出现了诸如 GRU，Peephole LSTM，BiLSTM 等 LSTM 的变体。但传统的股票预测模型有些并未考虑时间因素，有些仅考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。"><meta name=author content="Yue Shui"><link rel=canonical href=https://syhya.github.io/zh/posts/2021-04-21-deep-learning-stock-prediction/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3dc782d653c34c6a0c8f1a261092c93b4c57a4549c8e3b36275bd5d52648e773.css integrity="sha256-PceC1lPDTGoMjxomEJLJO0xXpFScjjs2J1vV1SZI53M=" rel="preload stylesheet" as=style><link rel=icon href=https://syhya.github.io/%3C%E9%93%BE%E6%8E%A5%20/%20%E7%BB%9D%E5%AF%B9URL%3E><link rel=icon type=image/png sizes=16x16 href=https://syhya.github.io/%3C%E9%93%BE%E6%8E%A5%20/%20%E7%BB%9D%E5%AF%B9URL%3E><link rel=icon type=image/png sizes=32x32 href=https://syhya.github.io/%3C%E9%93%BE%E6%8E%A5%20/%20%E7%BB%9D%E5%AF%B9URL%3E><link rel=apple-touch-icon href=https://syhya.github.io/%3C%E9%93%BE%E6%8E%A5%20/%20%E7%BB%9D%E5%AF%B9URL%3E><link rel=mask-icon href=https://syhya.github.io/%3C%E9%93%BE%E6%8E%A5%20/%20%E7%BB%9D%E5%AF%B9URL%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/><link rel=alternate hreflang=zh href=https://syhya.github.io/zh/posts/2021-04-21-deep-learning-stock-prediction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>window.MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SZ2660B91F"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SZ2660B91F")}</script><meta property="og:url" content="https://syhya.github.io/zh/posts/2021-04-21-deep-learning-stock-prediction/"><meta property="og:site_name" content="Yue Shui 博客"><meta property="og:title" content="基于深度学习的股票价格预测和量化策略"><meta property="og:description" content="摘要 股票市场是金融市场的重要组成部分，近些年来，股票市场蓬勃发展，股票价格预测和量化投资策略研究吸引了许多领域的研究学者。其中最近几年随着人工智能和机器学习的发展，学者们从传统的统计学模型迁移到了人工智能算法，尤其是在深度学习热潮掀起后，神经网络在股票价格预测和量化投资策略研究中取得了不错的效果。深度学习的目标是学习多层次的特征，通过组合低级特征构建抽象的高级特征，从而挖掘数据的分布式特征表示，基于此进行复杂的非线性建模，从而实现预测任务。其中 RNN 被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价，交易信息都是序列数据，因此之前有很多研究者，基于 RNN 来预测股票价格。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题，之后出现了诸如 GRU，Peephole LSTM，BiLSTM 等 LSTM 的变体。但传统的股票预测模型有些并未考虑时间因素，有些仅考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-21T12:00:00+08:00"><meta property="article:modified_time" content="2025-06-29T21:43:56+08:00"><meta property="article:tag" content="Deep Learning"><meta property="article:tag" content="AI"><meta property="article:tag" content="RNN"><meta property="article:tag" content="LSTM"><meta property="article:tag" content="BiLSTM"><meta property="article:tag" content="GRU"><meta property="og:image" content="https://syhya.github.io/%3Copengraph%E3%80%81twitter-cards%20%E5%9B%BE%E7%89%87%E7%9A%84%E9%93%BE%E6%8E%A5%E6%88%96%E8%B7%AF%E5%BE%84%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://syhya.github.io/%3Copengraph%E3%80%81twitter-cards%20%E5%9B%BE%E7%89%87%E7%9A%84%E9%93%BE%E6%8E%A5%E6%88%96%E8%B7%AF%E5%BE%84%3E"><meta name=twitter:title content="基于深度学习的股票价格预测和量化策略"><meta name=twitter:description content="摘要
股票市场是金融市场的重要组成部分，近些年来，股票市场蓬勃发展，股票价格预测和量化投资策略研究吸引了许多领域的研究学者。其中最近几年随着人工智能和机器学习的发展，学者们从传统的统计学模型迁移到了人工智能算法，尤其是在深度学习热潮掀起后，神经网络在股票价格预测和量化投资策略研究中取得了不错的效果。深度学习的目标是学习多层次的特征，通过组合低级特征构建抽象的高级特征，从而挖掘数据的分布式特征表示，基于此进行复杂的非线性建模，从而实现预测任务。其中 RNN 被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价，交易信息都是序列数据，因此之前有很多研究者，基于 RNN 来预测股票价格。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题，之后出现了诸如 GRU，Peephole LSTM，BiLSTM 等 LSTM 的变体。但传统的股票预测模型有些并未考虑时间因素，有些仅考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://syhya.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"基于深度学习的股票价格预测和量化策略","item":"https://syhya.github.io/zh/posts/2021-04-21-deep-learning-stock-prediction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"基于深度学习的股票价格预测和量化策略","name":"基于深度学习的股票价格预测和量化策略","description":"摘要 股票市场是金融市场的重要组成部分，近些年来，股票市场蓬勃发展，股票价格预测和量化投资策略研究吸引了许多领域的研究学者。其中最近几年随着人工智能和机器学习的发展，学者们从传统的统计学模型迁移到了人工智能算法，尤其是在深度学习热潮掀起后，神经网络在股票价格预测和量化投资策略研究中取得了不错的效果。深度学习的目标是学习多层次的特征，通过组合低级特征构建抽象的高级特征，从而挖掘数据的分布式特征表示，基于此进行复杂的非线性建模，从而实现预测任务。其中 RNN 被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价，交易信息都是序列数据，因此之前有很多研究者，基于 RNN 来预测股票价格。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题，之后出现了诸如 GRU，Peephole LSTM，BiLSTM 等 LSTM 的变体。但传统的股票预测模型有些并未考虑时间因素，有些仅考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。\n","keywords":["Deep learning","AI","RNN","LSTM","BiLSTM","GRU","LightGBM","Neural Networks","Stock Prediction","Financial Modeling","Machine Learning","Quantitative Investment","Portfolio Management","Financial Engineering","Algorithmic Trading","Time Series"],"articleBody":"摘要 股票市场是金融市场的重要组成部分，近些年来，股票市场蓬勃发展，股票价格预测和量化投资策略研究吸引了许多领域的研究学者。其中最近几年随着人工智能和机器学习的发展，学者们从传统的统计学模型迁移到了人工智能算法，尤其是在深度学习热潮掀起后，神经网络在股票价格预测和量化投资策略研究中取得了不错的效果。深度学习的目标是学习多层次的特征，通过组合低级特征构建抽象的高级特征，从而挖掘数据的分布式特征表示，基于此进行复杂的非线性建模，从而实现预测任务。其中 RNN 被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价，交易信息都是序列数据，因此之前有很多研究者，基于 RNN 来预测股票价格。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题，之后出现了诸如 GRU，Peephole LSTM，BiLSTM 等 LSTM 的变体。但传统的股票预测模型有些并未考虑时间因素，有些仅考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。\n本文实验第一部分通过利用国内浦发银行和国外 IBM 的股票数据，分别建立了 LSTM，GRU，BiLSTM 的股票预测模型，通过比较这三种深度学习模型最后预测的结果，发现对于两个数据集都是 BiLSTM 模型优于其他模型，有更好的预测准确率。第二部分通过使用 A 股全市场的股票数据，并先使用 LightGBM 模型进行对 50 个因子的篮选，选出重要程度最高的 10 个因子。之后再用 BiLSTM 模型选取进行因子组合，建立量化投资策略，最后对该策略进行实证与回测，发现该策略优于市场基准指数，说明了 BiLSTM 模型在股票价格预测和量化投资的实际应用价值。\n关键词：量化投资；深度学习；神经网络模型；多因子选股；BiLSTM\n第一章 绪论 1.1 研究背景与意义 1.1.1 研究背景 从 1970 年逐渐兴起，量化投资进入各投资者的视野，一场新的革命就此拉开序幕，改变了从前被动管理和有效市场假说主导的投资组合管理局面。有效市场假说认为，在市场有效的前提下，股票价格能反映市场的所有信息，不存在超额收益。被动投资管理的投资理念是市场是有效的，更加注重资产类别，最常见的方法是购买指数基金并关注已发布指数的表现。而主动投资管理主要依赖于投资者对于市场和个股的主观判定，根据能够获取的公开数据，通过将数学模型应用于金融领域，对股票进行评判，从而构建投资组合获取收益。量化投资通过对大量历史数据进行统计处理，挖掘投资机会，规避主观因素，受到越来越多投资者的追捧。量化投资兴起以后，人们也逐渐利用各种技术来进行股票价格的预测，从而更好地建立量化投资策略。早期国内外学者采用统计学方法建模，来预测股票价格，如指数平均法，多元回归法，自回归平均移动模型等，但是由于股票市场受多种因素影响，同时数据量很大，导致股票预测难度很大，各种统计学模型预测效果并不令人满意。\n近几年来，机器学习，深度学习和神经网络等相关技术不断发展，为股票价格预测和量化策略的构建提供了技术支持，不少学者通过随机森林法，神经网络，支持向量机和卷积神经网络等方法完成新的突破。股票市场足够的历史数据加之以多元的技术支撑，为股票价格预测和量化策略的构建提供了有利条件。\n1.1.2 研究意义 从国家经济体系和金融市场的长远发展来看，对于股票价格预测模型和量化投资策略的研究必不可少。我国起步较晚，金融市场不够成熟，金融工具不够丰富，市场效率较低，但是近几年来国家逐渐放宽政策，大力建设金融市场，为量化投资的发展提供“温床”，发展量化投资及新兴金融技术可以提供我们国家金融市场弯道超车的机会。并且股票价格指数作为一项重要的经济指标，对于我国经济发展起着晴雨表的作用。\n从个人投资者和机构投资者的角度来看，构建股票价格预测模型和量化投资策略模型提高了市场的有效性。个人投资者的专业知识不够完善，投资行为具有一定的盲目性，构建相关模型，为其提供参考，能够减少判断失误的概率，改变个人投资者在资本市场处于相对弱势的地位。并且对于机构投资者而言，理性客观的模型加之以个人经验的判断，提高了决策的正确性，为投资行为提供了新的方向。\n综上，结合我国目前的发展现状，本文选取个股进行股票价格预测模型和 A 股全市场的股票进行量化策略研究有重要的现实研究意义。\n1.2 研究综述 White（1988）$^{[1]}$ 使用 BP 神经网络来预测 IBM 股票的日收益率。然而，由于 BP 神经网络模型易受梯度爆炸的影响，导致模型无法收敛到全局最小值，从而无法实现准确的预测。\nKimoto（1990）$^{[2]}$ 使用模块化神经网络技术开发了一个用于东证股价指数（Tokyo Stock Exchange Prices Indexes，TOPIX）预测的系统。该系统不仅成功预测了东京证券交易所的 TOPIX，还通过基于预测结果的股票交易模拟，实现了一定程度的盈利。\nG．Peter Zhang（2003）$^{[3]}$ 对差分整合移动平均自回归（Autoregressive Integrated Moving Average，ARIMA）模型和人工神经网络（Artificial Neural Network，ANN）模型在时间序列预测中的性能进行了对比研究。结果显示，ANN 模型在时间序列预测的精度上显著优于 ARIMA 模型。\nRyo Akita（2016）$^{[4]}$ 选取消费者物价指数、市盈率以及报纸上的各种事件作为特征，利用段落向量和 LSTM 网络构建了一个金融时间序列预测模型。通过东京证券交易所五十家上市公司的实际数据，验证了该模型在股票开盘价预测方面的有效性。\nKunihiro Miyazaki（2017）$^{[5]}$ 通过提取股票日线图像及每 30 分钟的股票价格数据，构建了一个针对东证核心 30 指数（Topix Core 30）及其成分股涨跌预测的模型。研究对比了多种模型，包括逻辑回归（Logistic Regression, LR）、随机森林（Random Forest, RF）、多层感知器（Multilayer Perceptron, MLP）、LSTM、CNN、PCA-CNN 和 CNN-LSTM。结果表明，LSTM 在预测性能上最优，CNN 表现一般，但结合 CNN 和 LSTM 的混合模型可以提升预测精度。\nTaewook Kim（2019）$^{[6]}$ 提出了一个 LSTM-CNN 混合模型，用于结合股票价格时间序列与股票价格图像两种数据表示形式的特征，以预测 S\u0026P 500 指数的股价。研究表明，LSTM-CNN 模型在股价预测方面优于单一模型，并且这种预测对于构建量化投资策略具有一定的实际意义。\n1.3 论文的创新点 本文股票预测方面具有以下创新点：\n分别选用国内 A 股上海浦东发展银行和国外美股 IBM 的数据进行研究，避免单一市场研究的局限性。并且传统的 BP 模型从未考虑时间因素，要么像 LSTM 模型考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。实证过程中并与 LSTM 模型，GRU 模型进行对比，说明其能够提升预测准确率。 股票价格预测模型采用股票多特征进行训练，包括开盘价，闭盘价，最高价和交易量等特征，相对于单特征预测股票收盘价理论上更加精确，能更好地比较 LSTM，GRU 和 BiLSTM 对于股票的预测效果。 本文量化策略研究方面具有以下创新点：\n未使用市面上已有的常见因子，使用自己通过遗传规划算法（Genetic Programming，GP）和人工数据挖掘得到的多个价量因子，并通过 LightGBM 模型进行对 50 个因子的筛选，选出重要程度最高的 10 个因子。 传统的量化投资模型一般用 LSTM 模型和 CNN 模型构建量化投资策略，本文使用 A 股全市场的数据，利用 BiLSTM 模型选取进行因子组合，建立量化投资策略，最后对该策略进行实证与回测，发现该策略优于市场基准指数（中证全指），说明了 BiLSTM 模型在股票价格预测和量化投资的实际应用价值。 1.4 论文研究框架 本文基于深度学习算法分别进行了股票价格预测和量化策略研究，本文的具体研究框架如 Fig. 1 所示：\nFig. 1. Research Framework.\n本文具体研究框架内容如下：\n第一章为绪论。本章首先对股票价格预测和量化策略研究的研究意义和研究背景进行了介绍。随后对研究现状进行了综述，然后说明了本文相比现有的研究的创新点，最后简要阐述了本文的研究框架。\n第二章为相关理论基础。本章对本文研究中涉及到的深度学习模型和量化选股的基本理论进行了介绍。深度学习模型小节依次介绍了 RNN，LSTM，GRU 和 BiLSTM 这四个深度学习模型，其中重点介绍了 LSTM 模型的内部结构。量化选股理论小节依次介绍了均值－方差模型，资本资产定价模型，套利定价理论，多因子模型，Fama－French 三因子模型和五因子模型。本小节从各种金融理论和模型发展脉络中介绍了多因子量化选股的历程。\n第三章为 LSTM，GRU 和 BiLSTM 在股票价格预测中比较研究。本章首先介绍了实验所用国内及国外股票的数据集，然后对于数据进行归一化和数据划分的预处理步骤。紧接着说明了本章所使用 LSTM，GRU 和 BiLSTM 这三个模型的网络结构，模型的编译和超参数设置，并进行了实验得到实验结果。最后对实验结果进行分析和本章小结。\n第四章为基于 LightGBM-BiLSTM 的量化投资模型研究。本章首先大致介绍了实验步骤，然后分别介绍了实验所用的股票数据和因子数据。之后再对因子依次进行缺失值处理，去极值，因子标准化和因子中性化处理得到清洗后的因子。随后再利用 LightGBM 和 BiLSTM 分别进行因子选择和因子组合，最后根据得到的模型进行量化策略构建，并对量化策略进行回测。\n第五章为总结与展望。本章对于本文关于股票价格预测与量化投资策略的主要研究内容进行了总结，之后针对目前研究所存在的不足，对未来研究的方向进行了展望。\n第二章 相关理论基础 2.1 深度学习模型 2.1.1 RNN 循环神经网络（Recurrent Neural Network，RNN）被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价和交易信息都是序列数据，因此之前有很多工作，基于 RNN 来预测股票价格。RNN 采用十分简单的重复模块的链式结构，例如单个 tanh 层。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题。Fig. 2 是 RNN 结构图。\nFig. 2. RNN Structure Diagram. (Image source: Understanding LSTM Networks)\n2.1.2 LSTM 长短时记忆网络（Long Short-Term Memory，LSTM）是一种特殊的 RNN，能够学习长期依赖关系。它们是由 Hochreiter \u0026 Schmidhuber（1997）$^{[7]}$ 提出的，并在随后的工作中被许多人改进和推广。由于独特的设计结构，LSTM 有着间隙长度相对不敏感的特点，并且解决了传统 RNN 的梯度消失和梯度爆炸的问题。相对于传统 RNN 和隐马尔可夫模型（Hidden Markov Model，HMM）等其他时间序列模型，LSTM 能更好地处理和预测时间序列中间隔和延迟非常长的重要事件。因此，LSTM 广泛应用在机器翻译和语音识别的领域。\nLSTM 被明确设计为避免长期依赖问题。所有的递归神经网络都具有神经网络的重复模块链的形式，而 LSTM 对 RNN 的结构进行了改进。LSTM 并没有采用单一神经网络层，而是采用一种特殊的方式进行交互的四层结构。\nFig. 3. LSTM Structure Diagram 1. (Image source: Understanding LSTM Networks)\nFig. 4. LSTM Structure Diagram 2. (Image source: Understanding LSTM Networks)\n如 Fig.3 所示，黑线用来表示传输一个节点的输出向量到另一个节点的输入向量。神经网络层（Neural network layer）是带有 $\\sigma$ 激活函数或者 tanh 激活函数的处理模块；逐点运算（Pointwise operation）是代表向量与向量之间进行点乘运算；向量传输（Vector transfer）是表示信息传递方向；汇合（Concatenate）和复制（Copy）分别用两个黑线合在一起和两个黑线分开来表示信息的汇合和信息的复制。\n下面我们以 LSTM 为例，进行其结构详细的说明。\n遗忘门（forget gate） Fig. 5. Forget Gate Calculation (Image source: Understanding LSTM Networks)\n$$ f_{t} = \\sigma\\left(W_{f} \\cdot \\left[h_{t-1}, x_{t}\\right] + b_{f}\\right) $$参数说明：\n$h_{t-1}$ ：前一时刻的输出 $x_{t}$ ：当前时刻的输入 $\\sigma$ ：sigmoid 激活函数 $W_{f}$ ：遗忘门的权重矩阵 $b_{f}$ ：遗忘门的偏差向量参数 第一步如 Fig.5 所示，是一个决定从细胞状态中丢弃的信息的过程。该过程由 sigmoid 函数计算得到 $f_{t}$ 的值（$f_{t}$ 的范围在 0 到 1 之间，其中 0 代表完全不通过，1 代表完全通过）来决定细胞状态 $C_{t-1}$ 通过或者部分通过。\n输入门（input gate） Fig. 6. Input Gate Calculation (Image source: Understanding LSTM Networks)\n$$ \\begin{aligned} i_{t} \u0026= \\sigma\\left(W_{i} \\cdot \\left[h_{t-1}, x_{t}\\right] + b_{i}\\right) \\\\ \\tilde{C}_{t} \u0026= \\tanh\\left(W_{C} \\cdot \\left[h_{t-1}, x_{t}\\right] + b_{C}\\right) \\end{aligned} $$参数说明：\n$h_{t-1}$ ：前一时刻的输出 $x_{t}$ ：当前时刻的输入 $\\sigma$ ：sigmoid 激活函数 $W_{i}$ ：输入门的权重矩阵 $b_{i}$ ：输入门的偏差向量参数 $W_{C}$ ：细胞状态的权重矩阵 $b_{C}$ ：细胞状态的偏差向量参数 $\\tanh$ ：tanh 激活函数 第二步如 Fig.6 所示，通过 sigmoid 函数计算我们要在细胞状态中存储什么信息，接下来通过一个 $\\tanh$ 层创建候选向量 $\\tilde{C}_{t}$，该向量将会被加到细胞的状态中。\nFig. 7. Current Cell State Calculation (Image source: Understanding LSTM Networks)\n$$ C_{t} = f_{t} * C_{t-1} + i_{t} * \\tilde{C}_{t} $$参数说明：\n$C_{t-1}$ ：上一时刻的细胞状态 $\\tilde{C}_{t}$ ：临时细胞状态 $i_{t}$ ：输入门的值 $f_{t}$ ：遗忘门的值 第三步如 Fig.7 所示，当前时刻的细胞状态 $C_t$ 通过结合遗忘门和输入门的作用计算得到。\n遗忘门 $f_t$ 对上一时刻的细胞状态 $C_{t-1}$ 进行加权，以丢弃不需要的信息。 输入门 $i_t$ 对候选细胞状态 $\\tilde{C}_t$ 进行加权，决定引入多少新信息。\n最终，两个部分相加，更新得出当前时刻的细胞状态 $C_t$。 输出门（output gate） Fig. 8. Output Gate Calculation (Image source: Understanding LSTM Networks)\n$$ \\begin{aligned} o_{t} \u0026= \\sigma\\left(W_{o} \\cdot \\left[h_{t-1}, x_{t}\\right] + b_{o}\\right) \\\\ h_{t} \u0026= o_{t} * \\tanh\\left(C_{t}\\right) \\end{aligned} $$参数说明：\n$o_{t}$ ：输出门的值 $\\sigma$ ：sigmoid 激活函数 $W_{o}$ ：输出门的权重矩阵 $h_{t-1}$ ：前一时刻的输出 $x_{t}$ ：当前时刻的输入 $b_{o}$ ：输出门的偏差向量参数 $h_{t}$ ：当前时刻的输出 $\\tanh$ ：tanh 激活函数 $C_{t}$ ：当前时刻的细胞状态 第四步如 Fig.8 所示，使用 sigmoid 函数计算输出门的值，最后通过 tanh 激活函数将这一时刻的细胞状态 $C_{t}$ 进行处理并与输出门的值 $o_{t}$ 相乘得到当前时刻的输出 $h_{t}$。\n2.1.3 GRU K. Cho（2014）$^{[8]}$ 提出了门控循环单元（Gated Recurrent Unit，GRU）。GRU 主要是在 LSTM 的基础上进行了简化和调整，将 LSTM 原有的遗忘门、输入门和输出门合并为更新门（update gate）和重置门（reset gate）。此外，GRU 还将细胞状态与隐藏状态合并，从而减少了模型的复杂性，同时在某些任务中仍能够达到与 LSTM 相当的性能。\n该模型在训练数据集比较大的情况下可以节省很多时间，在某些较小和较不频繁的数据集上表现出更好的性能$^{[9][10]}$。\nFig. 9. GRU Structure Diagram (Image source: Understanding LSTM Networks)\n$$ \\begin{aligned} z_{t} \u0026= \\sigma\\left(W_{z} \\cdot \\left[h_{t-1}, x_{t}\\right]\\right) \\\\ r_{t} \u0026= \\sigma\\left(W_{r} \\cdot \\left[h_{t-1}, x_{t}\\right]\\right) \\\\ \\tilde{h}_{t} \u0026= \\tanh\\left(W \\cdot \\left[r_{t} * h_{t-1}, x_{t}\\right]\\right) \\\\ h_{t} \u0026= \\left(1 - z_{t}\\right) * h_{t-1} + z_{t} * \\tilde{h}_{t} \\end{aligned} $$参数说明：\n$z_{t}$ ：更新门的值 $r_{t}$ ：重置门的值 $W_{z}$ ：更新门的权重矩阵 $W_{r}$ ：重置门的权重矩阵 $\\tilde{h}_{t}$ ：临时的输出 2.1.4 BiLSTM 双向长短时记忆网络（Bidirectional Long Short-Term Memory，BiLSTM）是由前向的 LSTM 与后向的 LSTM 结合成的。BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，能够学习到对时间有长期依赖性的信息，与单向 LSTM 相比可以更好地考虑未来数据的反向影响。Fig. 10 是 BiLSTM 结构图。\nFig. 10. BiLSTM Structure Diagram. (Image source: Baeldung)\n2.2 量化选股理论 2.2.1 均值－方差模型 量化选股策略起源于 20 世纪 50 年代，Markowitz（1952）$^{[11]}$ 提出了均值－方差模型（Mean-Variance Model）。该模型不仅奠定了现代投资组合理论的基础，将投资风险量化，还建立了一个描述风险和预期收益率的具体模型。它打破了以往仅对投资组合进行定性分析而缺乏定量分析的局面，将数学模型成功引入金融投资领域。\n$$ \\begin{aligned} \\mathrm{E}\\left(R_{p}\\right) \u0026= \\sum_{i=1}^{n} w_{i} \\mathrm{E}\\left(R_{i}\\right) \\\\ \\sigma_{p}^{2} \u0026= \\sum_{i=1}^{n} \\sum_{j=1}^{n} w_{i} w_{j} \\operatorname{Cov}\\left(R_{i}, R_{j}\\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} w_{i} w_{j} \\sigma_{i} \\sigma_{j} \\rho_{ij} \\\\ \\sigma_{i} \u0026= \\sqrt{\\operatorname{Var}\\left(R_{i}\\right)}, \\quad \\rho_{ij} = \\operatorname{Corr}\\left(R_{i}, R_{j}\\right) \\end{aligned} $$$$ \\min \\sigma_{p}^{2} \\quad \\text{subject to} \\quad \\sum_{i=1}^{n} \\mathrm{E}\\left(R_{i}\\right) w_{i} = \\mu_{p}, \\quad \\sum_{i=1}^{n} w_{i} = 1 $$$$ \\begin{aligned} \\Omega \u0026= \\begin{pmatrix} \\sigma_{11} \u0026 \\cdots \u0026 \\sigma_{1n} \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\sigma_{n1} \u0026 \\cdots \u0026 \\sigma_{nn} \\end{pmatrix} = \\begin{pmatrix} \\operatorname{Var}\\left(R_{1}\\right) \u0026 \\cdots \u0026 \\operatorname{Cov}\\left(R_{1}, R_{n}\\right) \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\operatorname{Cov}\\left(R_{n}, R_{1}\\right) \u0026 \\cdots \u0026 \\operatorname{Var}\\left(R_{n}\\right) \\end{pmatrix} \\\\ \\Omega^{-1} \u0026= \\begin{pmatrix} v_{11} \u0026 \\cdots \u0026 v_{1n} \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ v_{n1} \u0026 \\cdots \u0026 v_{nn} \\end{pmatrix} \\\\ w_{i} \u0026= \\frac{1}{D}\\left(\\mu_{p} \\sum_{j=1}^{n} v_{ij}\\left(C \\mathrm{E}\\left(R_{j}\\right) - A\\right) + \\sum_{j=1}^{n} v_{ij}\\left(B - A \\mathrm{E}\\left(R_{j}\\right)\\right)\\right), \\quad i = 1, \\ldots, n \\end{aligned} $$$$ \\begin{aligned} A \u0026= \\sum_{i=1}^{n} \\sum_{j=1}^{n} v_{ij} \\mathrm{E}\\left(R_{j}\\right), \\quad B = \\sum_{i=1}^{n} \\sum_{j=1}^{n} v_{ij} \\mathrm{E}\\left(R_{i}\\right) \\mathrm{E}\\left(R_{j}\\right), \\quad C = \\sum_{i=1}^{n} \\sum_{j=1}^{n} v_{ij}, \\quad D = BC - A^{2} \u003e 0 \\\\ \\sigma_{p}^{2} \u0026= \\frac{C \\mu_{p}^{2} - 2A \\mu_{p} + B}{D} \\end{aligned} $$其中：\n$\\mathrm{E}\\left(R_{p}\\right)$ 和 $\\mu_{p}$ 是投资组合 $p$ 的预期收益率 $\\mathrm{E}\\left(R_{i}\\right)$ 是资产 $i$ 的预期收益率 $\\sigma_{i}$ 是资产 $i$ 的标准差 $\\sigma_{j}$ 是资产 $j$ 的标准差 $w_{i}$ 是资产 $i$ 在投资组合中的比例 $\\sigma_{p}^{2}$ 是投资组合 $p$ 的方差 $\\rho_{ij}$ 是资产 $i$ 和资产 $j$ 之间的相关系数 通过以上公式$^{[12]}$，我们可以构建投资组合，来让我们的投资组合在一定的期望收益率的条件下，非系统风险降低到最小。\n2.2.2 资本资产定价模型 William Sharpe（1964）$^{[13]}$、John Lintner（1965）$^{[14]}$ 和 Jan Mossin（1966）$^{[15]}$ 提出了资本资产定价模型（Capital Asset Pricing Model，CAPM）。该模型认为，一项资产的预期收益与该资产的风险度量 $\\beta$ 值相关。这一模型通过简单的线性关系，将资产的预期收益率与市场风险联系起来，使得 Markowitz（1952）$^{[11]}$ 的投资组合选择理论更贴近现实世界，同时为多因子选股模型的建立奠定了理论基础。\n根据资本资产定价模型，对于一个给定的资产 $i$，它的预期收益率和市场投资组合的预期收益率之间的关系可以表示为：\n$$ E\\left(r_{i}\\right) = r_{f} + \\beta_{im}\\left[E\\left(r_{m}\\right) - r_{f}\\right] $$其中：\n$E\\left(r_{i}\\right)$ 是资产 $i$ 的预期收益率 $r_{f}$ 是无风险利率 $\\beta_{im}$（Beta）是资产 $i$ 的系统性风险系数，$\\beta_{im} = \\frac{\\operatorname{Cov}\\left(r_{i}, r_{m}\\right)}{\\operatorname{Var}\\left(r_{m}\\right)}$ $E\\left(r_{m}\\right)$ 是市场投资组合 $m$ 的预期收益率 $E\\left(r_{m}\\right) - r_{f}$ 是市场风险溢价 2.2.3 套利定价理论和多因子模型 Ross（1976）$^{[16]}$ 提出了套利定价理论（Arbitrage Pricing Theory，APT）。该理论认为，套利行为是形成市场均衡价格的决定性因素，通过在收益率形成过程中引入一系列因子构建线性相关关系，克服了资本资产定价模型（CAPM）的局限性，为后续研究者提供了重要的理论指导。\n套利定价理论被认为是多因子模型（Multiple-Factor Model，MFM）的理论基础，是资产价格模型的重要组成部分，也是资产价格理论的基石之一。多因子模型的一般表达形式为：\n$$ r_{j} = a_{j} + \\lambda_{j1} f_{1} + \\lambda_{j2} f_{2} + \\cdots + \\lambda_{jn} f_{n} + \\delta_{j} $$其中：\n$r_{j}$ 是资产 $j$ 的收益率 $a_{j}$ 是资产 $j$ 的常数 $f_{n}$ 是系统性因素 $\\lambda_{jn}$ 是因子载荷 $\\delta_{j}$ 是随机误差 2.2.4 Fama－French 三因子模型和五因子模型 Fama（1992）和 French（1992）$^{[17]}$ 使用横截面回归与时间序列结合的方法发现，股票市场的 $\\beta$ 值无法解释不同股票回报率的差异，而上市公司的市值、账面市值比和市盈率等可以显著解释股票回报率的差异。他们认为超额收益是对 CAPM 中 $\\beta$ 未能反映的风险因素的补偿，由此提出了 Fama－French 三因子模型。这三个因子分别为：\n市场风险溢价因子（Market Risk Premium）\n表示市场整体的系统性风险，即市场投资组合的预期收益减去无风险利率的差值。 衡量投资者承担系统性风险（即无法通过分散投资消除的风险）所期望的超额回报。 计算公式为：\n$$ \\text{Market Risk Premium} = E(R_m) - R_f $$ 其中 $E(R_m)$ 是市场的预期收益率，$R_f$ 是无风险利率。 市值因子（Size, SMB: Small Minus Big）\n表示小市值股票与大市值股票之间的收益差异。 小市值股票通常风险更高，但历史数据显示，其预期收益也往往高于大市值股票。 计算公式为：\n$$ SMB = R_{\\text{Small}} - R_{\\text{Big}} $$ 反映了市场对小市值股票的额外风险溢价的补偿。 账面市值比因子（Value, HML: High Minus Low）\n反映高账面市值比（即“价值型股票”）与低账面市值比（即“成长型股票”）之间的收益差异。 高账面市值比的股票通常定价较低（被市场低估），但长期来看可能获得较高回报。 计算公式为：\n$$ HML = R_{\\text{High}} - R_{\\text{Low}} $$ 低账面市值比的股票可能因市场对其过于乐观的预期而被高估。 该模型将 APT 模型中的因子具体化，并得出结论：投资小市值、高成长的股票具有高风险高收益的特性。Fama－French 三因子模型被广泛应用于现代投资行为的分析和实践中。\n随后，Fama（2015）和 French（2015）$^{[18]}$ 对三因子模型进行了扩展，新增了以下两个因子：\n盈利水平因子（Profitability, RMW: Robust Minus Weak）\n反映高盈利公司与低盈利公司之间的收益差异。 盈利能力强的公司（高 ROE、净利润率）更可能提供稳定且较高的回报。 计算公式为：\n$$ RMW = R_{\\text{Robust}} - R_{\\text{Weak}} $$ 投资水平因子（Investment, CMA: Conservative Minus Aggressive）\n反映保守型投资公司与激进型投资公司之间的收益差异。 激进型公司（扩张迅速，资本开支较高）通常伴随着更大的经营风险，而保守型公司（资本支出相对稳健）表现出更高的稳定性和收益。 计算公式为：\n$$ CMA = R_{\\text{Conservative}} - R_{\\text{Aggressive}} $$ Fama-French 三因子模型公式为：\n$$ R_i - R_f = \\alpha_i + \\beta_{i,m} \\cdot (R_m - R_f) + \\beta_{i,SMB} \\cdot SMB + \\beta_{i,HML} \\cdot HML + \\epsilon_i $$Fama-French 五因子模型公式为：\n$$ R_i - R_f = \\alpha_i + \\beta_{i,m} \\cdot (R_m - R_f) + \\beta_{i,SMB} \\cdot SMB + \\beta_{i,HML} \\cdot HML + \\beta_{i,RMW} \\cdot RMW + \\beta_{i,CMA} \\cdot CMA + \\epsilon_i $$其中：\n$R_i$: 股票 $i$ 的预期收益率 $R_f$: 无风险收益率 $R_m$: 市场组合的预期收益率 $R_m - R_f$: 市场风险溢价因子 $SMB$: 小市值减去大市值股票收益 $HML$: 高账面市值比减去低账面市值比股票收益 $RMW$: 高盈利能力减去低盈利能力股票收益 $CMA$: 低投资活动减去高投资活动股票收益 $\\beta_{i,*}$: 股票 $i$ 对应因子的敏感度 $\\epsilon_i$: 回归残差 2.2.5 模型对比表格 以下表格总结了 均值-方差模型、资本资产定价模型 (CAPM)、套利定价理论 (APT) 和 Fama-French 模型 的核心内容及因子来源：\n模型 核心内容 因子来源 均值-方差模型 投资组合理论的基础，通过期望收益和协方差矩阵优化投资组合。 投资组合中资产的期望收益和协方差矩阵 资本资产定价模型 (CAPM) 通过市场风险因子（$\\beta$）解释资产收益，奠定多因子模型理论基础。 市场因子 $\\beta$ 套利定价理论 (APT) 多因子框架，允许多个经济变量解释资产收益，例如通胀率、利率等。 多因子（宏观经济变量，如通胀率、利率等） Fama-French 三因子模型 增加市值因子和账面市值比因子，改进对资产收益的解释能力。 市场因子、SMB（市值因子）、HML（账面市值比因子） Fama-French 五因子模型 在三因子模型基础上增加盈利因子和投资因子，进一步完善资产定价模型。 市场因子、SMB、HML、RMW（盈利因子）、CMA（投资因子） 以下表格总结了这些模型的优点及不足：\n模型 优点 不足 均值-方差模型 提供了系统化投资组合优化方法，奠定现代投资理论基础。 仅针对收益和方差进行优化，未明确风险补偿的来源。 资本资产定价模型 (CAPM) 简单易用，通过市场风险解释收益差异，为多因子模型提供理论基础。 假设单因子（市场风险）决定收益，忽略其他系统性风险因子。 套利定价理论 (APT) 允许多个因子解释资产收益，减少对单因子假设的依赖，更灵活。 未明确具体因子，实操性较低，仅提供框架。 Fama-French 三因子模型 通过增加市值因子和账面市值比因子，显著提高了对资产收益的解释能力。 忽略了盈利能力和投资行为等其他因子。 Fama-French 五因子模型 在三因子模型基础上增加盈利因子和投资因子，更全面地捕捉影响资产收益的关键变量。 模型复杂度较高，对数据要求高，仍可能遗漏某些潜在因子。 第三章 LSTM，GRU 和 BiLSTM 在股票价格预测中比较研究 3.1 实验数据介绍 国内外很多学者的研究以本国的股票指数为主，对于不同市场的单个股票研究相对较少。并且很少有研究将 LSTM、GRU、BiLSTM 这三个模型进行对比研究。因此本文分别选择国内 A 股上海浦东发展银行（简称浦发银行，代码600000）和美股 International Business Machines Corporation（简称 IBM）进行研究，这样更能准确地对我们使用的三个模型进行对比。其中浦发银行采用 2008 年 1 月 1 日到 2020 年 12 月 31 日的股票数据，共有 3114 条有效数据，数据来源于 Tushare 金融大数据平台。我们选取该数据集的日期（date）、开盘价（open）、收盘价（close）、最高价（high）、最低价（low）和成交量（volume）这 6 个特征进行实验。浦发银行的数据集除日期作为时间序列的索引以外，其他 5 个特征均作为自变量。IBM 采用 1990 年 1 月 2 日到 2018 年 11 月 15 日的股票数据，共有 7278 条有效数据，数据来源于雅虎财经。我们选取该数据集的日期（date）、开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、调整后的收盘价（Adj Close）和成交量（volume）这 7 个特征进行实验。IBM 的数据集除日期作为时间序列的索引以外，其他 6 个特征均作为自变量。本次实验选择收盘价（close）作为被预测的变量。表3.1.1和表3.1.2分别是两个数据集的部分数据。\n3.1.1 浦发银行数据集部分展示 date open close high low volume code 2008-01-02 9.007 9.101 9.356 8.805 131583.90 600000 2008-01-03 9.007 8.645 9.101 8.426 211346.56 600000 2008-01-04 8659 9.009 9.111 8.501 139249.67 600000 2008-01-07 8.970 9.515 9.593 8.953 228043.01 600000 2008-01-08 9.551 9.583 9.719 9.517 161255.31 600000 2008-01-09 9.583 9.663 9.772 9.432 102510.92 600000 2008-01-10 9.701 9.680 9.836 9.602 217966.25 600000 2008-01-11 9.670 10.467 10.532 9.670 231544.21 600000 2008-01-14 10.367 10.059 10.433 10.027 142918.39 600000 2008-01-15 10.142 10.051 10.389 10.006 161221.52 600000 数据来源：Tushare\n3.1.2 IBM数据集部分展示 Date Open High Low Close Adj Close Volume 1990-01-02 23.6875 24.5313 23.6250 24.5000 6.590755 7041600 1990-01-03 24.6875 24.8750 24.5938 24.7188 6.649599 9464000 1990-01-04 24.7500 25.0938 24.7188 25.0000 6.725261 9674800 1990-01-05 24.9688 25.4063 24.8750 24.9375 6.708448 7570000 1990-01-08 24.8125 25.2188 24.8125 25.0938 6.750481 4625200 1990-01-09 25.1250 25.3125 24.8438 24.8438 6.683229 7048000 1990-01-10 24.8750 25.0000 24.6563 24.7500 6.658009 5945600 1990-01-11 24.8750 25.0938 24.8438 24.9688 6.716855 5905600 1990-01-12 24.6563 24.8125 24.4063 24.4688 6.582347 5390800 1990-01-15 24.4063 24.5938 24.3125 24.5313 6.599163 4035600 数据来源：雅虎财经\n3.2 实验数据预处理 3.2.1 数据的归一化 实验中各个特征在单位和量级上存在差异，比如股票价格和成交量之间量级差异巨大，会对我们实验最终预测的结果产生影响。因此我们采用 sklearn.preprocessing 库中的 MinMaxScaler 方法将数据的特征缩放至 0 到 1 之间。这样既能提升模型精度，也能提升模型收敛速度。归一化公式：\n$$ x^{\\prime}=\\frac{x-\\min (x)}{\\max (x)-\\min (x)} $$其中 $x^{\\prime}$ 是归一化后的数据，$x$ 是原始数据， $\\min (x)$ 是原始数据集的最小值， $\\max (x)$ 是原始数据集的最大值。之后在我们的实验过程中获得预测结果之后，还要将数据进行反归一化处理，之后才能进行对于股票价格的预测和模型评估。\n3.2.2 数据的划分 此处分别将浦发银行和 IBM 的整个实验数据集送入，设置循环核时间步（timestep）都为 60，每个时间步输入特征个数分别为 5 和 6。这样可以输入前 60 个交易日的数据，预测出第 61 天的收盘价。使我们的数据集符合之后要比较的三种神经网络模型输入的要求，依次是送入样本数，循环核时间展开步数和每个时间步输入特征个数。之后我们再将浦发银行的数据集按照 2488：311：255 的比例将归一化的数据集划分为训练集，验证集，测试集三个部分。将 IBM 的数据集按照 6550：364：304 的比例将归一化的数据集划分为训练集，验证集，测试集三个部分。我们这里划分出验证集的目的是为了方便进行调整模型的超参数以便优化各个模型之后再进行比较。\n3.3 模型网络结构 本文通过大量反复试验最终各个模型设置的网络结构如下表所示，其中层与层之间使用循环神经网络默认的 tanh 和 linear 作为激活函数，并且为了防止过拟合加入 Dropout，Dropout 的丢弃比例（rate）取值为 0.2。LSTM 和 GRU 每个循环层的神经元个数为 50，BiLSTM 循环层的神经元的个数为 100。LSTM、GRU、BiLSTM 每个模型分别采用四层 LSTM、GRU、BiLSTM 和一层全连接层，其中每层网络之间都设置了一个 Dropout。\n3.3.1 IBM的LSTM网络结构 Layer(type) Output Shape Param# lstm_1 (LSTM) (None, 60, 50) 11400 dropout_1 (Dropout) (None, 60, 50) 0 lstm_2 (LSTM) (None, 60, 50) 20200 dropout_2 (Dropout) (None, 60, 50) 0 lstm_3 (LSTM) (None, 60, 50) 20200 dropout_3 (Dropout) (None, 60, 50) 0 lstm_4 (LSTM) (None, 50) 20200 dropout_4 (Dropout) (None, 50) 0 dense_1 (Dense) (None, 1) 51 Total params：72,051\nTrainable params：72,051\nNon-trainable params：0\n3.3.2 IBM的GRU网络结构 Layer(type) Output Shape Param# gru_1 (GRU) (None, 60, 50) 8550 dropout_1 (Dropout) (None, 60, 50) 0 gru_2 (GRU) (None, 60, 50) 15150 dropout_2 (Dropout) (None, 60, 50) 0 gru_3 (GRU) (None, 60, 50) 15150 dropout_3 (Dropout) (None, 60, 50) 0 gru_4 (GRU) (None, 50) 15150 dropout_4 (Dropout) (None, 50) 0 dense_1 (Dense) (None, 1) 51 Total params：54,051\nTrainable params：54,051\nNon-trainable params：0\n3.3.3 IBM的BiLSTM网络结构 Layer(type) Output Shape Param# bidirectional_1 (Bidirection) (None, 60, 100) 22800 dropout_1 (Dropout) (None, 60, 100) 0 bidirectional_2 (Bidirection) (None, 60, 100) 60400 dropout_2 (Dropout) (None, 60, 100) 0 bidirectional_3 (Bidirection) (None, 60, 100) 60400 dropout_3 (Dropout) (None, 60, 100) 0 bidirectional_4 (Bidirection) (None, 100) 60400 dropout_4 (Dropout) (None, 100) 0 dense_1 (Dense) (None, 1) 101 Total params：204,101\nTrainable params：204,101\nNon-trainable params：0\n3.4 模型和编译及超参数设置 本文模型在以验证集的损失函数最小为目标，进行不断的超参数调试之后，对于浦发银行的三个模型都选用 epochs=100，batch_size=32；对于 IBM 的三个模型都选用 epochs=50，batch_size=32。其中优化器都采用自适应矩估计（Adaptive moment estimation，Adam）$^{[19]}$。使用其 keras 包中的默认值，即 lr=0.001、beta_1=0.9、beta_2=0.999、epsilon=1e-08 和 decay=0.0。损失函数采用均方误差（Mean Square Error，MSE）。\n参数解释：\nlr：学习率 beta_1：一阶矩估计的指数衰减率 beta_2：二阶矩估计的指数衰减率 epsilon：模糊因子 decay：每次更新后的学习率衰减值 3.5 实验结果与分析 首先简单介绍一下模型使用评价的这几个指标。计算公式如下：\n均方误差（Mean Square Error，MSE）： $$ M S E=\\frac{1}{n} \\sum_{i=1}^{n}\\left(Y_{i}-\\hat{Y}_{i}\\right)^{2} $$ 均方根误差（Root Mean Squared Error，RMSE)： $$ R M S E=\\sqrt{\\frac{1}{n} \\sum_{i=1}^{n}\\left(Y_{i}-\\hat{Y}_{i}\\right)^{2}} $$ 平均绝对误差（Mean Absolute Error，MAE）： $$ M A E=\\frac{1}{n} \\sum_{i=1}^{n}\\left|Y_{i}-\\hat{Y}_{i}\\right| $$ \\( R^2 \\)（R Squared）： $$ \\begin{gathered} \\bar{Y}=\\frac{1}{n} \\sum_{i=1}^{n} Y_{i} \\\\ R^{2}=1-\\frac{\\sum_{i=1}^{n}\\left(Y_{i}-\\hat{Y}_{i}\\right)^{2}}{\\sum_{i=1}^{n}\\left(Y_{i}-\\bar{Y}\\right)^{2}} \\end{gathered} $$其中：$n$ 是样本的数量，$Y$ 是股票实际的收盘价，$\\hat{Y}_{i}$ 是股票预测的收盘价， $\\bar{Y}$ 是股票平均的收盘价。MSE，RMSE 和 MAE 越小该模型越精确。 $R^{2}$ 评价模型系数拟合优度越大越好。\n3.5.1 浦发银行实验结果 LSTM GRU BiLSTM MSE 0.059781 0.069323 0.056454 RMSE 0.244501 0.263292 0.237601 MAE 0.186541 0.202665 0.154289 R-squared 0.91788 0.896214 0.929643 比较三个模型的评价指标，我们可以发现在浦发银行测试集上 BiLSTM 模型的 MSE、RMSE 和 MAE 都小于 LSTM 模型和 GRU 模型，而 R-Squared 都大于 LSTM 模型和 GRU 模型。我们通过对比 RMSE 发现，BiLSTM 相较于 LSTM 在验证集上有 2.90%的性能提升，BiLSTM 相较于 GRU 在验证集上有 10.81%的性能提升。\n3.5.2 IBM实验结果 LSTM GRU BiLSTM MSE 18.01311 12.938584 11.057501 RMSE 4.244186 3.597024 3.325282 MAE 3.793223 3.069033 2.732075 R-squared 0.789453 0.851939 0.883334 比较三个模型的评价指标，我们可以发现在 IBM 测试集上 BiLSTM 模型的 MSE、RMSE 和 MAE 都小于 LSTM 模型和 GRU 模型，而 R-Squared 都大于 LSTM 模型和 GRU 模型。我们通过对比 RMSE 发现，BiLSTM 相较于 LSTM 在验证集上有 27.63%的性能提升，BiLSTM 相较于 GRU 在验证集上有 8.17%的性能提升。\n3.6 本章小结 本章先是介绍了实验所选用的浦发银行和 IBM 两个数据集以及选用的特征，之后对数据集进行了归一化、数据划分的预处理步骤。同时详细的说明了实验所使用 LSTM、GRU 和 BiLSTM 模型的网络结构和超参数。最后得到了每个模型的损失函数图像和一系列的拟合图形。比较了模型的多个评价指标和拟合图像最终得到 BiLSTM 模型能够更好地对股票价格进行预测，为我们下一章研究 LightGBM-BiLSTM 的量化投资策略奠定了基础。\n第四章 基于 LightGBM-BiLSTM 的量化投资模型研究 4.1 实验步骤 Fig. 11. LightGBM-BiLSTM Diagram.\n如 Fig.11 所示，本实验先从因子库中选取 50 个因子。之后对因子依次进行去极值、标准化和缺损值填充的因子清洗步骤。再利用 LightGBM 模型进行因子选择，根据因子重要性进行排序得到前十的因子作为本横截面挑选出来的因子。紧接着使用 BiLSTM 建立多因子模型，最后再进行回测分析。\n4.2 实验数据 本文采用的行情数据来源于 Tushare。具体数据集的特征如下表所示。\n4.2.1 股票数据集包含的特征 名称 类型 描述 ts_code str 股票代码 trade_date str 交易日期 open float 开盘价 high float 最高价 low float 最低价 close float 收盘价 pre_close float 昨收价 change float 涨跌额 pct_chg float 涨跌幅（未复权） vol float 成交量（手） amount float 成交额（千元） A股全市场日线数据集包含5,872,309行数据，即包含5,872,309个样本。如表4.2.1所示，A股全市场日线数据集数据集有以下11个特征，分别依次为股票代码（ts_code）、交易日期（trade_date）、开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、昨收价（pre_close）、涨跌额（change）、换手率（turnover_rate）、交易金额（amount）、总市值（total_mv）和复权因子（adj_factor）。\n4.2.2 A股全市场日线数据集部分展示 ts_code trade_date open high low close pre_close change vol amount 600613.SH 20120104 8.20 8.20 7.84 7.86 8.16 -0.30 4762.98 3854.1000 600690.SH 20120104 9.00 9.17 8.78 8.78 8.93 -0.15 142288.41 127992.6050 300277.SZ 20120104 22.90 22.98 20.81 20.88 22.68 -1.80 12212.39 26797.1370 002403.SZ 20120104 8.87 8.90 8.40 8.40 8.84 -0.441 10331.97 9013.4317 300179.SZ 20120104 19.99 20.32 19.20 19.50 19.96 -0.46 1532.31 3008.0594 600000.SH 20120104 8.54 8.56 8.39 8.41 8.49 -0.08 342013.79 290229.5510 300282.SZ 20120104 22.90 23.33 21.02 21.02 23.35 -2.33 38408.60 86216.2356 002319.SZ 20120104 9.74 9.95 9.38 9.41 9.73 -0.32 4809.74 4671.4803 601991.SH 20120104 5.17 5.39 5.12 5.25 5.16 0.09 145268.38 76547.7490 000780.SZ 20120104 10.42 10.49 10.00 10.00 10.30 -0.30 20362.30 20830.1761 [5872309 rows x 11 columns]\n中证全指日线数据集包含5,057行数据，即包含5,057个样本。如表4.2.2所示，中证全指日线数据集有以下7个特征，分别依次为交易日期（trade_date）、开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、交易量（volume）和昨收价（pre_close）。\n4.2.3 中证全指日线数据集部分展示 trade_date open high low close volume pre_close 2006-11-24 1564.3560 1579.3470 1549.9790 1576.1530 7.521819e+09 1567.0910 2006-11-27 1574.1130 1598.7440 1574.1130 1598.7440 7.212786e+09 1581.1530 2006-11-28 1597.7200 1604.7190 1585.3620 1596.8400 7.025637e+09 1598.7440 2006-11-29 1575.3030 1620.2870 1575.3030 1617.9880 7.250354e+09 1596.8400 2006-11-30 1621.4280 1657.3230 1621.4280 1657.3230 9.656888e+09 1617.9880 … … … … … … … 2020-11-11 5477.8870 5493.5867 5422.9110 5425.8017 5.604086e+10 5494.1042 2020-11-12 5439.2296 5454.3452 5413.9659 5435.1379 4.594251e+10 5425.8017 2020-11-13 5418.2953 5418.3523 5364.2031 5402.7702 4.688916e+10 5435.1379 2020-11-16 5422.3565 5456.7264 5391.9232 5456.7264 5.593672e+10 5402.7702 2020-11-17 5454.0696 5454.0696 5395.6052 5428.0765 5.857009e+10 5456.7264 [5057 rows x 7 columns]\n下表4.2.4是原始的因子部分数据。依次经过上述因子缺失值填充、因子去极值、因子标准化和因子中性化这 4 个因子清洗的步骤后，得到如表4.2.5展示的经过因子清洗后的因子部分数据。\n4.2.4 原始的因子数据 trade_date sec_code ret factor_0 factor_1 factor_2 factor_3 factor_4 factor_5 factor_6 … 2005-01-04 600874.SH 0.001684 NaN 9.445412 9.445412 9.445408 -1.00 NaN 12651.124023 … 2005-01-04 000411.SZ 0.021073 NaN 5.971262 5.971262 5.971313 0.38 NaN 392.124298 … 2005-01-04 000979.SZ 0.021207 NaN 6.768918 6.768918 6.768815 -1.45 NaN 870.587585 … 2005-01-04 000498.SZ 0.030220 NaN 8.852752 8.852752 8.852755 0.55 NaN 6994.011719 … 2005-01-04 600631.SH 0.015699 NaN 9.589897 9.589897 9.589889 -1.70 NaN 14616.806641 … 4.2.5 清洗后的因子数据 sec_code trade_date ret factor_0 factor_1 factor_2 factor_3 factor_4 factor_5 factor_6 … 000001.SZ 2005-01-04 -1.58653 0.01545 1.38306 1.38306 1.38306 0.13392 0.01545 1.38564 … 000002.SZ 2005-01-04 1.36761 -0.44814 1.69728 1.69728 1.69728 1.04567 -0.44814 1.69728 … 000004.SZ 2005-01-04 0.32966 -1.41654 -0.13907 -0.13907 -0.13907 -0.34769 -1.41654 -0.13650 … 000005.SZ 2005-01-04 0.61297 -1.13066 1.05339 1.05339 1.05339 -1.20020 -1.13066 1.05597 … 000006.SZ 2005-01-04 -0.35542 1.67667 -0.07726 -0.07726 -0.07726 1.55820 1.67667 -0.07469 … 4.2.6 因子数据 价量因子构建 本文使用如下方式构建价量因子，构建价量因子的基础要素有两点：首先是基础字段，其次是算子。如表4.2.1 所示，基础字段包括日频的最高价（high），最低价（low），开盘价（open），收盘价（close），上一日收盘价（pre_close），成交量（vol），涨跌（pct_chg），换手率（turnover_rate），交易金额（amount），总市值（total_mv）和复权因子（adj_factor）。\n4.2.7 基础字段表 编号 字段名 意义 high 最高价 当日成交订单中最高的价格 low 最低价 当日成交订单中最低的价格 open 开盘价 当日集合竞价成交的价格 close 收盘价 当日最后一笔成交订单的价格 pre_close 上一日收盘价 上一日最后一笔成交订单的价格 vol 成交 全天成交的股票数 pct_chg 涨跌 本日证券涨跌 turnover_rate 换手率 本日证券的换手率 amount 成交金额 全天成交的金额 total_mv 总市值 总股本数乘以当时股价得出的股票总价值 adj_factor 复权因子 权息修复比例 本文通过 gplearn提供的基础算子集和自己定义的一些特殊算子，得到如表所示的算子列表。\n4.2.8 算子列表 算子 名称 定义 add(x, y) 和 \\( x + y\\)；点运算 \\(\\operatorname{div}(x, y)\\) 除 \\( x / y\\)；点运算 \\(\\operatorname{mul}(x, y)\\) 乘 \\( x \\cdot y\\)；点运算 \\(\\operatorname{sub}(x, y)\\) 减 \\( x - y\\)；点运算 neg(x) 负 \\(-x\\)；点运算 \\(\\log(x)\\) 对数 \\(\\log(x)\\)；点运算 max(x, y) 最大值 \\(x, y\\) 中数值较大的数；点运算 \\(\\min(x, y)\\) 最小值 \\(x, y\\) 中数值较小的数；点运算 delta_d(x) d 日差值 当日的 \\(x\\) 值减去 d 日前的 \\(x\\) 值；时序运算 delay_d(x) d 日延时 d 日前的 \\(x\\) 值；时序运算 Corr_d(x, y) d 日相关性 d 日 \\(x\\) 值和 d 日 \\(y\\) 值的相关性；时序运算 Max_d(x) d 日最大值 d 日 \\(x\\) 值的最大值；时序运算 Min_d(x) d 日最小值 d 日 \\(x\\) 值的最小值；时序运算 sort_d(x) d 日排序位置 d 日 \\(x\\) 值的排序值；时序运算 Argsortmin_d(x) d 日最小值位置 d 日 \\(x\\) 值的最小值的位置；时序运算 Argsortmax_d(x) d 日最大值位置 d 日 \\(x\\) 值的最大值的位置；时序运算 \\(\\operatorname{inv}(x)\\) 倒数 \\( 1 / x\\)；点运算 Std_d(x) d 日方差 d 日 \\(x\\) 值的方差；时序运算 abs(x) 绝对值 \\(\\lvert x\\rvert\\)；点运算 4.2.9 遗传规划 遗传规划（Genetic Programming, GP）的核心思想是使用进化算法在算子（operators）与基础字段（terminals）组合而成的巨大搜索空间中，自动“进化”出具有较强预测能力的因子表达式。对于本文中的因子挖掘来说，GP 的主要目标是从表4.2.7中的基础字段和表4.2.8中的算子所能组合成的所有可能表达式中，搜索并找到那些能对下一期股票收益有较好预测效果的因子。GP 的核心流程可分为以下几个步骤：\n初始化（Initialization） 定义算子集与基础字段\n算子集（operators）如表4.2.8所示，包括加、减、乘、除、对数、绝对值、延时、移动最大/最小值、移动相关系数等运算。 基础字段（terminals）如表4.2.7所示，包括开盘价、收盘价、最高价、最低价、成交量、复权因子等。\n这些算子和基础字段可以视作因子表达式树中的“节点”，其中基础字段为叶子节点（终端节点），算子为内部节点。 随机生成初始种群\n在初始化阶段，根据给定的算子集与字段集，随机“拼接”生成一系列因子表达式（可表示为若干语法树或表达式树），形成初始种群。 例如，可能随机产生\n\\[ \\text{因子1}: \\mathrm{Max\\_5}\\bigl(\\mathrm{add}(\\mathrm{vol}, \\mathrm{close})\\bigr), \\quad \\text{因子2}: \\mathrm{sub}\\bigl(\\mathrm{adj\\_factor}, \\mathrm{neg}(\\mathrm{turnover\\_rate})\\bigr), \\dots \\] 每个因子表达式都将对应一个个体（individual）。 适应度函数（Fitness Function） 度量因子的预测能力\n针对每个表达式（个体），我们需要评估它对未来收益或其他目标的预测能力。具体来说，可以在下一期股票收益 \\( r^{T+1} \\) 与当前期因子暴露度 \\( x_k^T \\) 之间，计算其相关系数（IC）或更综合的指标 IR（Information Ratio）来衡量。 设定目标\n若我们希望因子具有更高的相关性（IC），则可令适应度函数为 \\(\\lvert \\rho(x_k^T, r^{T+1})\\rvert\\)； 若我们希望因子的 IR 更高，则可设定适应度函数为 IR 值。 因子 IC 或 IR 越高，该表达式的“适应度”就越高。 因此，我们通常令： \\[ \\text{Fitness} \\bigl(F(x)\\bigr) \\;=\\; \\begin{cases} \\lvert \\rho(x_k^T, r^{T+1})\\rvert \\quad \u0026\\text{(IC最大化)},\\\\[6pt] \\mathrm{IR}(x_k^T) \\quad \u0026\\text{(IR最大化)}. \\end{cases} \\] 其中 \\(\\rho(\\cdot)\\) 表示相关系数，\\(\\mathrm{IR}(\\cdot)\\) 为 IR 指标。\n选择（Selection）、交叉（Crossover）与变异（Mutation） 选择（Selection）\n根据适应度函数的结果，将因子适应度高的表达式“保留”或“繁衍”，适应度较低的表达式则被淘汰。 这类似于生物进化中的“优胜劣汰”。 交叉（Crossover）\n将若干适应度较高的表达式（父本）随机选取一部分“节点”进行交换，从而得到新的表达式（子本）。 在表达式树结构中，可以将子树 A 与子树 B 互换，从而产生新的后代表达式。 例如，若表达式树 \\(\\mathrm{FactorA}\\) 的某个子树与表达式树 \\(\\mathrm{FactorB}\\) 的对应子树相交换，就生成了两个新的表达式。 变异（Mutation）\n以一定概率对表达式的某些节点进行随机变更，比如： 更换节点的算子（例如将 \\(\\mathrm{add}\\) 换为 \\(\\mathrm{sub}\\)）， 替换终端节点的基础字段（例如将 \\(\\mathrm{vol}\\) 换为 \\(\\mathrm{close}\\)）， 或随机改变运算参数（如移动窗口长度、平滑因子等）。 变异可以增加群体的多样性，避免过早收敛或陷入局部最优。 迭代进化（Iteration） 循环执行\n将选择、交叉、变异的操作反复执行多代（generations）。 每一代都产生一个新的因子表达式种群，并对其进行适应度评估。 收敛与终止\n当进化达到预先设定的停止条件（如迭代次数、适应度阈值等）时，算法终止。 通常我们会选出若干个最终适应度较高的因子表达式，将它们视为进化结果。 数学表征：搜索最优因子表达式 将上述过程抽象成下式，可以简单表示因子的搜索目标：\n\\[ F(x) \\;=\\; \\mathrm{GP}\\bigl(\\{\\text{operators}\\}, \\{\\text{terminals}\\}\\bigr), \\] 表示通过 GP 算法在给定算子集（operators）和基础字段集（terminals）上搜索出一个函数 \\(F(x)\\)。从最优化的角度看，我们希望找到：\n\\[ \\max_{F} \\bigl\\lvert \\rho(F^T, r^{T+1}) \\bigr\\rvert \\quad \\text{或者} \\quad \\max_{F} \\; \\mathrm{IR}\\bigl(F\\bigr), \\] 其中\n\\(\\rho(\\cdot)\\) 表示因子与下一期收益的相关系数（IC）， \\(\\mathrm{IR}(\\cdot)\\) 表示该因子的 IR 指标。 在实际应用中，我们会给定一段回测期，对每一代的候选因子进行打分（IC/IR 评估），通过选择、交叉和变异的迭代过程不断“进化”出更优质的因子。\n通过以上步骤，我们最终能够在庞大的算子组合与基础字段组合的搜索空间中，自动挖掘到一批对未来收益有较强预测能力、且具有较好稳健性（如 IR 较高）的因子表达式。\n4.2.10 挖掘出的部分因子 因子名 定义 0 Max＿25(add(turnover_rate, vol)) 1 Max＿30(vol) 2 Max＿25(turnover_rate) 3 Max＿35(add(vol, close)) 4 Max＿30(turnover_rate) 5 sub(Min＿20(neg(pre_close)), div(vol, adj_factor)) 6 Max＿60(max(vol, adj_factor)) 7 Max＿50(amount) 8 div(vol, neg(close)) 9 min(ArgSortMin＿25(pre_close), neg(vol)) 10 neg(max(vol, turnover_rate)) 11 mul(amount, neg(turnover_rate)) 12 inv(add(ArgSortMax＿40(change), inv(pct_chg))) 13 Std＿40(inv(abs(sub(mul(total_mv, change), min(adj_factor, high)))) 14 div(log(total_mv),amount) 15 div(neg(Max＿5(amount)), Min＿20(ArgSort＿60(high))) 16 Corr＿30(inv(abs(sub(mul(total_mv, change), min(adj_factor, high)))), add(log(Max＿10(pre_close)), high)) 17 ArgSort＿60(neg(turnover_rate)) … … 这些因子均是通过遗传规划从算子列表（表4.2.8）与基础字段列表（表4.2.7）中组合而得，具有不同的数学表达形式。\n因子有效性检验 当我们得到挖掘的因子之后，需要对因子进行有效性检验，常见的检验指标有信息系数（Information Coefficient，IC）和信息比率（Information Ratio，IR）。\n信息系数（IC）描述的是所选股票下期收益率和本期因子暴露度的线性相关程度，可以反应该因子进行收益率预测的稳健性 **信息比率（IR）**是超额收益的均值与超额收益的标准差之比，信息比率与夏普比率类似，主要区别在于夏普比率使用无风险收益作为基准，而信息比率使用风险指数作为基准。夏普比率有助于确定投资组合的绝对收益，信息比率有助于确定投资组合的相对收益。当我们计算了 IC 之后，可以根据 IC 的值再对 IR 进行计算。当 IR 大于 0.5 时，因子稳定获取超额收益能力较强。 实际计算中，因子 \\(k\\) 的 \\( \\mathrm{IC} \\) 值一般是指所选股票第 \\(T\\) 期的因子 \\(k\\) 上的暴露度 \\( x_k^T \\) 与所选股票第 \\(T+1\\) 期的收益率 \\( r^{T+1} \\) 的相关系数；因子 \\(k\\) 的 \\( \\mathrm{IR} \\) 值为因子 \\(k\\) 的 \\( \\mathrm{IC} \\) 的均值除以因子 \\(k\\) 的 \\( \\mathrm{IC} \\) 的标准差，计算公式如下：\n$$ \\begin{gathered} I C=\\rho_{x_{k}^{T}, r^{T+1}}=\\frac{\\operatorname{cov}\\left(x_{k}^{T}, r^{T+1}\\right)}{\\sigma_{x_{k}^{T}} \\sigma_{r^{T+1}}}=\\frac{\\mathrm{E}\\left(x_{k}^{T} * r^{T+1}\\right)-\\mathrm{E}\\left(x_{k}^{T}\\right) \\mathrm{E}\\left(r^{T+1}\\right)}{\\sqrt{\\mathrm{E}\\left(\\left(x_{k}^{T}\\right)^{2}\\right)-\\mathrm{E}\\left(x_{k}^{T}\\right)^{2}} \\cdot \\sqrt{\\mathrm{E}\\left(\\left(r^{T+1}\\right)^{2}\\right)-\\mathrm{E}\\left(r^{T+1}\\right)^{2}}} \\\\ I R=\\frac{\\overline{I C}}{\\sigma_{I C}} \\end{gathered} $$其中：\n$x_{k}^{T}$ ：所选股票第 $T$ 期的因子 $k$ 上的暴露度 $r^{T+1}$ ：所选股票第 $T+1$ 期的收益率 $\\overline{I C}: I C$ 的均值 本文采用 IR 判断因子好坏，通过对大量不同的算子和基础数据的组合以及 IC 和 IR 的“篮选”，文章得到了本文所选用的 50 个价量因子。经过 IR 检测，按 IR 由高到低排序得到如下图所示的表格。从下表中我们可以看出来所选的 50 个价量因子的 IR 都大于 0.5 ，说明这些因子稳定获取超额收益能力较强。\n4.2.11 因子 IR 检验表 因子名 IR 因子名 IR 0 3.11 25 2.73 1 2.95 26 2.71 2 2.95 27 2.70 3 2.95 28 2.69 4 2.95 29 2.69 5 2.94 30 2.69 6 2.94 31 2.68 7 2.94 32 2.68 8 2.93 33 2.68 9 2.93 34 2.68 10 2.93 35 2.67 11 2.92 36 2.67 12 2.91 37 2.66 13 2.89 38 2.65 14 2.86 39 2.65 15 2.83 40 2.65 16 2.83 41 2.65 17 2.83 42 2.64 18 2.79 43 2.63 19 2.78 44 2.63 20 2.78 45 2.62 21 2.76 46 2.62 22 2.75 47 2.62 从该表可见，在所筛选的因子中，所有因子的 IR 均大于 0.5，具有较强且稳定的获取超额收益的能力。\n4.3 因子清洗 4.3.1 因子缺失值处理和去极值 对于因子的缺失值处理的方法有个案剔除法，均值替换法，回归替换法等方法。本文采用较为简单的均值替换法对缺损值进行处理，即利用因子的平均值来替代缺失的数据。对于因子去极值有中位数去极值，百分比去极值和 $3 \\sigma$ 去极值等方法。本文采用的是 $3 \\sigma$ 去极值法，该方法是利用统计学上的 $3 \\sigma$ 原则，将把离该因子均值三个标准差以上的极值因子转化到刚好离均值三个标准差的位置，具体计算公式如下：\n$$ X_i^{\\prime}= \\begin{cases} \\bar{X}+3 \\sigma \u0026 \\text{if } X_i \u003e \\bar{X} + 3 \\sigma \\\\ \\bar{X}-3 \\sigma \u0026 \\text{if } X_i \u003c \\bar{X} - 3 \\sigma \\\\ X_i \u0026 \\text{if } \\bar{X} - 3 \\sigma \u003c X_i \u003c \\bar{X} + 3 \\sigma \\end{cases} $$其中：\n$X_{i}$ ：因子处理之前的值 $\\bar{X}$ ：因子序列的均值 $\\sigma$ ：因子序列的标准差 $X_{i}^{\\prime}$ ：去极值后的因子的值 4.3.2 因子的标准化 本文实验选取了多个因子，并且各个因子量纲并不完全相同，为了我们方便进行比较和回归，我们还需对因子进行标准化处理。目前常用的具体的标准化方法有 Min－Max标准化，Z－score 标准化和 Decimal scaling 小数定标标准化等。本文选择 Z－score 标准化的方法。通过原始数据的均值和标准差进行数据的标准化，经过处理的数据符合标准正态分布，即均值为 0 ，标准差为 1 ，其标准化后的数值大小有正有负，得到标准正态分布曲线。\n本文采用 Z－score 标准化公式如下：\n$$ \\tilde{x}=\\frac{x_{i}-u}{\\sigma} $$其中：\n$x_{i}$ ：因子的原值 $u$ ：因子序列的均值 $\\sigma$ ：因子序列的标准差 $\\tilde{x}$ ：标准化后的因子值 4.3.3 因子的中性化 因子中性化是为了剔除其他因素对我们所选因子的影响，使我们构建量化投资策略组合所选择的股票更加分散，而不是集中在特定的行业或者市值的股票上，可以更好地分担投资组合的风险和解决因子多重共线性的问题。市值和行业是影响股票收益最主要的两种自变量，所以在进行因子清洗的过程中，还必须考虑市值和行业的影响。本文实证中我们采用仅纳入行业因子，而将市场因子包含在行业因子中的方法。针对因子的单因子回归模型见公式(31)，我们将以下回归模型的残差项作为因子中性化后的新的因子值。\n$$ \\tilde{r}_{j}^{t}=\\sum_{s=1}^{s} X_{j s}^{t} \\tilde{f}_{s}^{t}+X_{j k}^{t} \\tilde{f}_{k}^{t}+\\tilde{u}_{j}^{t} $$其中：\n$\\tilde{r}_{j}^{t}$ ：股票 $j$ 在第 $t$ 期的收益率 $X_{j s}^{t}$ ：股票 $j$ 在第 $t$ 期在行业 $s$ 上的暴露度 $\\tilde{f}_{s}^{t}$ ：行业在第 $t$ 期的收益率 $X_{j k}^{t}$ ：股票 $j$ 在第 $t$ 期在因子 $k$ 上的暴露度 $\\tilde{f}_{k}^{t}$ ：因子 $k$ 在第 $t$ 期的收益率 $\\tilde{u}_j^t$ ：一个 $0-1$ 哑变量，即如果股票 $j$ 属于行业 $s$ ，则暴露度为 1 ，否则为 0 在本文中，并不会对公司所属行业进行按照比例拆分，即股票 $j$ 只能属于一个特定的行业 $s$ ，在行业 $s$ 上的暴露度为 1 ，在其他所有行业的暴露度为 0 。本文使用申万宏源行业分类标准，具体分类情况依次为农林牧渔，采掘，化工，钢铁，有色金属，电子元器件，家用电器，食品饮料，纺织服装，轻工制造，医药生物，公用事业，交通运输，房地产，商业贸易，餐饮旅游，综合，建筑材料，建筑装饰，电器设备，国防军工，计算机，传媒，通信，银行，非银金融，汽车和机械设备这 28 类。下表为 2021 年 2 月 5 日的申万指数一级行业历史行情图。\n4.3.3.1 2021年2月5日的申万指数一级行业历史行情图 指数代码 指数名称 发布日期 开盘指数 最高指数 最低指数 收盘指数 成交量(亿殴) 成交额(亿元) 涨跌幅(%) 801010 农林牧渔 2021/2/5 0:00 4111.43 4271.09 4072.53 4081.81 15.81 307.82 -0.3 801020 采掘 2021/2/5 0:00 2344.62 2357.33 2288.97 2289.41 18.06 115.6 -2.25 801030 化工 2021/2/5 0:00 4087.77 4097.59 3910.67 3910.67 55.78 778.85 -3.95 801040 钢铁 2021/2/5 0:00 2253.78 2268.17 2243.48 2250.81 11.61 48.39 -1.02 801050 有色金属 2021/2/5 0:00 4212.1 4250.59 4035.99 4036.74 45.41 593.92 -4.43 801080 电子元器件 2021/2/5 0:00 4694.8 4694.8 4561.95 4561.95 52.67 850.79 -2.78 801110 家用电器 2021/2/5 0:00 10033.82 10171.26 9968.93 10096.83 8.55 149.18 0.83 801120 食品饮料 2021/2/5 0:00 30876.33 31545.02 30649.57 30931.69 11.32 657.11 0.47 801130 纺织服装 2021/2/5 0:00 1614.48 1633.89 1604.68 1607.63 6.28 57.47 -0.39 801140 轻工制造 2021/2/5 0:00 2782.07 2791.88 2735.48 2737.24 15.28 176.16 -1.35 … … … … … … … … … … 数据来源：申银万国\n下表是原始的因子部分数据。依次经过上述因子缺失值填充、因子去极值、因子标准化和因子中性化这 4 个因子清洗的步骤后，得到如表展示的经过因子清洗后的因子部分数据。\n4.3.3.2 原始的因子数据 trade_date sec_code ret factor_0 factor_1 factor_2 factor_3 factor_4 factor_5 factor_6 … 2005-01-04 600874.SH 0.001684 NaN 9.445412 9.445412 9.445408 -1.00 NaN 12651.124023 … 2005-01-04 000411.SZ 0.021073 NaN 5.971262 5.971262 5.971313 0.38 NaN 392.124298 … 2005-01-04 000979.SZ 0.021207 NaN 6.768918 6.768918 6.768815 -1.45 NaN 870.587585 … 2005-01-04 000498.SZ 0.030220 NaN 8.852752 8.852752 8.852755 0.55 NaN 6994.011719 … 2005-01-04 600631.SH 0.015699 NaN 9.589897 9.589897 9.589889 -1.70 NaN 14616.806641 … 4.3.3.3 清洗后的因子数据 sec_code trade_date ret factor_0 factor_1 factor_2 factor_3 factor_4 factor_5 factor_6 … 000001.SZ 2005-01-04 -1.58653 0.01545 1.38306 1.38306 1.38306 0.13392 0.01545 1.38564 … 000002.SZ 2005-01-04 1.36761 -0.44814 1.69728 1.69728 1.69728 1.04567 -0.44814 1.69728 … 000004.SZ 2005-01-04 0.32966 -1.41654 -0.13907 -0.13907 -0.13907 -0.34769 -1.41654 -0.13650 … 000005.SZ 2005-01-04 0.61297 -1.13066 1.05339 1.05339 1.05339 -1.20020 -1.13066 1.05597 … 000006.SZ 2005-01-04 -0.35542 1.67667 -0.07726 -0.07726 -0.07726 1.55820 1.67667 -0.07469 … 4.4 基于 LightGBM 的因子选择 4.4.1 GBDT Friedman（2001）$^{[20]}$ 提出的梯度提升决策树（Gradient Boosting Decision Tree，GBDT）是一种基于迭代的回归型决策树。其主要思想是通过逐步添加弱分类器（通常是决策树）来优化模型，使得整体模型能够最小化损失函数。GBDT 的模型可以表示为：\n$$ \\hat{y} = \\sum_{m=1}^{M} \\gamma_m h_m(\\mathbf{x}) $$其中：\n\\( M \\) 是迭代次数， \\( \\gamma_m \\) 是第 \\( m \\) 个弱分类器的权重， \\( h_m(\\mathbf{x}) \\) 是第 \\( m \\) 个决策树模型。 GBDT 的训练过程通过逐步拟合负梯度方向来最小化损失函数，具体更新公式为：\n$$ \\gamma_m = \\arg\\min_\\gamma \\sum_{i=1}^{N} L\\left(y_i, \\hat{y}_{i}^{(m-1)} + \\gamma h_m(\\mathbf{x}_i)\\right) $$其中，\\( L \\) 是损失函数，\\( y_i \\) 是真实值，\\( \\hat{y}_{i}^{(m-1)} \\) 是第 \\( m-1 \\) 次迭代后的预测值。\n4.4.2 LightGBM 轻量级梯度提升机（Light Gradient Boosting Machine，LightGBM)$^{[21]}$ 是一个高效实现 GBDT 算法的框架，最初由 Microsoft 开发，作为一个免费开源的分布式梯度提升框架。LightGBM 基于决策树算法，广泛应用于排名、分类及其他机器学习任务，开发重点在于性能和可伸缩性。其主要优势包括高效率的并行训练、更快的训练速度、更低的内存消耗、更好的准确率，以及支持分布式计算和快速处理海量数据$^{[22]}$。\nLightGBM 的核心算法基于以下优化目标：\n$$ L = \\sum_{i=1}^{N} l(y_i, \\hat{y}_i) + \\sum_{m=1}^{M} \\Omega(h_m) $$其中，\\( l \\) 是损失函数，\\( \\Omega \\) 是正则化项，用于控制模型复杂度，通常表示为：\n$$ \\Omega(h_m) = \\gamma T + \\frac{1}{2} \\lambda \\sum_{j=1}^{T} w_j^2 $$这里，\\( T \\) 是树的叶子数，\\( w_j \\) 是第 \\( j \\) 个叶子的权重，\\( \\gamma \\) 和 \\( \\lambda \\) 是正则化参数。\nLightGBM 采用基于梯度的单边采样（Gradient-based One-Side Sampling，GOSS）和互斥特征捆绑（Exclusive Feature Bundling，EFB）等技术，显著提升了训练效率和模型性能。\n在本研究中，训练过程中使用的损失函数为均方误差（Mean Squared Error，MSE），其定义为：\n$$ L(y, \\hat{y}) = \\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\hat{y}_i)^2 $$其中，\\( y \\) 为真实收益率，\\( \\hat{y} \\) 为模型预测的收益率，\\( N \\) 为样本数量。\n4.4.3 算法流程 本小节算法的具体流程如下：\n数据准备：使用一年的每只股票的 50 个因子数据（A 股全市场数据）和历史未来一个月的收益率作为特征。\n模型训练：利用网格搜索法（Grid Search）优化 LightGBM 模型的超参数，训练模型以预测未来一个月的收益率。模型训练流程如图4.12所示。\n$$ \\text{参数优化：} \\quad \\theta^* = \\arg\\min_\\theta \\sum_{i=1}^{N} L(y_i, \\hat{y}_i(\\theta)) $$其中，\\( \\theta \\) 表示模型的超参数集合，\\( \\theta^* \\) 为最优参数。\n因子重要性计算：使用 LightGBM 的 feature_importances_ 方法计算各因子的特征重要性。特征重要性主要通过两个指标衡量：\nSplit：该特征在所有树中被用于分裂的次数。 Gain：该特征在所有分裂中带来的总增益（即损失函数的减少量）。 因子的特征重要性可以表示为：\n$$ \\text{Importance}_{\\text{split}}(f) = \\sum_{m=1}^{M} \\sum_{j=1}^{T_m} \\mathbb{I}(f \\text{ 被用于第 } j \\text{ 个叶节点的分裂}) $$$$ \\text{Importance}_{\\text{gain}}(f) = \\sum_{m=1}^{M} \\sum_{j=1}^{T_m} \\Delta L_{m,j} \\cdot \\mathbb{I}(f \\text{ 被用于第 } j \\text{ 个叶节点的分裂}) $$其中，\\( \\mathbb{I} \\) 是指示函数，\\( \\Delta L_{m,j} \\) 是因子 \\( f \\) 在第 \\( m \\) 棵树的第 \\( j \\) 个分裂中带来的损失减少量。\n因子筛选：根据模型计算的因子重要性进行排序，选择前十个重要性最高的因子作为本横截面分析中使用的因子。所选因子的重要性如表4.4.4所示。\n4.4.4 部分所选因子重要性排序 importance feature_name trade_date 35 factor_35 2010-08-11 27 factor_27 2010-08-11 33 factor_33 2010-08-11 20 factor_20 2010-08-11 24 factor_24 2010-08-11 45 factor_45 2010-08-11 37 factor_37 2010-08-11 49 factor_49 2010-08-11 19 factor_19 2010-08-11 47 factor_47 2010-08-11 22 factor_22 2010-09-09 20 factor_20 2010-09-09 30 factor_30 2010-09-09 24 factor_24 2010-09-09 4.4.5 代码实现片段 以下是训练过程所使用的部分代码，用于因子选择。\nfeature_choice def feature_choice( self, days=21, is_local=False ): if is_local: feature_info = pd.read_hdf(os.path.join(RESULTS, Feature_Info + '.h5')) else: factors = self.get_env().query_data(Factors_Data) factors = factors[ factors[COM_DATE] \u003e= '2010-01-01' ] trade_list = list(set(factors[COM_DATE])) trade_list.sort() if len(trade_list) % days == 0: n = int(len(trade_list) / days) - 7 else: n = int(len(trade_list) / days) - 6 feature_info = pd.DataFrame() begin_index = 147 feature = list(factors.columns) feature.remove(COM_SEC) feature.remove(COM_DATE) feature.remove(Ret) for i in range(n): end_date = days * i + begin_index - 21 begin_date = days * i trade_date = days * i + begin_index print(trade_list[trade_date]) train_data = factors[ (factors[COM_DATE] \u003c= trade_list[end_date]) \u0026 (factors[COM_DATE] \u003e= trade_list[begin_date]) ] model = lgb.LGBMRegressor() model.fit(train_data[feature], train_data[Ret]) feature_info_cell = pd.DataFrame(columns=Info_Fields) feature_info_cell[Importance] = model.feature_importances_ feature_info_cell[Feature_Name] = model.feature_name_ feature_info_cell = feature_info_cell.sort_values(by=Importance).tail(10) feature_info_cell[COM_DATE] = trade_list[trade_date] feature_info = pd.concat( [feature_info, feature_info_cell], axis=0 ) h = pd.HDFStore(os.path.join(RESULTS, Feature_Info + '.h5'), 'w') h['data'] = feature_info h.close() self.get_env().add_data(feature_info, Feature_Info) pass 通过上述流程，利用 LightGBM 高效地筛选出对预测未来收益率最具影响力的因子，从而提升模型的预测能力和解释性。\n4.5 基于 BiLSTM 的因子组合 本小节使用 BiLSTM 进行因子组合。BiLSTM 的具体原理在第二章已经介绍了，这里不再赘述。下面先介绍一下使用模型的具体网络结构，本文通过大量反复试验最终 BiLSTM 设置的网络结构如表4.5.1所示。其中层与层之间使用循环神经网络默认的 tanh 和 linear 作为激活函数。并且为了防止过拟合加入 Dropout，但是如果 Dropout 使用过大的丢弃比例会出现欠拟合的现象，因此 Dropout 的丢弃比例取值为 0.01。最终模型的 BiLSTM 循环层的神经元个数为 100，采用一层 BiLSTM 层和三层全连接层，其中 BiLSTM 层和第一个全连接层之间设置了一个 Dropout。\n4.5.1 BiLSTM的网络结构 Layer(type) Output Shape Param# bidirectional_1 (Bidirection) (None, 100) 24400 dropout_1 (Dropout) (None, 100) 0 dense_1 (Dense) (None, 256) 25856 dropout_2 (Dropout) (None, 256) 0 dense_2 (Dense) (None, 64) 16448 dense_3 (Dense) (None, 1) 0 Total params：66,769\nTrainable params：66,769\nNon-trainable params：0\n因为本次实验使用数据的数据量较大，因此选用 epochs=400，batch_size=1024。模型的损失函数采用均方误差（Mean Square Error，MSE）。其中优化器采用随机梯度下降（Stochastic Gradient Descent，SGD）。随机梯度下降相对于梯度下降（Gradient Descent，GD）有在信息冗余的情况下更能有效地利用信息，前期迭代效果卓越，适合处理大样本的数据这三个优势 $^{[23]}$。由于本实验训练数据量较大，使用 SGD 的话每次仅用一个样本来迭代，训练的速度很快，可以大大减少我们训练所花费的时间。使用其 keras 包中的默认值，即 lr=0.01、momentum=0.0、decay=0.0 和 nesterov=False。\n参数解释：\nlr：学习率 momentum：动量参数 decay：每次更新后的学习率衰减值 nesterov：确定是否使用 Nesterov 动量 4.5.2 算法流程 本小节算法的具体流程如下：\n使用一年的每只股票的 10 个因子（LightGBM 选出来的因子）和历史未来一个月的收益率的 A 股全市场数据作为特征。 以一年每支股票未来一个月的收益率为预测目标，利用 BiLSTM 进行训练，如 Fig. 12 所示。 Fig. 12. Rolling Window\n一个月的样本外数据的实时因子数据通过训练好的 BiLSTM 模型，得到实时的未来一月的每只股票预期收益率。收益率如表4.11所示。 4.5.3 部分股票预测收益率表 sec_code trade_date y_hat 000001.SZ 2011/5/26 0.0424621 000002.SZ 2011/5/26 -0.1632174 000004.SZ 2011/5/26 -0.0642319 000005.SZ 2011/5/26 0.08154649 000006.SZ 2011/5/26 0.00093213 000007.SZ 2011/5/26 -0.073218 000008.SZ 2011/5/26 -0.0464256 000009.SZ 2011/5/26 -0.091549 000010.SZ 2011/5/26 0.08154649 000011.SZ 2011/5/26 -0.1219943 000012.SZ 2011/5/26 -0.1448984 000014.SZ 2011/5/26 0.09038845 000016.SZ 2011/5/26 -0.11225 4.5.4 代码实现片段 以下是训练过程所使用的部分代码，用于构建BiLSTM训练网络。\nbuild_net_blstm def build_net_blstm(self): model = ks.Sequential() model.add( ks.layers.Bidirectional(ks.layers.LSTM( 50 ),input_shape=(11,10)) ) model.add( ks.layers.Dropout(0.01) ) model.add(ks.layers.Dense(256)) model.add( ks.layers.Dropout(0.01) ) model.add(ks.layers.Dense(64)) model.add(ks.layers.Dense(1)) model.compile(optimizer='sgd', loss='mse') model.summary() self.set_model(model) 4.6 量化策略和策略回测 4.6.1 回测指标 下面先对策略的一些常见回测指标进行介绍。评价指标包括累计收益率（Total Rate of Return）、年化收益率（Annualized Rate of Return）、年化波动率（Annualized volatility）、夏普比率（Sharpe ratio）、最大回撤率 (Maximum Drawdown，MDD)、年化换手率（Annualized turnover rate）和年化交易成本率（Annualized transaction cost rate），其中假定一年股市开盘252天，无风险利率默认为0.035，手续费默认0.002。\n累计收益率（Total Rate of Return）：在其他指标相同的情况下，累计收益率越大说明该策略越好，越能带来更大的收益。公式如下： $$ \\text{Total Rate of Return} = r_{p} = \\frac{P_{1} - P_{0}}{P_{0}} $$$P_{1}$ ：最终股票和现金的总价值\n$P_{0}$ ：初始股票和现金的总价值\n年化收益率（Annualized Rate of Return）：是将累计总收益率换算成以年为单位的几何平均收益率。在其他指标相同的情况下，年化收益率越大，代表该策略越好。公式如下： $$ \\text{Annualized Rate of Return} = R_{p} = \\left(1 + r_{p}\\right)^{\\frac{252}{t}} - 1 $$$r_{p}$ ：累计收益率\n$t$ ：投资策略执行的天数\n年化波动率（Annualized volatility）：定义为对象资产的年回报率的对数值的标准差。年化波动率用来衡量策略的风险性，波动率越大代表策略的风险越高。公式如下： $$ \\begin{aligned} \\text{Annualized volatility} = \\sigma_{p} \u0026= \\sqrt{\\frac{252}{t-1} \\sum_{i=1}^{t}\\left(r_{d} - \\bar{r}_{d}\\right)^{2}} \\\\ \\bar{r}_{d} \u0026= \\frac{1}{t} \\sum_{i=1}^{t} r_{d_{i}} \\end{aligned} $$$r_{d_{i}}$ ：第 $i$ 天日收益率\n$\\bar{r}_{d}$ ：日平均收益率\n$t$ ：投资策略执行的天数\n夏普比率（Sharpe ratio）：是由 Sharpe（1966）$^{[24]}$ 提出的。它代表投资者额外承受一单位风险，所获得的超额收益$^{[25]}$。这里给出年化的夏普比率计算公式： $$ S = \\frac{R_{p} - R_{f}}{\\sigma_{p}} $$$R_{p}$ ：年化收益率\n$R_{f}$ ：无风险收益率\n$\\sigma_{p}$ ：年化波动率\n最大回撤率 (Maximum Drawdown，MDD)：表示表示我们策略运行期间股票和现金的总价值走到最低点时的收益率回撤幅度的最大值。最大回测率用来策略最极端可能的亏损情况。 $$ MDD = \\frac{\\max \\left(V_{x} - V_{y}\\right)}{V_{x}} $$$V_{x}$ 和 $V_{y}$ 分别为策略组合在第 $x$ 天和第 $y$ 天的股票和现金的总价值，且 $x \u003c y$。\n年化换手率（Annualized turnover rate）：用来衡量对投资组合里面的股票买卖的频繁程度。越大说明改投资组合换仓越频繁，交易成本也会越大。 $$ \\text{change} = \\frac{N \\times 252}{t} $$$t$ ：投资策略执行的天数\n$N$ ：总共买进和卖出的次数\n年化交易成本率（Annualized transaction cost rate）：用来衡量投资组合策略的交易成本，越大说明交易成本越高。 $$ c = \\left(1 + \\text{commison}\\right)^{\\text{change}} - 1 $$change：年化换手率\ncommison：手续费\n4.6.2 策略及回测结果 本文量化交易策略采用每隔一个月进行换仓（即调仓周期为28个交易日），每次换仓采取等额持股的方式买入 BiLSTM 预测出的预期收益率最高的25支股票，卖出原本所持有的股票。本文的回测时间和规则如下：\n回测时间：从 2012 年 1 月到 2020 年 10 月。 回测股票池：全 A 股，剔除特别处理（Special treatment，ST）股票。 交易手续费：买入时支付给券商交易佣金千分之二，卖出时支付给券商交易佣金千分之二，其中单笔交易佣金不满5元券商按5元收取交易佣金。 买卖规则：当天开盘涨停股票不能买入，跌停股票不能卖出。 4.6.2.1 策略回测结果 累计收益率 年化收益率 年化波动率 夏普比率 最大回撤 年化换手率 年化交易成本率 策略 701.00% 29.18% 33.44% 0.77 51.10% 51.10% 11.35% 基准 110.40% 9.70% 26.01% 0.24 58.49% 58.49% 0.00% Fig. 22. Net Profit Curve\n回测结果如上表和 Fig.22 所示。我的策略采用的是本章所介绍的 LightGBM-BiLSTM 量化策略。基准采用的中证全指（000985）。由上面的结果可以看到，本策略累计收益率为701.00%，远高于基准110.40%；年化收益率为29.18%，远高于基准9.70%；夏普率为0.77，高于基准0.24。这三项回测指标说明 LightGBM-BiLSTM 量化策略确实能够给投资者带来更大的收益。本策略年化波动率为33.44%大于基准26.01%，最大回撤为51.10%小于基准58.49%，这两项回测指标说明 LightGBM-BiLSTM 量化策略存在一定的风险，特别是很难抵御系统性风险的冲击。年化换手率为11.35%，年化交易成本率为2.29%，说明我们策略不是高频交易策略，交易成本较小。从收益曲线图可以看出 LightGBM-BiLSTM 量化策略在前两年的收益率和基准相差不大，并没有特别的优势。但从2015年4月左右开始 LightGBM-BiLSTM 量化策略的收益率明显好于基准的收益率。总体而言，该 LightGBM-BiLSTM 量化策略的收益率十分可观，但仍然存在一定的风险。\n第五章 总结与展望 5.1 总结 本文首先介绍了基于深度学习的股票价格预测和量化策略研究的研究背景和研究意义，然后分别介绍了股票价格预测和量化投资策略国内外的研究现状，之后说明了本文的创新点和研究框架。接着本论文在相关理论基础章节大致介绍了本文用到的深度学习模型和量化投资的发展历程。重点介绍了 LSTM，GRU，BiLSTM 这三个模型的基本结构，基本原理和特点。\n随后，本文利用浦发银行和 IBM 的日频数据，通过一系列的数据处理过程和特征提取来对数据进行预处理。然后介绍了 LSTM，GRU，BiLSTM 这三个模型的具体网络结构以及超参数的设定。紧接着我们使用 LSTM，GRU，BiLSTM 分别进行两只股票收盘价的预测和模型评估比较。实验结果表明对于两只股票而言都是 BiLSTM 预测效果更加准确。\n最后，本论文为了进一步说明 BiLSTM 在金融上的运用价值，构建了基于 LightGBM－BiLSTM 的量化投资模型。选取 A 股全市场的股票和多个因子依次进行因子清洗，基于 LightGBM 的因子选择和基于 LSTM 的因子组合等过程。接着，我们构建一定的投资策略并通过累计收益率，年化收益率，年化波动率和夏普比率等评估指标与基准的持有中证全指进行对比。通过对比发现 LightGBM－BiLSTM 量化投资模型能带来更好的收益，说明了利用深度学习构建量化投资策略的有效性。\n5.2 展望 本文虽然分别对比 LSTM，GRU，BiLSTM 这三个模型预测股票收盘价的效果和基于 LightGBM－BiLSTM 量化投资策略取得了一定的成果，但本文研究仍有一些不足之处。结合本文的研究成果，可以进一步进行以下研究和改进：\n预测目标多样化：本文在预测股票价格方面，选取的股票收盘价作为预测目标，虽然这一结果最直观，但 Bachelier（1900）$^{[26]}$ 提出的随机游走假说（Random Walk Hypothesis，RWH）认为股票的价格服从随机漫步，是不可预测的。虽然之后有许多行为经济学家证明这一观点不完全正确，但这也同时说明单纯预测股票的收盘价难度和可解释性不那么强 $^{[27][28]}$。因此可以选择股票波动率预测，股票涨跌判断和股票收益率预测等作为未来的研究的方向。 模型多样化对比：本文在预测股票价格方面，对比了 LSTM，GRU 和 BiLSTM 这三种循环神经网络模型并且说明了 BiLSTM 预测效果比较好，但仍然缺少和其他更多不同模型的对比研究。因此未来可以深入研究与 Autoregressive Integrated Moving Average (ARIMA)，卷积神经网络（Convolutional Neural Networks，CNN），深度神经网络（Deep Neural Networks，DNN）, CNN－LSTM, Transformer 和 TimeGPT 等单一或复合模型之间的对比。 因子多样化：本文在构建量化投资策略方面使用的因子都是技术面的价量因子，因子的种类单一。未来可以选择财务因子，情绪因子，成长因子等不同种类的因子，从而提高策略的性能。同时未来研究还可以适当的加入择时策略，在预测大盘上涨时增加仓位，在预测大盘下跌时减少仓位，赚取贝塔（beta，$\\beta$）的钱。 投资组合优化：本文的因子组合过程仍然不完善，未来可以利用二次规划的方法对投资组合进行优化。 高频交易策略研究：本文的量化投资策略方法采取的是低频交易的策略，未来可以利用股票的 tick 数据来研究高频策略和超高频策略。 参考文献 [1] White, H. “Economic prediction using neural networks: The case of IBM daily stock returns.” Proc. of ICNN. 1988, 2: 451-458.\n[2] Kimoto, T., Asakawa, K., Yoda, M., et al. “Stock market prediction system with modular neural networks.” Proc. of 1990 IJCNN International Joint Conference on Neural Networks. IEEE, 1990: 1-6.\n[3] Zhang, G. P. “Time series forecasting using a hybrid ARIMA and neural network model.” Neurocomputing. 2003, 50: 159-175.\n[4] Akita, R., Yoshihara, A., Matsubara, T., et al. “Deep learning for stock prediction using numerical and textual information.” Proc. of 2016 IEEE/ACIS 15th International Conference on Computer and Information Science (ICIS). IEEE, 2016: 1-6.\n[5] 宮崎邦洋, 松尾豊. “Deep Learning を用いた株価予測の分析.” 人工知能学会全国大会論文集 第31回全国大会. 一般社団法人 人工知能学会, 2017: 2D3OS19a3-2D3OS19a3.\n[6] Kim, T., Kim, H. Y. “Forecasting stock prices with a feature fusion LSTM-CNN model using different representations of the same data.” PLoS ONE. 2019, 14(2): e0212320.\n[7] Hochreiter, S., Schmidhuber, J. “Long short-term memory.” Neural Computation. 1997, 9(8): 1735-1780.\n[8] Cho, K., Van Merriënboer, B., Gulcehre, C., et al. “Learning phrase representations using RNN encoder-decoder for statistical machine translation.” arXiv preprint arXiv:1406.1078. 2014.\n[9] Chung, J., Gulcehre, C., Cho, K. H., et al. “Empirical evaluation of gated recurrent neural networks on sequence modeling.” arXiv preprint arXiv:1412.3555. 2014.\n[10] Gruber, N., Jockisch, A. “Are GRU cells more specific and LSTM cells more sensitive in motive classification of text?” Frontiers in Artificial Intelligence. 2020, 3(40): 1-6.\n[11] Markowitz, H. “Portfolio Selection.” The Journal of Finance. 1952, 7(1): 77-91. doi:10.2307/2975974.\n[12] Merton, R. C. “An analytic derivation of the efficient portfolio frontier.” Journal of Financial and Quantitative Analysis. 1972: 1851-1872.\n[13] Sharpe, W. F. “Capital asset prices: A theory of market equilibrium under conditions of risk.” The Journal of Finance. 1964, 19(3): 425-442.\n[14] Lintner, J. “The Valuation of Risk Assets and the Selection of Risky Investments in Stock Portfolios and Capital Budgets.” Review of Economics and Statistics. 1965, 47(1): 13-37.\n[15] Mossin, J. “Equilibrium in a capital asset market.” Econometrica: Journal of the Econometric Society. 1966: 768-783.\n[16] Ross, S. A. “The arbitrage theory of capital asset pricing.” Journal of Economic Theory. 1976, 13(3): 341-60.\n[17] Fama, E. F., French, K. R. “Common risk factors in the returns on stocks and bonds.” Journal of Financial Economics. 1993, 33(1): 3-56.\n[18] Fama, E. F., French, K. R. “A five-factor asset pricing model.” Journal of Financial Economics. 2015, 116(1): 1-22.\n[19] Kingma, D. P., Ba, J. “Adam: A method for stochastic optimization.” arXiv preprint arXiv:1412.6980. 2014.\n[20] Friedman, J. H. “Greedy function approximation: A gradient boosting machine.” Annals of Statistics. 2001: 1189-1232.\n[21] Kopitar, L., Kocbek, P., Cilar, L., et al. “Early detection of type 2 diabetes mellitus using machine learning-based prediction models.” Scientific Reports. 2020, 10(1): 1-12.\n[22] Ke, G., Meng, Q., Finley, T., et al. “Lightgbm: A highly efficient gradient boosting decision tree.” Advances in Neural Information Processing Systems. 2017, 30: 3146-3154.\n[23] Bottou, L., Curtis, F. E., Nocedal, J. “Optimization methods for large-scale machine learning.” SIAM Review. 2018, 60(2): 223-311.\n[24] Sharpe, W. F. “Mutual fund performance.” The Journal of Business. 1966, 39(1): 119-138.\n[25] Sharpe, W. F. “The sharpe ratio.” Journal of Portfolio Management. 1994, 21(1): 49-58.\n[26] Bachelier, L. “Théorie de la spéculation.” Annales Scientifiques de l’École Normale Supérieure. 1900, 17: 21-86.\n[27] Fromlet, H. “Behavioral finance-theory and practical application: Systematic analysis of departures from the homo oeconomicus paradigm are essential for realistic financial research and analysis.” Business Economics. 2001: 63-69.\n[28] Lo, A. W. “The adaptive markets hypothesis.” The Journal of Portfolio Management. 2004, 30(5): 15-29.\n参考博客 Colah’s Blog. (2015, August 27). Understanding LSTM Networks. 引用 引用：转载或引用本文内容，请注明原作者与出处。\nCited as:\nYue Shui. (Apr 2021). 基于深度学习的股票价格预测和量化策略.\nhttps://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/\nOr\n@article{syhya2021stockprediction, title = \"基于深度学习的股票价格预测和量化策略\", author = \"Yue Shui\", journal = \"syhya.github.io\", year = \"2021\", month = \"Apr\", url = \"https://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/\" } ","wordCount":"25260","inLanguage":"zh","image":"https://syhya.github.io/%3Copengraph%E3%80%81twitter-cards%20%E5%9B%BE%E7%89%87%E7%9A%84%E9%93%BE%E6%8E%A5%E6%88%96%E8%B7%AF%E5%BE%84%3E","datePublished":"2021-04-21T12:00:00+08:00","dateModified":"2025-06-29T21:43:56+08:00","author":{"@type":"Person","name":"Yue Shui"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://syhya.github.io/zh/posts/2021-04-21-deep-learning-stock-prediction/"},"publisher":{"@type":"Organization","name":"Yue Shui 博客","logo":{"@type":"ImageObject","url":"https://syhya.github.io/%3C%E9%93%BE%E6%8E%A5%20/%20%E7%BB%9D%E5%AF%B9URL%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://syhya.github.io/zh/ accesskey=h title="首页 (Alt + H)"><img src=https://syhya.github.io/apple-touch-icon.png alt aria-label=logo height=35>首页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://syhya.github.io/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://syhya.github.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://syhya.github.io/zh/search/ title=搜索><span>搜索</span></a></li><li><a href=https://syhya.github.io/zh/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://syhya.github.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://syhya.github.io/zh/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">基于深度学习的股票价格预测和量化策略</h1><div class=post-meta><span title='2021-04-21 12:00:00 +0800 +0800'>2021-04-21</span>&nbsp;·&nbsp;51 分钟&nbsp;·&nbsp;25260 字&nbsp;·&nbsp;Yue Shui&nbsp;|&nbsp;翻译:<ul class=i18n_list><li><a href=https://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/>En</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#摘要>摘要</a></li><li><a href=#第一章-绪论>第一章 绪论</a><ul><li><a href=#11-研究背景与意义>1.1 研究背景与意义</a><ul><li><a href=#111-研究背景>1.1.1 研究背景</a></li><li><a href=#112-研究意义>1.1.2 研究意义</a></li></ul></li><li><a href=#12-研究综述>1.2 研究综述</a></li><li><a href=#13-论文的创新点>1.3 论文的创新点</a></li><li><a href=#14-论文研究框架>1.4 论文研究框架</a></li></ul></li><li><a href=#第二章-相关理论基础>第二章 相关理论基础</a><ul><li><a href=#21-深度学习模型>2.1 深度学习模型</a><ul><li><a href=#211-rnn>2.1.1 RNN</a></li><li><a href=#212-lstm>2.1.2 LSTM</a></li><li><a href=#213-gru>2.1.3 GRU</a></li><li><a href=#214-bilstm>2.1.4 BiLSTM</a></li></ul></li><li><a href=#22-量化选股理论>2.2 量化选股理论</a><ul><li><a href=#221-均值方差模型>2.2.1 均值－方差模型</a></li><li><a href=#222-资本资产定价模型>2.2.2 资本资产定价模型</a></li><li><a href=#223-套利定价理论和多因子模型>2.2.3 套利定价理论和多因子模型</a></li><li><a href=#224-famafrench-三因子模型和五因子模型>2.2.4 Fama－French 三因子模型和五因子模型</a></li><li><a href=#225-模型对比表格>2.2.5 模型对比表格</a></li></ul></li></ul></li><li><a href=#第三章-lstmgru-和-bilstm-在股票价格预测中比较研究>第三章 LSTM，GRU 和 BiLSTM 在股票价格预测中比较研究</a><ul><li><a href=#31-实验数据介绍>3.1 实验数据介绍</a><ul><li><a href=#311-浦发银行数据集部分展示>3.1.1 浦发银行数据集部分展示</a></li><li><a href=#312-ibm数据集部分展示>3.1.2 IBM数据集部分展示</a></li></ul></li><li><a href=#32-实验数据预处理>3.2 实验数据预处理</a><ul><li><a href=#321-数据的归一化>3.2.1 数据的归一化</a></li><li><a href=#322-数据的划分>3.2.2 数据的划分</a></li></ul></li><li><a href=#33-模型网络结构>3.3 模型网络结构</a><ul><li><a href=#331-ibm的lstm网络结构>3.3.1 IBM的LSTM网络结构</a></li><li><a href=#332-ibm的gru网络结构>3.3.2 IBM的GRU网络结构</a></li><li><a href=#333-ibm的bilstm网络结构>3.3.3 IBM的BiLSTM网络结构</a></li></ul></li><li><a href=#34-模型和编译及超参数设置>3.4 模型和编译及超参数设置</a></li><li><a href=#35-实验结果与分析>3.5 实验结果与分析</a><ul><li><a href=#351-浦发银行实验结果>3.5.1 浦发银行实验结果</a></li><li><a href=#352-ibm实验结果>3.5.2 IBM实验结果</a></li></ul></li><li><a href=#36-本章小结>3.6 本章小结</a></li></ul></li><li><a href=#第四章-基于-lightgbm-bilstm-的量化投资模型研究>第四章 基于 LightGBM-BiLSTM 的量化投资模型研究</a><ul><li><a href=#41-实验步骤>4.1 实验步骤</a></li><li><a href=#42-实验数据>4.2 实验数据</a><ul><li><a href=#421-股票数据集包含的特征>4.2.1 股票数据集包含的特征</a></li><li><a href=#422-a股全市场日线数据集部分展示>4.2.2 A股全市场日线数据集部分展示</a></li><li><a href=#423-中证全指日线数据集部分展示>4.2.3 中证全指日线数据集部分展示</a></li><li><a href=#424-原始的因子数据>4.2.4 原始的因子数据</a></li><li><a href=#425-清洗后的因子数据>4.2.5 清洗后的因子数据</a></li><li><a href=#426-因子数据>4.2.6 因子数据</a></li><li><a href=#427-基础字段表>4.2.7 基础字段表</a></li><li><a href=#428-算子列表>4.2.8 算子列表</a></li><li><a href=#429-遗传规划>4.2.9 遗传规划</a></li><li><a href=#4210-挖掘出的部分因子>4.2.10 挖掘出的部分因子</a></li><li><a href=#4211-因子-ir-检验表>4.2.11 因子 IR 检验表</a></li></ul></li><li><a href=#43-因子清洗>4.3 因子清洗</a><ul><li><a href=#431-因子缺失值处理和去极值>4.3.1 因子缺失值处理和去极值</a></li><li><a href=#432-因子的标准化>4.3.2 因子的标准化</a></li><li><a href=#433-因子的中性化>4.3.3 因子的中性化</a></li></ul></li><li><a href=#44-基于-lightgbm-的因子选择>4.4 基于 LightGBM 的因子选择</a><ul><li><a href=#441-gbdt>4.4.1 GBDT</a></li><li><a href=#442-lightgbm>4.4.2 LightGBM</a></li><li><a href=#443-算法流程>4.4.3 算法流程</a></li><li><a href=#444-部分所选因子重要性排序>4.4.4 部分所选因子重要性排序</a></li><li><a href=#445-代码实现片段>4.4.5 代码实现片段</a></li></ul></li><li><a href=#45-基于-bilstm-的因子组合>4.5 基于 BiLSTM 的因子组合</a><ul><li><a href=#451-bilstm的网络结构>4.5.1 BiLSTM的网络结构</a></li><li><a href=#452-算法流程>4.5.2 算法流程</a></li><li><a href=#453-部分股票预测收益率表>4.5.3 部分股票预测收益率表</a></li><li><a href=#454-代码实现片段>4.5.4 代码实现片段</a></li></ul></li><li><a href=#46-量化策略和策略回测>4.6 量化策略和策略回测</a><ul><li><a href=#461-回测指标>4.6.1 回测指标</a></li><li><a href=#462-策略及回测结果>4.6.2 策略及回测结果</a></li></ul></li></ul></li><li><a href=#第五章-总结与展望>第五章 总结与展望</a><ul><li><a href=#51-总结>5.1 总结</a></li><li><a href=#52-展望>5.2 展望</a></li></ul></li><li><a href=#参考文献>参考文献</a><ul><li><a href=#参考博客>参考博客</a></li></ul></li><li><a href=#引用>引用</a></li></ul></nav></div></details></div><div class=post-content><h2 id=摘要>摘要<a hidden class=anchor aria-hidden=true href=#摘要>#</a></h2><p>股票市场是金融市场的重要组成部分，近些年来，股票市场蓬勃发展，股票价格预测和量化投资策略研究吸引了许多领域的研究学者。其中最近几年随着人工智能和机器学习的发展，学者们从传统的统计学模型迁移到了人工智能算法，尤其是在深度学习热潮掀起后，神经网络在股票价格预测和量化投资策略研究中取得了不错的效果。深度学习的目标是学习多层次的特征，通过组合低级特征构建抽象的高级特征，从而挖掘数据的分布式特征表示，基于此进行复杂的非线性建模，从而实现预测任务。其中 RNN 被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价，交易信息都是序列数据，因此之前有很多研究者，基于 RNN 来预测股票价格。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题，之后出现了诸如 GRU，Peephole LSTM，BiLSTM 等 LSTM 的变体。但传统的股票预测模型有些并未考虑时间因素，有些仅考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。</p><p>本文实验第一部分通过利用国内浦发银行和国外 IBM 的股票数据，分别建立了 LSTM，GRU，BiLSTM 的股票预测模型，通过比较这三种深度学习模型最后预测的结果，发现对于两个数据集都是 BiLSTM 模型优于其他模型，有更好的预测准确率。第二部分通过使用 A 股全市场的股票数据，并先使用 LightGBM 模型进行对 50 个因子的篮选，选出重要程度最高的 10 个因子。之后再用 BiLSTM 模型选取进行因子组合，建立量化投资策略，最后对该策略进行实证与回测，发现该策略优于市场基准指数，说明了 BiLSTM 模型在股票价格预测和量化投资的实际应用价值。</p><p><strong>关键词</strong>：量化投资；深度学习；神经网络模型；多因子选股；BiLSTM</p><h2 id=第一章-绪论>第一章 绪论<a hidden class=anchor aria-hidden=true href=#第一章-绪论>#</a></h2><h3 id=11-研究背景与意义>1.1 研究背景与意义<a hidden class=anchor aria-hidden=true href=#11-研究背景与意义>#</a></h3><h4 id=111-研究背景>1.1.1 研究背景<a hidden class=anchor aria-hidden=true href=#111-研究背景>#</a></h4><p>从 1970 年逐渐兴起，量化投资进入各投资者的视野，一场新的革命就此拉开序幕，改变了从前被动管理和有效市场假说主导的投资组合管理局面。有效市场假说认为，在市场有效的前提下，股票价格能反映市场的所有信息，不存在超额收益。被动投资管理的投资理念是市场是有效的，更加注重资产类别，最常见的方法是购买指数基金并关注已发布指数的表现。而主动投资管理主要依赖于投资者对于市场和个股的主观判定，根据能够获取的公开数据，通过将数学模型应用于金融领域，对股票进行评判，从而构建投资组合获取收益。量化投资通过对大量历史数据进行统计处理，挖掘投资机会，规避主观因素，受到越来越多投资者的追捧。量化投资兴起以后，人们也逐渐利用各种技术来进行股票价格的预测，从而更好地建立量化投资策略。早期国内外学者采用统计学方法建模，来预测股票价格，如指数平均法，多元回归法，自回归平均移动模型等，但是由于股票市场受多种因素影响，同时数据量很大，导致股票预测难度很大，各种统计学模型预测效果并不令人满意。</p><p>近几年来，机器学习，深度学习和神经网络等相关技术不断发展，为股票价格预测和量化策略的构建提供了技术支持，不少学者通过随机森林法，神经网络，支持向量机和卷积神经网络等方法完成新的突破。股票市场足够的历史数据加之以多元的技术支撑，为股票价格预测和量化策略的构建提供了有利条件。</p><h4 id=112-研究意义>1.1.2 研究意义<a hidden class=anchor aria-hidden=true href=#112-研究意义>#</a></h4><p>从国家经济体系和金融市场的长远发展来看，对于股票价格预测模型和量化投资策略的研究必不可少。我国起步较晚，金融市场不够成熟，金融工具不够丰富，市场效率较低，但是近几年来国家逐渐放宽政策，大力建设金融市场，为量化投资的发展提供“温床”，发展量化投资及新兴金融技术可以提供我们国家金融市场弯道超车的机会。并且股票价格指数作为一项重要的经济指标，对于我国经济发展起着晴雨表的作用。</p><p>从个人投资者和机构投资者的角度来看，构建股票价格预测模型和量化投资策略模型提高了市场的有效性。个人投资者的专业知识不够完善，投资行为具有一定的盲目性，构建相关模型，为其提供参考，能够减少判断失误的概率，改变个人投资者在资本市场处于相对弱势的地位。并且对于机构投资者而言，理性客观的模型加之以个人经验的判断，提高了决策的正确性，为投资行为提供了新的方向。</p><p>综上，结合我国目前的发展现状，本文选取个股进行股票价格预测模型和 A 股全市场的股票进行量化策略研究有重要的现实研究意义。</p><h3 id=12-研究综述>1.2 研究综述<a hidden class=anchor aria-hidden=true href=#12-研究综述>#</a></h3><p><a href=https://pages.cs.wisc.edu/~dyer/cs540/handouts/deep-learning-nature2015.pdf>White（1988）</a>$^{[1]}$ 使用 BP 神经网络来预测 IBM 股票的日收益率。然而，由于 BP 神经网络模型易受梯度爆炸的影响，导致模型无法收敛到全局最小值，从而无法实现准确的预测。</p><p><a href=https://web.ist.utl.pt/adriano.simoes/tese/referencias/Papers%20-%20Adriano/NN.pdf>Kimoto（1990）</a>$^{[2]}$ 使用模块化神经网络技术开发了一个用于东证股价指数（Tokyo Stock Exchange Prices Indexes，TOPIX）预测的系统。该系统不仅成功预测了东京证券交易所的 TOPIX，还通过基于预测结果的股票交易模拟，实现了一定程度的盈利。</p><p><a href=https://dl.icdst.org/pdfs/files/2c442c738bd6bc178e715f400bec5d5f.pdf>G．Peter Zhang（2003）</a>$^{[3]}$ 对差分整合移动平均自回归（Autoregressive Integrated Moving Average，ARIMA）模型和人工神经网络（Artificial Neural Network，ANN）模型在时间序列预测中的性能进行了对比研究。结果显示，ANN 模型在时间序列预测的精度上显著优于 ARIMA 模型。</p><p><a href=https://ieeexplore.ieee.org/document/7550882>Ryo Akita（2016）</a>$^{[4]}$ 选取消费者物价指数、市盈率以及报纸上的各种事件作为特征，利用段落向量和 LSTM 网络构建了一个金融时间序列预测模型。通过东京证券交易所五十家上市公司的实际数据，验证了该模型在股票开盘价预测方面的有效性。</p><p><a href=https://www.ai-gakkai.or.jp/jsai2017/webprogram/2017/pdf/1112.pdf>Kunihiro Miyazaki（2017）</a>$^{[5]}$ 通过提取股票日线图像及每 30 分钟的股票价格数据，构建了一个针对东证核心 30 指数（Topix Core 30）及其成分股涨跌预测的模型。研究对比了多种模型，包括逻辑回归（Logistic Regression, LR）、随机森林（Random Forest, RF）、多层感知器（Multilayer Perceptron, MLP）、LSTM、CNN、PCA-CNN 和 CNN-LSTM。结果表明，LSTM 在预测性能上最优，CNN 表现一般，但结合 CNN 和 LSTM 的混合模型可以提升预测精度。</p><p><a href="https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0212320&amp;type=printable">Taewook Kim（2019）</a>$^{[6]}$ 提出了一个 LSTM-CNN 混合模型，用于结合股票价格时间序列与股票价格图像两种数据表示形式的特征，以预测 S&amp;P 500 指数的股价。研究表明，LSTM-CNN 模型在股价预测方面优于单一模型，并且这种预测对于构建量化投资策略具有一定的实际意义。</p><h3 id=13-论文的创新点>1.3 论文的创新点<a hidden class=anchor aria-hidden=true href=#13-论文的创新点>#</a></h3><p>本文股票预测方面具有以下创新点：</p><ol><li>分别选用国内 A 股上海浦东发展银行和国外美股 IBM 的数据进行研究，避免单一市场研究的局限性。并且传统的 BP 模型从未考虑时间因素，要么像 LSTM 模型考虑时间上的单向关系。因此，文中使用 BiLSTM 模型进行股票价格预测。从模型原理上来说，BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，并且避免了长时间序列上的梯度消失和梯度爆炸问题，能够更好地学习到对时间有长期依赖性的信息。实证过程中并与 LSTM 模型，GRU 模型进行对比，说明其能够提升预测准确率。</li><li>股票价格预测模型采用股票多特征进行训练，包括开盘价，闭盘价，最高价和交易量等特征，相对于单特征预测股票收盘价理论上更加精确，能更好地比较 LSTM，GRU 和 BiLSTM 对于股票的预测效果。</li></ol><p>本文量化策略研究方面具有以下创新点：</p><ol><li>未使用市面上已有的常见因子，使用自己通过遗传规划算法（Genetic Programming，GP）和人工数据挖掘得到的多个价量因子，并通过 LightGBM 模型进行对 50 个因子的筛选，选出重要程度最高的 10 个因子。</li><li>传统的量化投资模型一般用 LSTM 模型和 CNN 模型构建量化投资策略，本文使用 A 股全市场的数据，利用 BiLSTM 模型选取进行因子组合，建立量化投资策略，最后对该策略进行实证与回测，发现该策略优于市场基准指数（中证全指），说明了 BiLSTM 模型在股票价格预测和量化投资的实际应用价值。</li></ol><h3 id=14-论文研究框架>1.4 论文研究框架<a hidden class=anchor aria-hidden=true href=#14-论文研究框架>#</a></h3><p>本文基于深度学习算法分别进行了股票价格预测和量化策略研究，本文的具体研究框架如 Fig. 1 所示：</p><figure class=align-center><img loading=lazy src=Research%20Framework.svg#center alt="Fig. 1. Research Framework."><figcaption><p>Fig. 1. Research Framework.</p></figcaption></figure><p>本文具体研究框架内容如下：</p><p>第一章为绪论。本章首先对股票价格预测和量化策略研究的研究意义和研究背景进行了介绍。随后对研究现状进行了综述，然后说明了本文相比现有的研究的创新点，最后简要阐述了本文的研究框架。</p><p>第二章为相关理论基础。本章对本文研究中涉及到的深度学习模型和量化选股的基本理论进行了介绍。深度学习模型小节依次介绍了 RNN，LSTM，GRU 和 BiLSTM 这四个深度学习模型，其中重点介绍了 LSTM 模型的内部结构。量化选股理论小节依次介绍了均值－方差模型，资本资产定价模型，套利定价理论，多因子模型，Fama－French 三因子模型和五因子模型。本小节从各种金融理论和模型发展脉络中介绍了多因子量化选股的历程。</p><p>第三章为 LSTM，GRU 和 BiLSTM 在股票价格预测中比较研究。本章首先介绍了实验所用国内及国外股票的数据集，然后对于数据进行归一化和数据划分的预处理步骤。紧接着说明了本章所使用 LSTM，GRU 和 BiLSTM 这三个模型的网络结构，模型的编译和超参数设置，并进行了实验得到实验结果。最后对实验结果进行分析和本章小结。</p><p>第四章为基于 LightGBM-BiLSTM 的量化投资模型研究。本章首先大致介绍了实验步骤，然后分别介绍了实验所用的股票数据和因子数据。之后再对因子依次进行缺失值处理，去极值，因子标准化和因子中性化处理得到清洗后的因子。随后再利用 LightGBM 和 BiLSTM 分别进行因子选择和因子组合，最后根据得到的模型进行量化策略构建，并对量化策略进行回测。</p><p>第五章为总结与展望。本章对于本文关于股票价格预测与量化投资策略的主要研究内容进行了总结，之后针对目前研究所存在的不足，对未来研究的方向进行了展望。</p><h2 id=第二章-相关理论基础>第二章 相关理论基础<a hidden class=anchor aria-hidden=true href=#第二章-相关理论基础>#</a></h2><h3 id=21-深度学习模型>2.1 深度学习模型<a hidden class=anchor aria-hidden=true href=#21-深度学习模型>#</a></h3><h4 id=211-rnn>2.1.1 RNN<a hidden class=anchor aria-hidden=true href=#211-rnn>#</a></h4><p>循环神经网络（Recurrent Neural Network，RNN）被人们广泛地应用在序列数据上面，如自然语言和语音。股票每天的股价和交易信息都是序列数据，因此之前有很多工作，基于 RNN 来预测股票价格。RNN 采用十分简单的重复模块的链式结构，例如单个 tanh 层。由于基础的循环神经网络在层数过多的情况下，会出现梯度消失的问题，而 LSTM 的诞生，解决了此问题。Fig. 2 是 RNN 结构图。</p><figure class=align-center><img loading=lazy src=RNN.png#center alt="Fig. 2. RNN Structure Diagram. (Image source: Understanding LSTM Networks)"><figcaption><p>Fig. 2. RNN Structure Diagram. (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure><h4 id=212-lstm>2.1.2 LSTM<a hidden class=anchor aria-hidden=true href=#212-lstm>#</a></h4><p>长短时记忆网络（Long Short-Term Memory，LSTM）是一种特殊的 RNN，能够学习长期依赖关系。它们是由 <a href=https://www.bioinf.jku.at/publications/older/2604.pdf>Hochreiter & Schmidhuber（1997）</a>$^{[7]}$ 提出的，并在随后的工作中被许多人改进和推广。由于独特的设计结构，LSTM 有着间隙长度相对不敏感的特点，并且解决了传统 RNN 的梯度消失和梯度爆炸的问题。相对于传统 RNN 和隐马尔可夫模型（Hidden Markov Model，HMM）等其他时间序列模型，LSTM 能更好地处理和预测时间序列中间隔和延迟非常长的重要事件。因此，LSTM 广泛应用在机器翻译和语音识别的领域。</p><p>LSTM 被明确设计为避免长期依赖问题。所有的递归神经网络都具有神经网络的重复模块链的形式，而 LSTM 对 RNN 的结构进行了改进。LSTM 并没有采用单一神经网络层，而是采用一种特殊的方式进行交互的四层结构。</p><figure class=align-center><img loading=lazy src=LSTM.png#center alt="Fig. 3. LSTM Structure Diagram 1. (Image source: Understanding LSTM Networks)"><figcaption><p>Fig. 3. LSTM Structure Diagram 1. (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure><figure class=align-center><img loading=lazy src=LSTM2.png#center alt="Fig. 4. LSTM Structure Diagram 2. (Image source: Understanding LSTM Networks)"><figcaption><p>Fig. 4. LSTM Structure Diagram 2. (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure><p>如 Fig.3 所示，黑线用来表示传输一个节点的输出向量到另一个节点的输入向量。神经网络层（Neural network layer）是带有 $\sigma$ 激活函数或者 tanh 激活函数的处理模块；逐点运算（Pointwise operation）是代表向量与向量之间进行点乘运算；向量传输（Vector transfer）是表示信息传递方向；汇合（Concatenate）和复制（Copy）分别用两个黑线合在一起和两个黑线分开来表示信息的汇合和信息的复制。</p><p>下面我们以 LSTM 为例，进行其结构详细的说明。</p><ol><li><strong>遗忘门（forget gate）</strong></li></ol><figure class=align-center><img loading=lazy src=forget_gate.png#center alt="Fig. 5. Forget Gate Calculation (Image source: Understanding LSTM Networks)" width=70%><figcaption><p>Fig. 5. Forget Gate Calculation (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure>$$
f_{t} = \sigma\left(W_{f} \cdot \left[h_{t-1}, x_{t}\right] + b_{f}\right)
$$<p><strong>参数说明：</strong></p><ul><li>$h_{t-1}$ ：前一时刻的输出</li><li>$x_{t}$ ：当前时刻的输入</li><li>$\sigma$ ：sigmoid 激活函数</li><li>$W_{f}$ ：遗忘门的权重矩阵</li><li>$b_{f}$ ：遗忘门的偏差向量参数</li></ul><p>第一步如 Fig.5 所示，是一个决定从细胞状态中丢弃的信息的过程。该过程由 sigmoid 函数计算得到 $f_{t}$ 的值（$f_{t}$ 的范围在 0 到 1 之间，其中 0 代表完全不通过，1 代表完全通过）来决定细胞状态 $C_{t-1}$ 通过或者部分通过。</p><ol start=2><li><strong>输入门（input gate）</strong></li></ol><figure class=align-center><img loading=lazy src=input_gate1.png#center alt="Fig. 6. Input Gate Calculation (Image source: Understanding LSTM Networks)" width=70%><figcaption><p>Fig. 6. Input Gate Calculation (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure>$$
\begin{aligned}
i_{t} &= \sigma\left(W_{i} \cdot \left[h_{t-1}, x_{t}\right] + b_{i}\right) \\
\tilde{C}_{t} &= \tanh\left(W_{C} \cdot \left[h_{t-1}, x_{t}\right] + b_{C}\right)
\end{aligned}
$$<p><strong>参数说明：</strong></p><ul><li>$h_{t-1}$ ：前一时刻的输出</li><li>$x_{t}$ ：当前时刻的输入</li><li>$\sigma$ ：sigmoid 激活函数</li><li>$W_{i}$ ：输入门的权重矩阵</li><li>$b_{i}$ ：输入门的偏差向量参数</li><li>$W_{C}$ ：细胞状态的权重矩阵</li><li>$b_{C}$ ：细胞状态的偏差向量参数</li><li>$\tanh$ ：tanh 激活函数</li></ul><p>第二步如 Fig.6 所示，通过 sigmoid 函数计算我们要在细胞状态中存储什么信息，接下来通过一个 $\tanh$ 层创建候选向量 $\tilde{C}_{t}$，该向量将会被加到细胞的状态中。</p><figure class=align-center><img loading=lazy src=input_gate2.png#center alt="Fig. 7. Current Cell State Calculation (Image source: Understanding LSTM Networks)" width=70%><figcaption><p>Fig. 7. Current Cell State Calculation (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure>$$
C_{t} = f_{t} * C_{t-1} + i_{t} * \tilde{C}_{t}
$$<p><strong>参数说明：</strong></p><ul><li>$C_{t-1}$ ：上一时刻的细胞状态</li><li>$\tilde{C}_{t}$ ：临时细胞状态</li><li>$i_{t}$ ：输入门的值</li><li>$f_{t}$ ：遗忘门的值</li></ul><p>第三步如 Fig.7 所示，当前时刻的细胞状态 $C_t$ 通过结合遗忘门和输入门的作用计算得到。</p><ul><li>遗忘门 $f_t$ 对上一时刻的细胞状态 $C_{t-1}$ 进行加权，以丢弃不需要的信息。</li><li>输入门 $i_t$ 对候选细胞状态 $\tilde{C}_t$ 进行加权，决定引入多少新信息。<br>最终，两个部分相加，更新得出当前时刻的细胞状态 $C_t$。</li></ul><ol start=3><li><strong>输出门（output gate）</strong></li></ol><figure class=align-center><img loading=lazy src=output_gate.png#center alt="Fig. 8. Output Gate Calculation (Image source: Understanding LSTM Networks)" width=70%><figcaption><p>Fig. 8. Output Gate Calculation (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure>$$
\begin{aligned}
o_{t} &= \sigma\left(W_{o} \cdot \left[h_{t-1}, x_{t}\right] + b_{o}\right) \\
h_{t} &= o_{t} * \tanh\left(C_{t}\right)
\end{aligned}
$$<p><strong>参数说明：</strong></p><ul><li>$o_{t}$ ：输出门的值</li><li>$\sigma$ ：sigmoid 激活函数</li><li>$W_{o}$ ：输出门的权重矩阵</li><li>$h_{t-1}$ ：前一时刻的输出</li><li>$x_{t}$ ：当前时刻的输入</li><li>$b_{o}$ ：输出门的偏差向量参数</li><li>$h_{t}$ ：当前时刻的输出</li><li>$\tanh$ ：tanh 激活函数</li><li>$C_{t}$ ：当前时刻的细胞状态</li></ul><p>第四步如 Fig.8 所示，使用 sigmoid 函数计算输出门的值，最后通过 tanh 激活函数将这一时刻的细胞状态 $C_{t}$ 进行处理并与输出门的值 $o_{t}$ 相乘得到当前时刻的输出 $h_{t}$。</p><h4 id=213-gru>2.1.3 GRU<a hidden class=anchor aria-hidden=true href=#213-gru>#</a></h4><p><a href=https://arxiv.org/abs/1406.1078>K. Cho（2014）</a>$^{[8]}$ 提出了门控循环单元（Gated Recurrent Unit，GRU）。GRU 主要是在 LSTM 的基础上进行了简化和调整，将 LSTM 原有的遗忘门、输入门和输出门合并为更新门（update gate）和重置门（reset gate）。此外，GRU 还将细胞状态与隐藏状态合并，从而减少了模型的复杂性，同时在某些任务中仍能够达到与 LSTM 相当的性能。</p><p>该模型在训练数据集比较大的情况下可以节省很多时间，在某些较小和较不频繁的数据集上表现出更好的性能$^{[9][10]}$。</p><figure class=align-center><img loading=lazy src=GRU.png#center alt="Fig. 9. GRU Structure Diagram (Image source: Understanding LSTM Networks)" width=70%><figcaption><p>Fig. 9. GRU Structure Diagram (Image source: <a href=http://colah.github.io/posts/2015-08-Understanding-LSTMs/>Understanding LSTM Networks</a>)</p></figcaption></figure>$$
\begin{aligned}
z_{t} &= \sigma\left(W_{z} \cdot \left[h_{t-1}, x_{t}\right]\right) \\
r_{t} &= \sigma\left(W_{r} \cdot \left[h_{t-1}, x_{t}\right]\right) \\
\tilde{h}_{t} &= \tanh\left(W \cdot \left[r_{t} * h_{t-1}, x_{t}\right]\right) \\
h_{t} &= \left(1 - z_{t}\right) * h_{t-1} + z_{t} * \tilde{h}_{t}
\end{aligned}
$$<p><strong>参数说明：</strong></p><ul><li>$z_{t}$ ：更新门的值</li><li>$r_{t}$ ：重置门的值</li><li>$W_{z}$ ：更新门的权重矩阵</li><li>$W_{r}$ ：重置门的权重矩阵</li><li>$\tilde{h}_{t}$ ：临时的输出</li></ul><h4 id=214-bilstm>2.1.4 BiLSTM<a hidden class=anchor aria-hidden=true href=#214-bilstm>#</a></h4><p>双向长短时记忆网络（Bidirectional Long Short-Term Memory，BiLSTM）是由前向的 LSTM 与后向的 LSTM 结合成的。BiLSTM 模型充分利用了时间序列上向前，向后两个时间方向的上下文关系，能够学习到对时间有长期依赖性的信息，与单向 LSTM 相比可以更好地考虑未来数据的反向影响。Fig. 10 是 BiLSTM 结构图。</p><figure class=align-center><img loading=lazy src=BiLSTM.png#center alt="Fig. 10. BiLSTM Structure Diagram. (Image source: Baeldung)"><figcaption><p>Fig. 10. BiLSTM Structure Diagram. (Image source: <a href=https://www.baeldung.com/cs/bidirectional-vs-unidirectional-lstm>Baeldung</a>)</p></figcaption></figure><h3 id=22-量化选股理论>2.2 量化选股理论<a hidden class=anchor aria-hidden=true href=#22-量化选股理论>#</a></h3><h4 id=221-均值方差模型>2.2.1 均值－方差模型<a hidden class=anchor aria-hidden=true href=#221-均值方差模型>#</a></h4><p>量化选股策略起源于 20 世纪 50 年代，<a href=https://www.jstor.org/stable/2975974>Markowitz（1952）</a>$^{[11]}$ 提出了均值－方差模型（Mean-Variance Model）。该模型不仅奠定了现代投资组合理论的基础，将投资风险量化，还建立了一个描述风险和预期收益率的具体模型。它打破了以往仅对投资组合进行定性分析而缺乏定量分析的局面，将数学模型成功引入金融投资领域。</p>$$
\begin{aligned}
\mathrm{E}\left(R_{p}\right) &= \sum_{i=1}^{n} w_{i} \mathrm{E}\left(R_{i}\right) \\
\sigma_{p}^{2} &= \sum_{i=1}^{n} \sum_{j=1}^{n} w_{i} w_{j} \operatorname{Cov}\left(R_{i}, R_{j}\right) = \sum_{i=1}^{n} \sum_{j=1}^{n} w_{i} w_{j} \sigma_{i} \sigma_{j} \rho_{ij} \\
\sigma_{i} &= \sqrt{\operatorname{Var}\left(R_{i}\right)}, \quad \rho_{ij} = \operatorname{Corr}\left(R_{i}, R_{j}\right)
\end{aligned}
$$$$
\min \sigma_{p}^{2} \quad \text{subject to} \quad \sum_{i=1}^{n} \mathrm{E}\left(R_{i}\right) w_{i} = \mu_{p}, \quad \sum_{i=1}^{n} w_{i} = 1
$$$$
\begin{aligned}
\Omega &= \begin{pmatrix}
\sigma_{11} & \cdots & \sigma_{1n} \\
\vdots & \ddots & \vdots \\
\sigma_{n1} & \cdots & \sigma_{nn}
\end{pmatrix} = \begin{pmatrix}
\operatorname{Var}\left(R_{1}\right) & \cdots & \operatorname{Cov}\left(R_{1}, R_{n}\right) \\
\vdots & \ddots & \vdots \\
\operatorname{Cov}\left(R_{n}, R_{1}\right) & \cdots & \operatorname{Var}\left(R_{n}\right)
\end{pmatrix} \\
\Omega^{-1} &= \begin{pmatrix}
v_{11} & \cdots & v_{1n} \\
\vdots & \ddots & \vdots \\
v_{n1} & \cdots & v_{nn}
\end{pmatrix} \\
w_{i} &= \frac{1}{D}\left(\mu_{p} \sum_{j=1}^{n} v_{ij}\left(C \mathrm{E}\left(R_{j}\right) - A\right) + \sum_{j=1}^{n} v_{ij}\left(B - A \mathrm{E}\left(R_{j}\right)\right)\right), \quad i = 1, \ldots, n
\end{aligned}
$$$$
\begin{aligned}
A &= \sum_{i=1}^{n} \sum_{j=1}^{n} v_{ij} \mathrm{E}\left(R_{j}\right), \quad B = \sum_{i=1}^{n} \sum_{j=1}^{n} v_{ij} \mathrm{E}\left(R_{i}\right) \mathrm{E}\left(R_{j}\right), \quad C = \sum_{i=1}^{n} \sum_{j=1}^{n} v_{ij}, \quad D = BC - A^{2} > 0 \\
\sigma_{p}^{2} &= \frac{C \mu_{p}^{2} - 2A \mu_{p} + B}{D}
\end{aligned}
$$<p><strong>其中：</strong></p><ul><li>$\mathrm{E}\left(R_{p}\right)$ 和 $\mu_{p}$ 是投资组合 $p$ 的预期收益率</li><li>$\mathrm{E}\left(R_{i}\right)$ 是资产 $i$ 的预期收益率</li><li>$\sigma_{i}$ 是资产 $i$ 的标准差</li><li>$\sigma_{j}$ 是资产 $j$ 的标准差</li><li>$w_{i}$ 是资产 $i$ 在投资组合中的比例</li><li>$\sigma_{p}^{2}$ 是投资组合 $p$ 的方差</li><li>$\rho_{ij}$ 是资产 $i$ 和资产 $j$ 之间的相关系数</li></ul><p>通过以上公式$^{[12]}$，我们可以构建投资组合，来让我们的投资组合在一定的期望收益率的条件下，非系统风险降低到最小。</p><h4 id=222-资本资产定价模型>2.2.2 资本资产定价模型<a hidden class=anchor aria-hidden=true href=#222-资本资产定价模型>#</a></h4><p><a href=https://www.jstor.org/stable/2977928>William Sharpe（1964）</a>$^{[13]}$、<a href=https://www.jstor.org/stable/1924119>John Lintner（1965）</a>$^{[14]}$ 和 <a href=https://www.jstor.org/stable/1910098>Jan Mossin（1966）</a>$^{[15]}$ 提出了资本资产定价模型（Capital Asset Pricing Model，CAPM）。该模型认为，一项资产的预期收益与该资产的风险度量 $\beta$ 值相关。这一模型通过简单的线性关系，将资产的预期收益率与市场风险联系起来，使得 <a href=https://www.jstor.org/stable/2975974>Markowitz（1952）</a>$^{[11]}$ 的投资组合选择理论更贴近现实世界，同时为多因子选股模型的建立奠定了理论基础。</p><p>根据资本资产定价模型，对于一个给定的资产 $i$，它的预期收益率和市场投资组合的预期收益率之间的关系可以表示为：</p>$$
E\left(r_{i}\right) = r_{f} + \beta_{im}\left[E\left(r_{m}\right) - r_{f}\right]
$$<p><strong>其中：</strong></p><ul><li>$E\left(r_{i}\right)$ 是资产 $i$ 的预期收益率</li><li>$r_{f}$ 是无风险利率</li><li>$\beta_{im}$（Beta）是资产 $i$ 的系统性风险系数，$\beta_{im} = \frac{\operatorname{Cov}\left(r_{i}, r_{m}\right)}{\operatorname{Var}\left(r_{m}\right)}$</li><li>$E\left(r_{m}\right)$ 是市场投资组合 $m$ 的预期收益率</li><li>$E\left(r_{m}\right) - r_{f}$ 是市场风险溢价</li></ul><h4 id=223-套利定价理论和多因子模型>2.2.3 套利定价理论和多因子模型<a hidden class=anchor aria-hidden=true href=#223-套利定价理论和多因子模型>#</a></h4><p><a href=https://www.top1000funds.com/wp-content/uploads/2014/05/The-Arbitrage-Theory-of-Capital-Asset-Pricing.pdf>Ross（1976）</a>$^{[16]}$ 提出了套利定价理论（Arbitrage Pricing Theory，APT）。该理论认为，套利行为是形成市场均衡价格的决定性因素，通过在收益率形成过程中引入一系列因子构建线性相关关系，克服了资本资产定价模型（CAPM）的局限性，为后续研究者提供了重要的理论指导。</p><p>套利定价理论被认为是多因子模型（Multiple-Factor Model，MFM）的理论基础，是资产价格模型的重要组成部分，也是资产价格理论的基石之一。多因子模型的一般表达形式为：</p>$$
r_{j} = a_{j} + \lambda_{j1} f_{1} + \lambda_{j2} f_{2} + \cdots + \lambda_{jn} f_{n} + \delta_{j}
$$<p><strong>其中：</strong></p><ul><li>$r_{j}$ 是资产 $j$ 的收益率</li><li>$a_{j}$ 是资产 $j$ 的常数</li><li>$f_{n}$ 是系统性因素</li><li>$\lambda_{jn}$ 是因子载荷</li><li>$\delta_{j}$ 是随机误差</li></ul><h4 id=224-famafrench-三因子模型和五因子模型>2.2.4 Fama－French 三因子模型和五因子模型<a hidden class=anchor aria-hidden=true href=#224-famafrench-三因子模型和五因子模型>#</a></h4><p><a href=https://www.bauer.uh.edu/rsusmel/phd/Fama-French_JFE93.pdf>Fama（1992）和 French（1992）</a>$^{[17]}$ 使用横截面回归与时间序列结合的方法发现，股票市场的 $\beta$ 值无法解释不同股票回报率的差异，而上市公司的市值、账面市值比和市盈率等可以显著解释股票回报率的差异。他们认为超额收益是对 CAPM 中 $\beta$ 未能反映的风险因素的补偿，由此提出了 Fama－French 三因子模型。这三个因子分别为：</p><ul><li><p><strong>市场风险溢价因子</strong>（Market Risk Premium）</p><ul><li>表示市场整体的系统性风险，即市场投资组合的预期收益减去无风险利率的差值。</li><li>衡量投资者承担系统性风险（即无法通过分散投资消除的风险）所期望的超额回报。</li><li>计算公式为：<br>$$
\text{Market Risk Premium} = E(R_m) - R_f
$$
其中 $E(R_m)$ 是市场的预期收益率，$R_f$ 是无风险利率。</li></ul></li><li><p><strong>市值因子</strong>（Size, SMB: Small Minus Big）</p><ul><li>表示小市值股票与大市值股票之间的收益差异。</li><li>小市值股票通常风险更高，但历史数据显示，其预期收益也往往高于大市值股票。</li><li>计算公式为：<br>$$
SMB = R_{\text{Small}} - R_{\text{Big}}
$$
反映了市场对小市值股票的额外风险溢价的补偿。</li></ul></li><li><p><strong>账面市值比因子</strong>（Value, HML: High Minus Low）</p><ul><li>反映高账面市值比（即“价值型股票”）与低账面市值比（即“成长型股票”）之间的收益差异。</li><li>高账面市值比的股票通常定价较低（被市场低估），但长期来看可能获得较高回报。</li><li>计算公式为：<br>$$
HML = R_{\text{High}} - R_{\text{Low}}
$$
低账面市值比的股票可能因市场对其过于乐观的预期而被高估。</li></ul></li></ul><p>该模型将 APT 模型中的因子具体化，并得出结论：投资小市值、高成长的股票具有高风险高收益的特性。Fama－French 三因子模型被广泛应用于现代投资行为的分析和实践中。</p><p>随后，<a href=https://tevgeniou.github.io/EquityRiskFactors/bibliography/FiveFactor.pdf>Fama（2015）和 French（2015）</a>$^{[18]}$ 对三因子模型进行了扩展，新增了以下两个因子：</p><ul><li><p><strong>盈利水平因子</strong>（Profitability, RMW: Robust Minus Weak）</p><ul><li>反映高盈利公司与低盈利公司之间的收益差异。</li><li>盈利能力强的公司（高 ROE、净利润率）更可能提供稳定且较高的回报。</li><li>计算公式为：<br>$$
RMW = R_{\text{Robust}} - R_{\text{Weak}}
$$</li></ul></li><li><p><strong>投资水平因子</strong>（Investment, CMA: Conservative Minus Aggressive）</p><ul><li>反映保守型投资公司与激进型投资公司之间的收益差异。</li><li>激进型公司（扩张迅速，资本开支较高）通常伴随着更大的经营风险，而保守型公司（资本支出相对稳健）表现出更高的稳定性和收益。</li><li>计算公式为：<br>$$
CMA = R_{\text{Conservative}} - R_{\text{Aggressive}}
$$</li></ul></li></ul><p>Fama-French 三因子模型公式为：</p>$$
R_i - R_f = \alpha_i + \beta_{i,m} \cdot (R_m - R_f) + \beta_{i,SMB} \cdot SMB + \beta_{i,HML} \cdot HML + \epsilon_i
$$<p>Fama-French 五因子模型公式为：</p>$$
R_i - R_f = \alpha_i + \beta_{i,m} \cdot (R_m - R_f) + \beta_{i,SMB} \cdot SMB + \beta_{i,HML} \cdot HML + \beta_{i,RMW} \cdot RMW + \beta_{i,CMA} \cdot CMA + \epsilon_i
$$<p><strong>其中：</strong></p><ul><li>$R_i$: 股票 $i$ 的预期收益率</li><li>$R_f$: 无风险收益率</li><li>$R_m$: 市场组合的预期收益率</li><li>$R_m - R_f$: 市场风险溢价因子</li><li>$SMB$: 小市值减去大市值股票收益</li><li>$HML$: 高账面市值比减去低账面市值比股票收益</li><li>$RMW$: 高盈利能力减去低盈利能力股票收益</li><li>$CMA$: 低投资活动减去高投资活动股票收益</li><li>$\beta_{i,*}$: 股票 $i$ 对应因子的敏感度</li><li>$\epsilon_i$: 回归残差</li></ul><h4 id=225-模型对比表格>2.2.5 模型对比表格<a hidden class=anchor aria-hidden=true href=#225-模型对比表格>#</a></h4><p>以下表格总结了 <strong>均值-方差模型</strong>、<strong>资本资产定价模型 (CAPM)</strong>、<strong>套利定价理论 (APT)</strong> 和 <strong>Fama-French 模型</strong> 的核心内容及因子来源：</p><table><thead><tr><th><strong>模型</strong></th><th><strong>核心内容</strong></th><th><strong>因子来源</strong></th></tr></thead><tbody><tr><td><strong>均值-方差模型</strong></td><td>投资组合理论的基础，通过期望收益和协方差矩阵优化投资组合。</td><td>投资组合中资产的期望收益和协方差矩阵</td></tr><tr><td><strong>资本资产定价模型 (CAPM)</strong></td><td>通过市场风险因子（$\beta$）解释资产收益，奠定多因子模型理论基础。</td><td>市场因子 $\beta$</td></tr><tr><td><strong>套利定价理论 (APT)</strong></td><td>多因子框架，允许多个经济变量解释资产收益，例如通胀率、利率等。</td><td>多因子（宏观经济变量，如通胀率、利率等）</td></tr><tr><td><strong>Fama-French 三因子模型</strong></td><td>增加市值因子和账面市值比因子，改进对资产收益的解释能力。</td><td>市场因子、SMB（市值因子）、HML（账面市值比因子）</td></tr><tr><td><strong>Fama-French 五因子模型</strong></td><td>在三因子模型基础上增加盈利因子和投资因子，进一步完善资产定价模型。</td><td>市场因子、SMB、HML、RMW（盈利因子）、CMA（投资因子）</td></tr></tbody></table><p>以下表格总结了这些模型的优点及不足：</p><table><thead><tr><th><strong>模型</strong></th><th><strong>优点</strong></th><th><strong>不足</strong></th></tr></thead><tbody><tr><td><strong>均值-方差模型</strong></td><td>提供了系统化投资组合优化方法，奠定现代投资理论基础。</td><td>仅针对收益和方差进行优化，未明确风险补偿的来源。</td></tr><tr><td><strong>资本资产定价模型 (CAPM)</strong></td><td>简单易用，通过市场风险解释收益差异，为多因子模型提供理论基础。</td><td>假设单因子（市场风险）决定收益，忽略其他系统性风险因子。</td></tr><tr><td><strong>套利定价理论 (APT)</strong></td><td>允许多个因子解释资产收益，减少对单因子假设的依赖，更灵活。</td><td>未明确具体因子，实操性较低，仅提供框架。</td></tr><tr><td><strong>Fama-French 三因子模型</strong></td><td>通过增加市值因子和账面市值比因子，显著提高了对资产收益的解释能力。</td><td>忽略了盈利能力和投资行为等其他因子。</td></tr><tr><td><strong>Fama-French 五因子模型</strong></td><td>在三因子模型基础上增加盈利因子和投资因子，更全面地捕捉影响资产收益的关键变量。</td><td>模型复杂度较高，对数据要求高，仍可能遗漏某些潜在因子。</td></tr></tbody></table><h2 id=第三章-lstmgru-和-bilstm-在股票价格预测中比较研究>第三章 LSTM，GRU 和 BiLSTM 在股票价格预测中比较研究<a hidden class=anchor aria-hidden=true href=#第三章-lstmgru-和-bilstm-在股票价格预测中比较研究>#</a></h2><h3 id=31-实验数据介绍>3.1 实验数据介绍<a hidden class=anchor aria-hidden=true href=#31-实验数据介绍>#</a></h3><p>国内外很多学者的研究以本国的股票指数为主，对于不同市场的单个股票研究相对较少。并且很少有研究将 LSTM、GRU、BiLSTM 这三个模型进行对比研究。因此本文分别选择国内 A 股上海浦东发展银行（简称浦发银行，代码600000）和美股 International Business Machines Corporation（简称 IBM）进行研究，这样更能准确地对我们使用的三个模型进行对比。其中浦发银行采用 2008 年 1 月 1 日到 2020 年 12 月 31 日的股票数据，共有 3114 条有效数据，数据来源于 Tushare 金融大数据平台。我们选取该数据集的日期（date）、开盘价（open）、收盘价（close）、最高价（high）、最低价（low）和成交量（volume）这 6 个特征进行实验。浦发银行的数据集除日期作为时间序列的索引以外，其他 5 个特征均作为自变量。IBM 采用 1990 年 1 月 2 日到 2018 年 11 月 15 日的股票数据，共有 7278 条有效数据，数据来源于雅虎财经。我们选取该数据集的日期（date）、开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、调整后的收盘价（Adj Close）和成交量（volume）这 7 个特征进行实验。IBM 的数据集除日期作为时间序列的索引以外，其他 6 个特征均作为自变量。本次实验选择收盘价（close）作为被预测的变量。表3.1.1和表3.1.2分别是两个数据集的部分数据。</p><h4 id=311-浦发银行数据集部分展示>3.1.1 浦发银行数据集部分展示<a hidden class=anchor aria-hidden=true href=#311-浦发银行数据集部分展示>#</a></h4><table><thead><tr><th>date</th><th>open</th><th>close</th><th>high</th><th>low</th><th>volume</th><th>code</th></tr></thead><tbody><tr><td>2008-01-02</td><td>9.007</td><td>9.101</td><td>9.356</td><td>8.805</td><td>131583.90</td><td>600000</td></tr><tr><td>2008-01-03</td><td>9.007</td><td>8.645</td><td>9.101</td><td>8.426</td><td>211346.56</td><td>600000</td></tr><tr><td>2008-01-04</td><td>8659</td><td>9.009</td><td>9.111</td><td>8.501</td><td>139249.67</td><td>600000</td></tr><tr><td>2008-01-07</td><td>8.970</td><td>9.515</td><td>9.593</td><td>8.953</td><td>228043.01</td><td>600000</td></tr><tr><td>2008-01-08</td><td>9.551</td><td>9.583</td><td>9.719</td><td>9.517</td><td>161255.31</td><td>600000</td></tr><tr><td>2008-01-09</td><td>9.583</td><td>9.663</td><td>9.772</td><td>9.432</td><td>102510.92</td><td>600000</td></tr><tr><td>2008-01-10</td><td>9.701</td><td>9.680</td><td>9.836</td><td>9.602</td><td>217966.25</td><td>600000</td></tr><tr><td>2008-01-11</td><td>9.670</td><td>10.467</td><td>10.532</td><td>9.670</td><td>231544.21</td><td>600000</td></tr><tr><td>2008-01-14</td><td>10.367</td><td>10.059</td><td>10.433</td><td>10.027</td><td>142918.39</td><td>600000</td></tr><tr><td>2008-01-15</td><td>10.142</td><td>10.051</td><td>10.389</td><td>10.006</td><td>161221.52</td><td>600000</td></tr></tbody></table><p><strong>数据来源</strong>：<a href=https://github.com/waditu/tushare>Tushare</a></p><h4 id=312-ibm数据集部分展示>3.1.2 IBM数据集部分展示<a hidden class=anchor aria-hidden=true href=#312-ibm数据集部分展示>#</a></h4><table><thead><tr><th>Date</th><th>Open</th><th>High</th><th>Low</th><th>Close</th><th>Adj Close</th><th>Volume</th></tr></thead><tbody><tr><td>1990-01-02</td><td>23.6875</td><td>24.5313</td><td>23.6250</td><td>24.5000</td><td>6.590755</td><td>7041600</td></tr><tr><td>1990-01-03</td><td>24.6875</td><td>24.8750</td><td>24.5938</td><td>24.7188</td><td>6.649599</td><td>9464000</td></tr><tr><td>1990-01-04</td><td>24.7500</td><td>25.0938</td><td>24.7188</td><td>25.0000</td><td>6.725261</td><td>9674800</td></tr><tr><td>1990-01-05</td><td>24.9688</td><td>25.4063</td><td>24.8750</td><td>24.9375</td><td>6.708448</td><td>7570000</td></tr><tr><td>1990-01-08</td><td>24.8125</td><td>25.2188</td><td>24.8125</td><td>25.0938</td><td>6.750481</td><td>4625200</td></tr><tr><td>1990-01-09</td><td>25.1250</td><td>25.3125</td><td>24.8438</td><td>24.8438</td><td>6.683229</td><td>7048000</td></tr><tr><td>1990-01-10</td><td>24.8750</td><td>25.0000</td><td>24.6563</td><td>24.7500</td><td>6.658009</td><td>5945600</td></tr><tr><td>1990-01-11</td><td>24.8750</td><td>25.0938</td><td>24.8438</td><td>24.9688</td><td>6.716855</td><td>5905600</td></tr><tr><td>1990-01-12</td><td>24.6563</td><td>24.8125</td><td>24.4063</td><td>24.4688</td><td>6.582347</td><td>5390800</td></tr><tr><td>1990-01-15</td><td>24.4063</td><td>24.5938</td><td>24.3125</td><td>24.5313</td><td>6.599163</td><td>4035600</td></tr></tbody></table><p><strong>数据来源</strong>：<a href=https://finance.yahoo.com/quote/IBM/history/>雅虎财经</a></p><h3 id=32-实验数据预处理>3.2 实验数据预处理<a hidden class=anchor aria-hidden=true href=#32-实验数据预处理>#</a></h3><h4 id=321-数据的归一化>3.2.1 数据的归一化<a hidden class=anchor aria-hidden=true href=#321-数据的归一化>#</a></h4><p>实验中各个特征在单位和量级上存在差异，比如股票价格和成交量之间量级差异巨大，会对我们实验最终预测的结果产生影响。因此我们采用 <code>sklearn.preprocessing</code> 库中的 <code>MinMaxScaler</code> 方法将数据的特征缩放至 0 到 1 之间。这样既能提升模型精度，也能提升模型收敛速度。归一化公式：</p>$$
x^{\prime}=\frac{x-\min (x)}{\max (x)-\min (x)}
$$<p>其中 $x^{\prime}$ 是归一化后的数据，$x$ 是原始数据， $\min (x)$ 是原始数据集的最小值， $\max (x)$ 是原始数据集的最大值。之后在我们的实验过程中获得预测结果之后，还要将数据进行反归一化处理，之后才能进行对于股票价格的预测和模型评估。</p><h4 id=322-数据的划分>3.2.2 数据的划分<a hidden class=anchor aria-hidden=true href=#322-数据的划分>#</a></h4><p>此处分别将浦发银行和 IBM 的整个实验数据集送入，设置循环核时间步（timestep）都为 60，每个时间步输入特征个数分别为 5 和 6。这样可以输入前 60 个交易日的数据，预测出第 61 天的收盘价。使我们的数据集符合之后要比较的三种神经网络模型输入的要求，依次是送入样本数，循环核时间展开步数和每个时间步输入特征个数。之后我们再将浦发银行的数据集按照 2488：311：255 的比例将归一化的数据集划分为训练集，验证集，测试集三个部分。将 IBM 的数据集按照 6550：364：304 的比例将归一化的数据集划分为训练集，验证集，测试集三个部分。我们这里划分出验证集的目的是为了方便进行调整模型的超参数以便优化各个模型之后再进行比较。</p><h3 id=33-模型网络结构>3.3 模型网络结构<a hidden class=anchor aria-hidden=true href=#33-模型网络结构>#</a></h3><p>本文通过大量反复试验最终各个模型设置的网络结构如下表所示，其中层与层之间使用循环神经网络默认的 tanh 和 linear 作为激活函数，并且为了防止过拟合加入 Dropout，Dropout 的丢弃比例（rate）取值为 0.2。LSTM 和 GRU 每个循环层的神经元个数为 50，BiLSTM 循环层的神经元的个数为 100。LSTM、GRU、BiLSTM 每个模型分别采用四层 LSTM、GRU、BiLSTM 和一层全连接层，其中每层网络之间都设置了一个 Dropout。</p><h4 id=331-ibm的lstm网络结构>3.3.1 IBM的LSTM网络结构<a hidden class=anchor aria-hidden=true href=#331-ibm的lstm网络结构>#</a></h4><table><thead><tr><th>Layer(type)</th><th>Output Shape</th><th>Param#</th></tr></thead><tbody><tr><td>lstm_1 (LSTM)</td><td>(None, 60, 50)</td><td>11400</td></tr><tr><td>dropout_1 (Dropout)</td><td>(None, 60, 50)</td><td>0</td></tr><tr><td>lstm_2 (LSTM)</td><td>(None, 60, 50)</td><td>20200</td></tr><tr><td>dropout_2 (Dropout)</td><td>(None, 60, 50)</td><td>0</td></tr><tr><td>lstm_3 (LSTM)</td><td>(None, 60, 50)</td><td>20200</td></tr><tr><td>dropout_3 (Dropout)</td><td>(None, 60, 50)</td><td>0</td></tr><tr><td>lstm_4 (LSTM)</td><td>(None, 50)</td><td>20200</td></tr><tr><td>dropout_4 (Dropout)</td><td>(None, 50)</td><td>0</td></tr><tr><td>dense_1 (Dense)</td><td>(None, 1)</td><td>51</td></tr></tbody></table><p><strong>Total params</strong>：72,051<br><strong>Trainable params</strong>：72,051<br><strong>Non-trainable params</strong>：0</p><hr><h4 id=332-ibm的gru网络结构>3.3.2 IBM的GRU网络结构<a hidden class=anchor aria-hidden=true href=#332-ibm的gru网络结构>#</a></h4><table><thead><tr><th>Layer(type)</th><th>Output Shape</th><th>Param#</th></tr></thead><tbody><tr><td>gru_1 (GRU)</td><td>(None, 60, 50)</td><td>8550</td></tr><tr><td>dropout_1 (Dropout)</td><td>(None, 60, 50)</td><td>0</td></tr><tr><td>gru_2 (GRU)</td><td>(None, 60, 50)</td><td>15150</td></tr><tr><td>dropout_2 (Dropout)</td><td>(None, 60, 50)</td><td>0</td></tr><tr><td>gru_3 (GRU)</td><td>(None, 60, 50)</td><td>15150</td></tr><tr><td>dropout_3 (Dropout)</td><td>(None, 60, 50)</td><td>0</td></tr><tr><td>gru_4 (GRU)</td><td>(None, 50)</td><td>15150</td></tr><tr><td>dropout_4 (Dropout)</td><td>(None, 50)</td><td>0</td></tr><tr><td>dense_1 (Dense)</td><td>(None, 1)</td><td>51</td></tr></tbody></table><p><strong>Total params</strong>：54,051<br><strong>Trainable params</strong>：54,051<br><strong>Non-trainable params</strong>：0</p><hr><h4 id=333-ibm的bilstm网络结构>3.3.3 IBM的BiLSTM网络结构<a hidden class=anchor aria-hidden=true href=#333-ibm的bilstm网络结构>#</a></h4><table><thead><tr><th>Layer(type)</th><th>Output Shape</th><th>Param#</th></tr></thead><tbody><tr><td>bidirectional_1 (Bidirection)</td><td>(None, 60, 100)</td><td>22800</td></tr><tr><td>dropout_1 (Dropout)</td><td>(None, 60, 100)</td><td>0</td></tr><tr><td>bidirectional_2 (Bidirection)</td><td>(None, 60, 100)</td><td>60400</td></tr><tr><td>dropout_2 (Dropout)</td><td>(None, 60, 100)</td><td>0</td></tr><tr><td>bidirectional_3 (Bidirection)</td><td>(None, 60, 100)</td><td>60400</td></tr><tr><td>dropout_3 (Dropout)</td><td>(None, 60, 100)</td><td>0</td></tr><tr><td>bidirectional_4 (Bidirection)</td><td>(None, 100)</td><td>60400</td></tr><tr><td>dropout_4 (Dropout)</td><td>(None, 100)</td><td>0</td></tr><tr><td>dense_1 (Dense)</td><td>(None, 1)</td><td>101</td></tr></tbody></table><p><strong>Total params</strong>：204,101<br><strong>Trainable params</strong>：204,101<br><strong>Non-trainable params</strong>：0</p><h3 id=34-模型和编译及超参数设置>3.4 模型和编译及超参数设置<a hidden class=anchor aria-hidden=true href=#34-模型和编译及超参数设置>#</a></h3><p>本文模型在以验证集的损失函数最小为目标，进行不断的超参数调试之后，对于浦发银行的三个模型都选用 <code>epochs=100</code>，<code>batch_size=32</code>；对于 IBM 的三个模型都选用 <code>epochs=50</code>，<code>batch_size=32</code>。其中优化器都采用自适应矩估计<a href=https://arxiv.org/abs/1412.6980>（Adaptive moment estimation，Adam）</a>$^{[19]}$。使用其 <code>keras</code> 包中的默认值，即 <code>lr=0.001</code>、<code>beta_1=0.9</code>、<code>beta_2=0.999</code>、<code>epsilon=1e-08</code> 和 <code>decay=0.0</code>。损失函数采用均方误差（Mean Square Error，MSE）。</p><p><strong>参数解释：</strong></p><ul><li><code>lr</code>：学习率</li><li><code>beta_1</code>：一阶矩估计的指数衰减率</li><li><code>beta_2</code>：二阶矩估计的指数衰减率</li><li><code>epsilon</code>：模糊因子</li><li><code>decay</code>：每次更新后的学习率衰减值</li></ul><h3 id=35-实验结果与分析>3.5 实验结果与分析<a hidden class=anchor aria-hidden=true href=#35-实验结果与分析>#</a></h3><p>首先简单介绍一下模型使用评价的这几个指标。计算公式如下：</p><ol><li><strong>均方误差（Mean Square Error，MSE）</strong>：</li></ol>$$
M S E=\frac{1}{n} \sum_{i=1}^{n}\left(Y_{i}-\hat{Y}_{i}\right)^{2}
$$<ol start=2><li><strong>均方根误差（Root Mean Squared Error，RMSE)</strong>：</li></ol>$$
R M S E=\sqrt{\frac{1}{n} \sum_{i=1}^{n}\left(Y_{i}-\hat{Y}_{i}\right)^{2}}
$$<ol start=3><li><strong>平均绝对误差（Mean Absolute Error，MAE）</strong>：</li></ol>$$
M A E=\frac{1}{n} \sum_{i=1}^{n}\left|Y_{i}-\hat{Y}_{i}\right|
$$<ol start=4><li><strong>\( R^2 \)（R Squared）</strong>：</li></ol>$$
\begin{gathered}
\bar{Y}=\frac{1}{n} \sum_{i=1}^{n} Y_{i} \\
R^{2}=1-\frac{\sum_{i=1}^{n}\left(Y_{i}-\hat{Y}_{i}\right)^{2}}{\sum_{i=1}^{n}\left(Y_{i}-\bar{Y}\right)^{2}}
\end{gathered}
$$<p>其中：$n$ 是样本的数量，$Y$ 是股票实际的收盘价，$\hat{Y}_{i}$ 是股票预测的收盘价， $\bar{Y}$ 是股票平均的收盘价。MSE，RMSE 和 MAE 越小该模型越精确。 $R^{2}$ 评价模型系数拟合优度越大越好。</p><h4 id=351-浦发银行实验结果>3.5.1 浦发银行实验结果<a hidden class=anchor aria-hidden=true href=#351-浦发银行实验结果>#</a></h4><table><thead><tr><th></th><th>LSTM</th><th>GRU</th><th>BiLSTM</th></tr></thead><tbody><tr><td><strong>MSE</strong></td><td>0.059781</td><td>0.069323</td><td>0.056454</td></tr><tr><td><strong>RMSE</strong></td><td>0.244501</td><td>0.263292</td><td>0.237601</td></tr><tr><td><strong>MAE</strong></td><td>0.186541</td><td>0.202665</td><td>0.154289</td></tr><tr><td><strong>R-squared</strong></td><td>0.91788</td><td>0.896214</td><td>0.929643</td></tr></tbody></table><p>比较三个模型的评价指标，我们可以发现在浦发银行测试集上 BiLSTM 模型的 MSE、RMSE 和 MAE 都小于 LSTM 模型和 GRU 模型，而 R-Squared 都大于 LSTM 模型和 GRU 模型。我们通过对比 RMSE 发现，BiLSTM 相较于 LSTM 在验证集上有 2.90%的性能提升，BiLSTM 相较于 GRU 在验证集上有 10.81%的性能提升。</p><h4 id=352-ibm实验结果>3.5.2 IBM实验结果<a hidden class=anchor aria-hidden=true href=#352-ibm实验结果>#</a></h4><table><thead><tr><th></th><th>LSTM</th><th>GRU</th><th>BiLSTM</th></tr></thead><tbody><tr><td><strong>MSE</strong></td><td>18.01311</td><td>12.938584</td><td>11.057501</td></tr><tr><td><strong>RMSE</strong></td><td>4.244186</td><td>3.597024</td><td>3.325282</td></tr><tr><td><strong>MAE</strong></td><td>3.793223</td><td>3.069033</td><td>2.732075</td></tr><tr><td><strong>R-squared</strong></td><td>0.789453</td><td>0.851939</td><td>0.883334</td></tr></tbody></table><p>比较三个模型的评价指标，我们可以发现在 IBM 测试集上 BiLSTM 模型的 MSE、RMSE 和 MAE 都小于 LSTM 模型和 GRU 模型，而 R-Squared 都大于 LSTM 模型和 GRU 模型。我们通过对比 RMSE 发现，BiLSTM 相较于 LSTM 在验证集上有 27.63%的性能提升，BiLSTM 相较于 GRU 在验证集上有 8.17%的性能提升。</p><h3 id=36-本章小结>3.6 本章小结<a hidden class=anchor aria-hidden=true href=#36-本章小结>#</a></h3><p>本章先是介绍了实验所选用的浦发银行和 IBM 两个数据集以及选用的特征，之后对数据集进行了归一化、数据划分的预处理步骤。同时详细的说明了实验所使用 LSTM、GRU 和 BiLSTM 模型的网络结构和超参数。最后得到了每个模型的损失函数图像和一系列的拟合图形。比较了模型的多个评价指标和拟合图像最终得到 BiLSTM 模型能够更好地对股票价格进行预测，为我们下一章研究 LightGBM-BiLSTM 的量化投资策略奠定了基础。</p><hr><h2 id=第四章-基于-lightgbm-bilstm-的量化投资模型研究>第四章 基于 LightGBM-BiLSTM 的量化投资模型研究<a hidden class=anchor aria-hidden=true href=#第四章-基于-lightgbm-bilstm-的量化投资模型研究>#</a></h2><h3 id=41-实验步骤>4.1 实验步骤<a hidden class=anchor aria-hidden=true href=#41-实验步骤>#</a></h3><figure class=align-center><img loading=lazy src=LightGBM_BiLSTM_Flow.png#center alt="Fig. 11. LightGBM-BiLSTM Diagram."><figcaption><p>Fig. 11. LightGBM-BiLSTM Diagram.</p></figcaption></figure><p>如 Fig.11 所示，本实验先从因子库中选取 50 个因子。之后对因子依次进行去极值、标准化和缺损值填充的因子清洗步骤。再利用 LightGBM 模型进行因子选择，根据因子重要性进行排序得到前十的因子作为本横截面挑选出来的因子。紧接着使用 BiLSTM 建立多因子模型，最后再进行回测分析。</p><h3 id=42-实验数据>4.2 实验数据<a hidden class=anchor aria-hidden=true href=#42-实验数据>#</a></h3><p>本文采用的行情数据来源于 <a href=https://github.com/waditu/tushare>Tushare</a>。具体数据集的特征如下表所示。</p><h4 id=421-股票数据集包含的特征>4.2.1 股票数据集包含的特征<a hidden class=anchor aria-hidden=true href=#421-股票数据集包含的特征>#</a></h4><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ts_code</td><td>str</td><td>股票代码</td></tr><tr><td>trade_date</td><td>str</td><td>交易日期</td></tr><tr><td>open</td><td>float</td><td>开盘价</td></tr><tr><td>high</td><td>float</td><td>最高价</td></tr><tr><td>low</td><td>float</td><td>最低价</td></tr><tr><td>close</td><td>float</td><td>收盘价</td></tr><tr><td>pre_close</td><td>float</td><td>昨收价</td></tr><tr><td>change</td><td>float</td><td>涨跌额</td></tr><tr><td>pct_chg</td><td>float</td><td>涨跌幅（未复权）</td></tr><tr><td>vol</td><td>float</td><td>成交量（手）</td></tr><tr><td>amount</td><td>float</td><td>成交额（千元）</td></tr></tbody></table><p>A股全市场日线数据集包含5,872,309行数据，即包含5,872,309个样本。如表4.2.1所示，A股全市场日线数据集数据集有以下11个特征，分别依次为股票代码（ts_code）、交易日期（trade_date）、开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、昨收价（pre_close）、涨跌额（change）、换手率（turnover_rate）、交易金额（amount）、总市值（total_mv）和复权因子（adj_factor）。</p><h4 id=422-a股全市场日线数据集部分展示>4.2.2 A股全市场日线数据集部分展示<a hidden class=anchor aria-hidden=true href=#422-a股全市场日线数据集部分展示>#</a></h4><table><thead><tr><th>ts_code</th><th>trade_date</th><th>open</th><th>high</th><th>low</th><th>close</th><th>pre_close</th><th>change</th><th>vol</th><th>amount</th></tr></thead><tbody><tr><td>600613.SH</td><td>20120104</td><td>8.20</td><td>8.20</td><td>7.84</td><td>7.86</td><td>8.16</td><td>-0.30</td><td>4762.98</td><td>3854.1000</td></tr><tr><td>600690.SH</td><td>20120104</td><td>9.00</td><td>9.17</td><td>8.78</td><td>8.78</td><td>8.93</td><td>-0.15</td><td>142288.41</td><td>127992.6050</td></tr><tr><td>300277.SZ</td><td>20120104</td><td>22.90</td><td>22.98</td><td>20.81</td><td>20.88</td><td>22.68</td><td>-1.80</td><td>12212.39</td><td>26797.1370</td></tr><tr><td>002403.SZ</td><td>20120104</td><td>8.87</td><td>8.90</td><td>8.40</td><td>8.40</td><td>8.84</td><td>-0.441</td><td>10331.97</td><td>9013.4317</td></tr><tr><td>300179.SZ</td><td>20120104</td><td>19.99</td><td>20.32</td><td>19.20</td><td>19.50</td><td>19.96</td><td>-0.46</td><td>1532.31</td><td>3008.0594</td></tr><tr><td>600000.SH</td><td>20120104</td><td>8.54</td><td>8.56</td><td>8.39</td><td>8.41</td><td>8.49</td><td>-0.08</td><td>342013.79</td><td>290229.5510</td></tr><tr><td>300282.SZ</td><td>20120104</td><td>22.90</td><td>23.33</td><td>21.02</td><td>21.02</td><td>23.35</td><td>-2.33</td><td>38408.60</td><td>86216.2356</td></tr><tr><td>002319.SZ</td><td>20120104</td><td>9.74</td><td>9.95</td><td>9.38</td><td>9.41</td><td>9.73</td><td>-0.32</td><td>4809.74</td><td>4671.4803</td></tr><tr><td>601991.SH</td><td>20120104</td><td>5.17</td><td>5.39</td><td>5.12</td><td>5.25</td><td>5.16</td><td>0.09</td><td>145268.38</td><td>76547.7490</td></tr><tr><td>000780.SZ</td><td>20120104</td><td>10.42</td><td>10.49</td><td>10.00</td><td>10.00</td><td>10.30</td><td>-0.30</td><td>20362.30</td><td>20830.1761</td></tr></tbody></table><p><strong>[5872309 rows x 11 columns]</strong></p><p>中证全指日线数据集包含5,057行数据，即包含5,057个样本。如表4.2.2所示，中证全指日线数据集有以下7个特征，分别依次为交易日期（trade_date）、开盘价（open）、最高价（high）、最低价（low）、收盘价（close）、交易量（volume）和昨收价（pre_close）。</p><h4 id=423-中证全指日线数据集部分展示>4.2.3 中证全指日线数据集部分展示<a hidden class=anchor aria-hidden=true href=#423-中证全指日线数据集部分展示>#</a></h4><table><thead><tr><th>trade_date</th><th>open</th><th>high</th><th>low</th><th>close</th><th>volume</th><th>pre_close</th></tr></thead><tbody><tr><td>2006-11-24</td><td>1564.3560</td><td>1579.3470</td><td>1549.9790</td><td>1576.1530</td><td>7.521819e+09</td><td>1567.0910</td></tr><tr><td>2006-11-27</td><td>1574.1130</td><td>1598.7440</td><td>1574.1130</td><td>1598.7440</td><td>7.212786e+09</td><td>1581.1530</td></tr><tr><td>2006-11-28</td><td>1597.7200</td><td>1604.7190</td><td>1585.3620</td><td>1596.8400</td><td>7.025637e+09</td><td>1598.7440</td></tr><tr><td>2006-11-29</td><td>1575.3030</td><td>1620.2870</td><td>1575.3030</td><td>1617.9880</td><td>7.250354e+09</td><td>1596.8400</td></tr><tr><td>2006-11-30</td><td>1621.4280</td><td>1657.3230</td><td>1621.4280</td><td>1657.3230</td><td>9.656888e+09</td><td>1617.9880</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr><tr><td>2020-11-11</td><td>5477.8870</td><td>5493.5867</td><td>5422.9110</td><td>5425.8017</td><td>5.604086e+10</td><td>5494.1042</td></tr><tr><td>2020-11-12</td><td>5439.2296</td><td>5454.3452</td><td>5413.9659</td><td>5435.1379</td><td>4.594251e+10</td><td>5425.8017</td></tr><tr><td>2020-11-13</td><td>5418.2953</td><td>5418.3523</td><td>5364.2031</td><td>5402.7702</td><td>4.688916e+10</td><td>5435.1379</td></tr><tr><td>2020-11-16</td><td>5422.3565</td><td>5456.7264</td><td>5391.9232</td><td>5456.7264</td><td>5.593672e+10</td><td>5402.7702</td></tr><tr><td>2020-11-17</td><td>5454.0696</td><td>5454.0696</td><td>5395.6052</td><td>5428.0765</td><td>5.857009e+10</td><td>5456.7264</td></tr></tbody></table><p><strong>[5057 rows x 7 columns]</strong></p><p>下表4.2.4是原始的因子部分数据。依次经过上述因子缺失值填充、因子去极值、因子标准化和因子中性化这 4 个因子清洗的步骤后，得到如表4.2.5展示的经过因子清洗后的因子部分数据。</p><h4 id=424-原始的因子数据>4.2.4 原始的因子数据<a hidden class=anchor aria-hidden=true href=#424-原始的因子数据>#</a></h4><table><thead><tr><th>trade_date</th><th>sec_code</th><th>ret</th><th>factor_0</th><th>factor_1</th><th>factor_2</th><th>factor_3</th><th>factor_4</th><th>factor_5</th><th>factor_6</th><th>&mldr;</th></tr></thead><tbody><tr><td>2005-01-04</td><td>600874.SH</td><td>0.001684</td><td>NaN</td><td>9.445412</td><td>9.445412</td><td>9.445408</td><td>-1.00</td><td>NaN</td><td>12651.124023</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>000411.SZ</td><td>0.021073</td><td>NaN</td><td>5.971262</td><td>5.971262</td><td>5.971313</td><td>0.38</td><td>NaN</td><td>392.124298</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>000979.SZ</td><td>0.021207</td><td>NaN</td><td>6.768918</td><td>6.768918</td><td>6.768815</td><td>-1.45</td><td>NaN</td><td>870.587585</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>000498.SZ</td><td>0.030220</td><td>NaN</td><td>8.852752</td><td>8.852752</td><td>8.852755</td><td>0.55</td><td>NaN</td><td>6994.011719</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>600631.SH</td><td>0.015699</td><td>NaN</td><td>9.589897</td><td>9.589897</td><td>9.589889</td><td>-1.70</td><td>NaN</td><td>14616.806641</td><td>&mldr;</td></tr></tbody></table><h4 id=425-清洗后的因子数据>4.2.5 清洗后的因子数据<a hidden class=anchor aria-hidden=true href=#425-清洗后的因子数据>#</a></h4><table><thead><tr><th>sec_code</th><th>trade_date</th><th>ret</th><th>factor_0</th><th>factor_1</th><th>factor_2</th><th>factor_3</th><th>factor_4</th><th>factor_5</th><th>factor_6</th><th>&mldr;</th></tr></thead><tbody><tr><td>000001.SZ</td><td>2005-01-04</td><td>-1.58653</td><td>0.01545</td><td>1.38306</td><td>1.38306</td><td>1.38306</td><td>0.13392</td><td>0.01545</td><td>1.38564</td><td>&mldr;</td></tr><tr><td>000002.SZ</td><td>2005-01-04</td><td>1.36761</td><td>-0.44814</td><td>1.69728</td><td>1.69728</td><td>1.69728</td><td>1.04567</td><td>-0.44814</td><td>1.69728</td><td>&mldr;</td></tr><tr><td>000004.SZ</td><td>2005-01-04</td><td>0.32966</td><td>-1.41654</td><td>-0.13907</td><td>-0.13907</td><td>-0.13907</td><td>-0.34769</td><td>-1.41654</td><td>-0.13650</td><td>&mldr;</td></tr><tr><td>000005.SZ</td><td>2005-01-04</td><td>0.61297</td><td>-1.13066</td><td>1.05339</td><td>1.05339</td><td>1.05339</td><td>-1.20020</td><td>-1.13066</td><td>1.05597</td><td>&mldr;</td></tr><tr><td>000006.SZ</td><td>2005-01-04</td><td>-0.35542</td><td>1.67667</td><td>-0.07726</td><td>-0.07726</td><td>-0.07726</td><td>1.55820</td><td>1.67667</td><td>-0.07469</td><td>&mldr;</td></tr></tbody></table><h4 id=426-因子数据>4.2.6 因子数据<a hidden class=anchor aria-hidden=true href=#426-因子数据>#</a></h4><ul><li><strong>价量因子构建</strong></li></ul><p>本文使用如下方式构建价量因子，构建价量因子的基础要素有两点：首先是<strong>基础字段</strong>，其次是<strong>算子</strong>。如表4.2.1 所示，基础字段包括日频的最高价（high），最低价（low），开盘价（open），收盘价（close），上一日收盘价（pre_close），成交量（vol），涨跌（pct_chg），换手率（turnover_rate），交易金额（amount），总市值（total_mv）和复权因子（adj_factor）。</p><h4 id=427-基础字段表>4.2.7 基础字段表<a hidden class=anchor aria-hidden=true href=#427-基础字段表>#</a></h4><table><thead><tr><th style=text-align:center>编号</th><th style=text-align:left>字段名</th><th style=text-align:left>意义</th></tr></thead><tbody><tr><td style=text-align:center>high</td><td style=text-align:left>最高价</td><td style=text-align:left>当日成交订单中最高的价格</td></tr><tr><td style=text-align:center>low</td><td style=text-align:left>最低价</td><td style=text-align:left>当日成交订单中最低的价格</td></tr><tr><td style=text-align:center>open</td><td style=text-align:left>开盘价</td><td style=text-align:left>当日集合竞价成交的价格</td></tr><tr><td style=text-align:center>close</td><td style=text-align:left>收盘价</td><td style=text-align:left>当日最后一笔成交订单的价格</td></tr><tr><td style=text-align:center>pre_close</td><td style=text-align:left>上一日收盘价</td><td style=text-align:left>上一日最后一笔成交订单的价格</td></tr><tr><td style=text-align:center>vol</td><td style=text-align:left>成交</td><td style=text-align:left>全天成交的股票数</td></tr><tr><td style=text-align:center>pct_chg</td><td style=text-align:left>涨跌</td><td style=text-align:left>本日证券涨跌</td></tr><tr><td style=text-align:center>turnover_rate</td><td style=text-align:left>换手率</td><td style=text-align:left>本日证券的换手率</td></tr><tr><td style=text-align:center>amount</td><td style=text-align:left>成交金额</td><td style=text-align:left>全天成交的金额</td></tr><tr><td style=text-align:center>total_mv</td><td style=text-align:left>总市值</td><td style=text-align:left>总股本数乘以当时股价得出的股票总价值</td></tr><tr><td style=text-align:center>adj_factor</td><td style=text-align:left>复权因子</td><td style=text-align:left>权息修复比例</td></tr></tbody></table><p>本文通过 <a href=https://github.com/trevorstephens/gplearn>gplearn</a>提供的基础算子集和自己定义的一些特殊算子，得到如表所示的算子列表。</p><h4 id=428-算子列表>4.2.8 算子列表<a hidden class=anchor aria-hidden=true href=#428-算子列表>#</a></h4><table><thead><tr><th style=text-align:left>算子</th><th style=text-align:left>名称</th><th style=text-align:left>定义</th></tr></thead><tbody><tr><td style=text-align:left>add(x, y)</td><td style=text-align:left>和</td><td style=text-align:left>\( x + y\)；点运算</td></tr><tr><td style=text-align:left>\(\operatorname{div}(x, y)\)</td><td style=text-align:left>除</td><td style=text-align:left>\( x / y\)；点运算</td></tr><tr><td style=text-align:left>\(\operatorname{mul}(x, y)\)</td><td style=text-align:left>乘</td><td style=text-align:left>\( x \cdot y\)；点运算</td></tr><tr><td style=text-align:left>\(\operatorname{sub}(x, y)\)</td><td style=text-align:left>减</td><td style=text-align:left>\( x - y\)；点运算</td></tr><tr><td style=text-align:left>neg(x)</td><td style=text-align:left>负</td><td style=text-align:left>\(-x\)；点运算</td></tr><tr><td style=text-align:left>\(\log(x)\)</td><td style=text-align:left>对数</td><td style=text-align:left>\(\log(x)\)；点运算</td></tr><tr><td style=text-align:left>max(x, y)</td><td style=text-align:left>最大值</td><td style=text-align:left>\(x, y\) 中数值较大的数；点运算</td></tr><tr><td style=text-align:left>\(\min(x, y)\)</td><td style=text-align:left>最小值</td><td style=text-align:left>\(x, y\) 中数值较小的数；点运算</td></tr><tr><td style=text-align:left>delta_d(x)</td><td style=text-align:left>d 日差值</td><td style=text-align:left>当日的 \(x\) 值减去 d 日前的 \(x\) 值；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>delay_d(x)</td><td style=text-align:left>d 日延时</td><td style=text-align:left>d 日前的 \(x\) 值；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>Corr_d(x, y)</td><td style=text-align:left>d 日相关性</td><td style=text-align:left>d 日 \(x\) 值和 d 日 \(y\) 值的相关性；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>Max_d(x)</td><td style=text-align:left>d 日最大值</td><td style=text-align:left>d 日 \(x\) 值的最大值；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>Min_d(x)</td><td style=text-align:left>d 日最小值</td><td style=text-align:left>d 日 \(x\) 值的最小值；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>sort_d(x)</td><td style=text-align:left>d 日排序位置</td><td style=text-align:left>d 日 \(x\) 值的排序值；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>Argsortmin_d(x)</td><td style=text-align:left>d 日最小值位置</td><td style=text-align:left>d 日 \(x\) 值的最小值的位置；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>Argsortmax_d(x)</td><td style=text-align:left>d 日最大值位置</td><td style=text-align:left>d 日 \(x\) 值的最大值的位置；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>\(\operatorname{inv}(x)\)</td><td style=text-align:left>倒数</td><td style=text-align:left>\( 1 / x\)；点运算</td></tr><tr><td style=text-align:left>Std_d(x)</td><td style=text-align:left>d 日方差</td><td style=text-align:left>d 日 \(x\) 值的方差；<strong>时序运算</strong></td></tr><tr><td style=text-align:left>abs(x)</td><td style=text-align:left>绝对值</td><td style=text-align:left>\(\lvert x\rvert\)；点运算</td></tr></tbody></table><h4 id=429-遗传规划>4.2.9 遗传规划<a hidden class=anchor aria-hidden=true href=#429-遗传规划>#</a></h4><p><strong>遗传规划（Genetic Programming, GP）<strong>的核心思想是使用进化算法在算子（operators）与基础字段（terminals）组合而成的巨大搜索空间中，自动“进化”出具有较强预测能力的因子表达式。对于本文中的因子挖掘来说，GP 的主要目标是从表4.2.7中的</strong>基础字段</strong>和表4.2.8中的<strong>算子</strong>所能组合成的所有可能表达式中，<strong>搜索</strong>并找到那些能对下一期股票收益有较好预测效果的因子。GP 的核心流程可分为以下几个步骤：</p><h5 id=初始化initialization>初始化（Initialization）<a hidden class=anchor aria-hidden=true href=#初始化initialization>#</a></h5><ol><li><p><strong>定义算子集与基础字段</strong></p><ul><li>算子集（operators）如表4.2.8所示，包括加、减、乘、除、对数、绝对值、延时、移动最大/最小值、移动相关系数等运算。</li><li>基础字段（terminals）如表4.2.7所示，包括开盘价、收盘价、最高价、最低价、成交量、复权因子等。<br>这些算子和基础字段可以视作因子表达式树中的“节点”，其中基础字段为叶子节点（终端节点），算子为内部节点。</li></ul></li><li><p><strong>随机生成初始种群</strong></p><ul><li>在初始化阶段，根据给定的算子集与字段集，随机“拼接”生成一系列因子表达式（可表示为若干语法树或表达式树），形成初始种群。</li><li>例如，可能随机产生<br>\[
\text{因子1}: \mathrm{Max\_5}\bigl(\mathrm{add}(\mathrm{vol}, \mathrm{close})\bigr), \quad
\text{因子2}: \mathrm{sub}\bigl(\mathrm{adj\_factor}, \mathrm{neg}(\mathrm{turnover\_rate})\bigr),
\dots
\]</li><li>每个因子表达式都将对应一个个体（individual）。</li></ul></li></ol><h5 id=适应度函数fitness-function>适应度函数（Fitness Function）<a hidden class=anchor aria-hidden=true href=#适应度函数fitness-function>#</a></h5><ol><li><p><strong>度量因子的预测能力</strong></p><ul><li>针对每个表达式（个体），我们需要评估它对未来收益或其他目标的预测能力。具体来说，可以在<strong>下一期股票收益</strong> \( r^{T+1} \) 与当前期因子暴露度 \( x_k^T \) 之间，计算其<strong>相关系数</strong>（IC）或更综合的指标 IR（Information Ratio）来衡量。</li></ul></li><li><p><strong>设定目标</strong></p><ul><li>若我们希望因子具有更高的相关性（IC），则可令适应度函数为 \(\lvert \rho(x_k^T, r^{T+1})\rvert\)；</li><li>若我们希望因子的 IR 更高，则可设定适应度函数为 IR 值。</li><li>因子 IC 或 IR 越高，该表达式的“适应度”就越高。</li></ul></li></ol><p>因此，我们通常令：</p>\[
\text{Fitness} \bigl(F(x)\bigr) \;=\;
\begin{cases}
\lvert \rho(x_k^T, r^{T+1})\rvert \quad &\text{(IC最大化)},\\[6pt]
\mathrm{IR}(x_k^T) \quad &\text{(IR最大化)}.
\end{cases}
\]<p>其中 \(\rho(\cdot)\) 表示相关系数，\(\mathrm{IR}(\cdot)\) 为 IR 指标。</p><h5 id=选择selection交叉crossover与变异mutation>选择（Selection）、交叉（Crossover）与变异（Mutation）<a hidden class=anchor aria-hidden=true href=#选择selection交叉crossover与变异mutation>#</a></h5><ol><li><p><strong>选择（Selection）</strong></p><ul><li>根据适应度函数的结果，将因子适应度高的表达式“保留”或“繁衍”，适应度较低的表达式则被淘汰。</li><li>这类似于生物进化中的“优胜劣汰”。</li></ul></li><li><p><strong>交叉（Crossover）</strong></p><ul><li>将若干适应度较高的表达式（父本）随机选取一部分“节点”进行交换，从而得到新的表达式（子本）。</li><li>在表达式树结构中，可以将子树 A 与子树 B 互换，从而产生新的后代表达式。</li><li>例如，若表达式树 \(\mathrm{FactorA}\) 的某个子树与表达式树 \(\mathrm{FactorB}\) 的对应子树相交换，就生成了两个新的表达式。</li></ul></li><li><p><strong>变异（Mutation）</strong></p><ul><li>以一定概率对表达式的某些节点进行随机变更，比如：<ul><li>更换节点的算子（例如将 \(\mathrm{add}\) 换为 \(\mathrm{sub}\)），</li><li>替换终端节点的基础字段（例如将 \(\mathrm{vol}\) 换为 \(\mathrm{close}\)），</li><li>或随机改变运算参数（如移动窗口长度、平滑因子等）。</li></ul></li><li>变异可以增加群体的多样性，避免过早收敛或陷入局部最优。</li></ul></li></ol><h5 id=迭代进化iteration>迭代进化（Iteration）<a hidden class=anchor aria-hidden=true href=#迭代进化iteration>#</a></h5><ol><li><p><strong>循环执行</strong></p><ul><li>将选择、交叉、变异的操作反复执行多代（generations）。</li><li>每一代都产生一个新的因子表达式种群，并对其进行适应度评估。</li></ul></li><li><p><strong>收敛与终止</strong></p><ul><li>当进化达到预先设定的停止条件（如迭代次数、适应度阈值等）时，算法终止。</li><li>通常我们会选出<strong>若干个</strong>最终适应度较高的因子表达式，将它们视为进化结果。</li></ul></li></ol><h5 id=数学表征搜索最优因子表达式>数学表征：搜索最优因子表达式<a hidden class=anchor aria-hidden=true href=#数学表征搜索最优因子表达式>#</a></h5><p>将上述过程抽象成下式，可以简单表示因子的搜索目标：</p>\[
F(x) \;=\; \mathrm{GP}\bigl(\{\text{operators}\}, \{\text{terminals}\}\bigr),
\]<p>表示通过 GP 算法在给定算子集（operators）和基础字段集（terminals）上搜索出一个函数 \(F(x)\)。从最优化的角度看，我们希望找到：</p>\[
\max_{F} \bigl\lvert \rho(F^T, r^{T+1}) \bigr\rvert
\quad \text{或者} \quad
\max_{F} \; \mathrm{IR}\bigl(F\bigr),
\]<p>其中</p><ul><li>\(\rho(\cdot)\) 表示因子与下一期收益的相关系数（IC），</li><li>\(\mathrm{IR}(\cdot)\) 表示该因子的 IR 指标。</li></ul><p>在实际应用中，我们会给定一段回测期，对每一代的候选因子进行打分（IC/IR 评估），通过选择、交叉和变异的迭代过程不断“进化”出更优质的因子。</p><p><strong>通过以上步骤，我们最终能够在庞大的算子组合与基础字段组合的搜索空间中，自动挖掘到一批对未来收益有较强预测能力、且具有较好稳健性（如 IR 较高）的因子表达式。</strong></p><h4 id=4210-挖掘出的部分因子>4.2.10 挖掘出的部分因子<a hidden class=anchor aria-hidden=true href=#4210-挖掘出的部分因子>#</a></h4><table><thead><tr><th style=text-align:left>因子名</th><th style=text-align:center>定义</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:center>Max＿25(add(turnover_rate, vol))</td></tr><tr><td style=text-align:left>1</td><td style=text-align:center>Max＿30(vol)</td></tr><tr><td style=text-align:left>2</td><td style=text-align:center>Max＿25(turnover_rate)</td></tr><tr><td style=text-align:left>3</td><td style=text-align:center>Max＿35(add(vol, close))</td></tr><tr><td style=text-align:left>4</td><td style=text-align:center>Max＿30(turnover_rate)</td></tr><tr><td style=text-align:left>5</td><td style=text-align:center>sub(Min＿20(neg(pre_close)), div(vol, adj_factor))</td></tr><tr><td style=text-align:left>6</td><td style=text-align:center>Max＿60(max(vol, adj_factor))</td></tr><tr><td style=text-align:left>7</td><td style=text-align:center>Max＿50(amount)</td></tr><tr><td style=text-align:left>8</td><td style=text-align:center>div(vol, neg(close))</td></tr><tr><td style=text-align:left>9</td><td style=text-align:center>min(ArgSortMin＿25(pre_close), neg(vol))</td></tr><tr><td style=text-align:left>10</td><td style=text-align:center>neg(max(vol, turnover_rate))</td></tr><tr><td style=text-align:left>11</td><td style=text-align:center>mul(amount, neg(turnover_rate))</td></tr><tr><td style=text-align:left>12</td><td style=text-align:center>inv(add(ArgSortMax＿40(change), inv(pct_chg)))</td></tr><tr><td style=text-align:left>13</td><td style=text-align:center>Std＿40(inv(abs(sub(mul(total_mv, change), min(adj_factor, high))))</td></tr><tr><td style=text-align:left>14</td><td style=text-align:center>div(log(total_mv),amount)</td></tr><tr><td style=text-align:left>15</td><td style=text-align:center>div(neg(Max＿5(amount)), Min＿20(ArgSort＿60(high)))</td></tr><tr><td style=text-align:left>16</td><td style=text-align:center>Corr＿30(inv(abs(sub(mul(total_mv, change), min(adj_factor, high)))), add(log(Max＿10(pre_close)), high))</td></tr><tr><td style=text-align:left>17</td><td style=text-align:center>ArgSort＿60(neg(turnover_rate))</td></tr><tr><td style=text-align:left>&mldr;</td><td style=text-align:center>&mldr;</td></tr></tbody></table><p>这些因子均是通过遗传规划从算子列表（表4.2.8）与基础字段列表（表4.2.7）中组合而得，具有不同的数学表达形式。</p><ul><li><strong>因子有效性检验</strong></li></ul><p>当我们得到挖掘的因子之后，需要对因子进行有效性检验，常见的检验指标有<strong>信息系数（Information Coefficient，IC）<strong>和</strong>信息比率（Information Ratio，IR）</strong>。</p><ul><li><strong>信息系数（IC）<strong>描述的是所选股票</strong>下期收益率</strong>和本期因子暴露度的<strong>线性相关程度</strong>，可以反应该因子进行收益率预测的稳健性</li><li>**信息比率（IR）**是超额收益的均值与超额收益的标准差之比，信息比率与夏普比率类似，主要区别在于夏普比率使用无风险收益作为基准，而信息比率使用风险指数作为基准。夏普比率有助于确定投资组合的绝对收益，信息比率有助于确定投资组合的相对收益。当我们计算了 IC 之后，可以根据 IC 的值再对 IR 进行计算。当 IR 大于 0.5 时，因子稳定获取超额收益能力较强。</li></ul><p>实际计算中，因子 \(k\) 的 \( \mathrm{IC} \) 值一般是指所选股票第 \(T\) 期的因子 \(k\) 上的暴露度 \( x_k^T \) 与所选股票第 \(T+1\) 期的收益率 \( r^{T+1} \) 的相关系数；因子 \(k\) 的 \( \mathrm{IR} \) 值为因子 \(k\) 的 \( \mathrm{IC} \) 的均值除以因子 \(k\) 的 \( \mathrm{IC} \) 的标准差，计算公式如下：</p>$$
\begin{gathered}
I C=\rho_{x_{k}^{T}, r^{T+1}}=\frac{\operatorname{cov}\left(x_{k}^{T}, r^{T+1}\right)}{\sigma_{x_{k}^{T}} \sigma_{r^{T+1}}}=\frac{\mathrm{E}\left(x_{k}^{T} * r^{T+1}\right)-\mathrm{E}\left(x_{k}^{T}\right) \mathrm{E}\left(r^{T+1}\right)}{\sqrt{\mathrm{E}\left(\left(x_{k}^{T}\right)^{2}\right)-\mathrm{E}\left(x_{k}^{T}\right)^{2}} \cdot \sqrt{\mathrm{E}\left(\left(r^{T+1}\right)^{2}\right)-\mathrm{E}\left(r^{T+1}\right)^{2}}} \\
I R=\frac{\overline{I C}}{\sigma_{I C}}
\end{gathered}
$$<p>其中：</p><ul><li>$x_{k}^{T}$ ：所选股票第 $T$ 期的因子 $k$ 上的暴露度</li><li>$r^{T+1}$ ：所选股票第 $T+1$ 期的收益率</li><li>$\overline{I C}: I C$ 的均值</li></ul><p>本文采用 IR 判断因子好坏，通过对大量不同的算子和基础数据的组合以及 IC 和 IR 的“篮选”，文章得到了本文所选用的 50 个价量因子。经过 IR 检测，按 IR 由高到低排序得到如下图所示的表格。从下表中我们可以看出来所选的 50 个价量因子的 IR 都大于 0.5 ，说明这些因子稳定获取超额收益能力较强。</p><h4 id=4211-因子-ir-检验表>4.2.11 因子 IR 检验表<a hidden class=anchor aria-hidden=true href=#4211-因子-ir-检验表>#</a></h4><table><thead><tr><th>因子名</th><th>IR</th><th>因子名</th><th>IR</th></tr></thead><tbody><tr><td>0</td><td>3.11</td><td>25</td><td>2.73</td></tr><tr><td>1</td><td>2.95</td><td>26</td><td>2.71</td></tr><tr><td>2</td><td>2.95</td><td>27</td><td>2.70</td></tr><tr><td>3</td><td>2.95</td><td>28</td><td>2.69</td></tr><tr><td>4</td><td>2.95</td><td>29</td><td>2.69</td></tr><tr><td>5</td><td>2.94</td><td>30</td><td>2.69</td></tr><tr><td>6</td><td>2.94</td><td>31</td><td>2.68</td></tr><tr><td>7</td><td>2.94</td><td>32</td><td>2.68</td></tr><tr><td>8</td><td>2.93</td><td>33</td><td>2.68</td></tr><tr><td>9</td><td>2.93</td><td>34</td><td>2.68</td></tr><tr><td>10</td><td>2.93</td><td>35</td><td>2.67</td></tr><tr><td>11</td><td>2.92</td><td>36</td><td>2.67</td></tr><tr><td>12</td><td>2.91</td><td>37</td><td>2.66</td></tr><tr><td>13</td><td>2.89</td><td>38</td><td>2.65</td></tr><tr><td>14</td><td>2.86</td><td>39</td><td>2.65</td></tr><tr><td>15</td><td>2.83</td><td>40</td><td>2.65</td></tr><tr><td>16</td><td>2.83</td><td>41</td><td>2.65</td></tr><tr><td>17</td><td>2.83</td><td>42</td><td>2.64</td></tr><tr><td>18</td><td>2.79</td><td>43</td><td>2.63</td></tr><tr><td>19</td><td>2.78</td><td>44</td><td>2.63</td></tr><tr><td>20</td><td>2.78</td><td>45</td><td>2.62</td></tr><tr><td>21</td><td>2.76</td><td>46</td><td>2.62</td></tr><tr><td>22</td><td>2.75</td><td>47</td><td>2.62</td></tr></tbody></table><p>从该表可见，在所筛选的因子中，所有因子的 IR 均大于 0.5，具有较强且稳定的获取超额收益的能力。</p><h3 id=43-因子清洗>4.3 因子清洗<a hidden class=anchor aria-hidden=true href=#43-因子清洗>#</a></h3><h4 id=431-因子缺失值处理和去极值>4.3.1 因子缺失值处理和去极值<a hidden class=anchor aria-hidden=true href=#431-因子缺失值处理和去极值>#</a></h4><p>对于因子的缺失值处理的方法有个案剔除法，均值替换法，回归替换法等方法。本文采用较为简单的均值替换法对缺损值进行处理，即利用因子的平均值来替代缺失的数据。对于因子去极值有中位数去极值，百分比去极值和 $3 \sigma$ 去极值等方法。本文采用的是 $3 \sigma$ 去极值法，该方法是利用统计学上的 $3 \sigma$ 原则，将把离该因子均值三个标准差以上的极值因子转化到刚好离均值三个标准差的位置，具体计算公式如下：</p>$$
X_i^{\prime}= \begin{cases} \bar{X}+3 \sigma & \text{if } X_i > \bar{X} + 3 \sigma \\ \bar{X}-3 \sigma & \text{if } X_i < \bar{X} - 3 \sigma \\ X_i & \text{if } \bar{X} - 3 \sigma < X_i < \bar{X} + 3 \sigma \end{cases}
$$<p>其中：</p><ul><li>$X_{i}$ ：因子处理之前的值</li><li>$\bar{X}$ ：因子序列的均值</li><li>$\sigma$ ：因子序列的标准差</li><li>$X_{i}^{\prime}$ ：去极值后的因子的值</li></ul><h4 id=432-因子的标准化>4.3.2 因子的标准化<a hidden class=anchor aria-hidden=true href=#432-因子的标准化>#</a></h4><p>本文实验选取了多个因子，并且各个因子量纲并不完全相同，为了我们方便进行比较和回归，我们还需对因子进行标准化处理。目前常用的具体的标准化方法有 Min－Max标准化，Z－score 标准化和 Decimal scaling 小数定标标准化等。本文选择 Z－score 标准化的方法。通过原始数据的均值和标准差进行数据的标准化，经过处理的数据符合标准正态分布，即均值为 0 ，标准差为 1 ，其标准化后的数值大小有正有负，得到标准正态分布曲线。</p><p>本文采用 Z－score 标准化公式如下：</p>$$
\tilde{x}=\frac{x_{i}-u}{\sigma}
$$<p>其中：</p><ul><li>$x_{i}$ ：因子的原值</li><li>$u$ ：因子序列的均值</li><li>$\sigma$ ：因子序列的标准差</li><li>$\tilde{x}$ ：标准化后的因子值</li></ul><h4 id=433-因子的中性化>4.3.3 因子的中性化<a hidden class=anchor aria-hidden=true href=#433-因子的中性化>#</a></h4><p>因子中性化是为了剔除其他因素对我们所选因子的影响，使我们构建量化投资策略组合所选择的股票更加分散，而不是集中在特定的行业或者市值的股票上，可以更好地分担投资组合的风险和解决因子多重共线性的问题。市值和行业是影响股票收益最主要的两种自变量，所以在进行因子清洗的过程中，还必须考虑市值和行业的影响。本文实证中我们采用仅纳入行业因子，而将市场因子包含在行业因子中的方法。针对因子的单因子回归模型见公式(31)，我们将以下回归模型的残差项作为因子中性化后的新的因子值。</p>$$
\tilde{r}_{j}^{t}=\sum_{s=1}^{s} X_{j s}^{t} \tilde{f}_{s}^{t}+X_{j k}^{t} \tilde{f}_{k}^{t}+\tilde{u}_{j}^{t}
$$<p>其中：</p><ul><li>$\tilde{r}_{j}^{t}$ ：股票 $j$ 在第 $t$ 期的收益率</li><li>$X_{j s}^{t}$ ：股票 $j$ 在第 $t$ 期在行业 $s$ 上的暴露度</li><li>$\tilde{f}_{s}^{t}$ ：行业在第 $t$ 期的收益率</li><li>$X_{j k}^{t}$ ：股票 $j$ 在第 $t$ 期在因子 $k$ 上的暴露度</li><li>$\tilde{f}_{k}^{t}$ ：因子 $k$ 在第 $t$ 期的收益率</li><li>$\tilde{u}_j^t$ ：一个 $0-1$ 哑变量，即如果股票 $j$ 属于行业 $s$ ，则暴露度为 1 ，否则为 0</li></ul><p>在本文中，并不会对公司所属行业进行按照比例拆分，即股票 $j$ 只能属于一个特定的行业 $s$ ，在行业 $s$ 上的暴露度为 1 ，在其他所有行业的暴露度为 0 。本文使用申万宏源行业分类标准，具体分类情况依次为农林牧渔，采掘，化工，钢铁，有色金属，电子元器件，家用电器，食品饮料，纺织服装，轻工制造，医药生物，公用事业，交通运输，房地产，商业贸易，餐饮旅游，综合，建筑材料，建筑装饰，电器设备，国防军工，计算机，传媒，通信，银行，非银金融，汽车和机械设备这 28 类。下表为 2021 年 2 月 5 日的申万指数一级行业历史行情图。</p><h5 id=4331-2021年2月5日的申万指数一级行业历史行情图>4.3.3.1 2021年2月5日的申万指数一级行业历史行情图<a hidden class=anchor aria-hidden=true href=#4331-2021年2月5日的申万指数一级行业历史行情图>#</a></h5><table><thead><tr><th>指数代码</th><th>指数名称</th><th>发布日期</th><th>开盘指数</th><th>最高指数</th><th>最低指数</th><th>收盘指数</th><th>成交量(亿殴)</th><th>成交额(亿元)</th><th>涨跌幅(%)</th></tr></thead><tbody><tr><td>801010</td><td>农林牧渔</td><td>2021/2/5 0:00</td><td>4111.43</td><td>4271.09</td><td>4072.53</td><td>4081.81</td><td>15.81</td><td>307.82</td><td>-0.3</td></tr><tr><td>801020</td><td>采掘</td><td>2021/2/5 0:00</td><td>2344.62</td><td>2357.33</td><td>2288.97</td><td>2289.41</td><td>18.06</td><td>115.6</td><td>-2.25</td></tr><tr><td>801030</td><td>化工</td><td>2021/2/5 0:00</td><td>4087.77</td><td>4097.59</td><td>3910.67</td><td>3910.67</td><td>55.78</td><td>778.85</td><td>-3.95</td></tr><tr><td>801040</td><td>钢铁</td><td>2021/2/5 0:00</td><td>2253.78</td><td>2268.17</td><td>2243.48</td><td>2250.81</td><td>11.61</td><td>48.39</td><td>-1.02</td></tr><tr><td>801050</td><td>有色金属</td><td>2021/2/5 0:00</td><td>4212.1</td><td>4250.59</td><td>4035.99</td><td>4036.74</td><td>45.41</td><td>593.92</td><td>-4.43</td></tr><tr><td>801080</td><td>电子元器件</td><td>2021/2/5 0:00</td><td>4694.8</td><td>4694.8</td><td>4561.95</td><td>4561.95</td><td>52.67</td><td>850.79</td><td>-2.78</td></tr><tr><td>801110</td><td>家用电器</td><td>2021/2/5 0:00</td><td>10033.82</td><td>10171.26</td><td>9968.93</td><td>10096.83</td><td>8.55</td><td>149.18</td><td>0.83</td></tr><tr><td>801120</td><td>食品饮料</td><td>2021/2/5 0:00</td><td>30876.33</td><td>31545.02</td><td>30649.57</td><td>30931.69</td><td>11.32</td><td>657.11</td><td>0.47</td></tr><tr><td>801130</td><td>纺织服装</td><td>2021/2/5 0:00</td><td>1614.48</td><td>1633.89</td><td>1604.68</td><td>1607.63</td><td>6.28</td><td>57.47</td><td>-0.39</td></tr><tr><td>801140</td><td>轻工制造</td><td>2021/2/5 0:00</td><td>2782.07</td><td>2791.88</td><td>2735.48</td><td>2737.24</td><td>15.28</td><td>176.16</td><td>-1.35</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><p><strong>数据来源</strong>：申银万国</p><p>下表是原始的因子部分数据。依次经过上述因子缺失值填充、因子去极值、因子标准化和因子中性化这 4 个因子清洗的步骤后，得到如表展示的经过因子清洗后的因子部分数据。</p><h5 id=4332-原始的因子数据>4.3.3.2 原始的因子数据<a hidden class=anchor aria-hidden=true href=#4332-原始的因子数据>#</a></h5><table><thead><tr><th>trade_date</th><th>sec_code</th><th>ret</th><th>factor_0</th><th>factor_1</th><th>factor_2</th><th>factor_3</th><th>factor_4</th><th>factor_5</th><th>factor_6</th><th>&mldr;</th></tr></thead><tbody><tr><td>2005-01-04</td><td>600874.SH</td><td>0.001684</td><td>NaN</td><td>9.445412</td><td>9.445412</td><td>9.445408</td><td>-1.00</td><td>NaN</td><td>12651.124023</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>000411.SZ</td><td>0.021073</td><td>NaN</td><td>5.971262</td><td>5.971262</td><td>5.971313</td><td>0.38</td><td>NaN</td><td>392.124298</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>000979.SZ</td><td>0.021207</td><td>NaN</td><td>6.768918</td><td>6.768918</td><td>6.768815</td><td>-1.45</td><td>NaN</td><td>870.587585</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>000498.SZ</td><td>0.030220</td><td>NaN</td><td>8.852752</td><td>8.852752</td><td>8.852755</td><td>0.55</td><td>NaN</td><td>6994.011719</td><td>&mldr;</td></tr><tr><td>2005-01-04</td><td>600631.SH</td><td>0.015699</td><td>NaN</td><td>9.589897</td><td>9.589897</td><td>9.589889</td><td>-1.70</td><td>NaN</td><td>14616.806641</td><td>&mldr;</td></tr></tbody></table><h5 id=4333-清洗后的因子数据>4.3.3.3 清洗后的因子数据<a hidden class=anchor aria-hidden=true href=#4333-清洗后的因子数据>#</a></h5><table><thead><tr><th>sec_code</th><th>trade_date</th><th>ret</th><th>factor_0</th><th>factor_1</th><th>factor_2</th><th>factor_3</th><th>factor_4</th><th>factor_5</th><th>factor_6</th><th>&mldr;</th></tr></thead><tbody><tr><td>000001.SZ</td><td>2005-01-04</td><td>-1.58653</td><td>0.01545</td><td>1.38306</td><td>1.38306</td><td>1.38306</td><td>0.13392</td><td>0.01545</td><td>1.38564</td><td>&mldr;</td></tr><tr><td>000002.SZ</td><td>2005-01-04</td><td>1.36761</td><td>-0.44814</td><td>1.69728</td><td>1.69728</td><td>1.69728</td><td>1.04567</td><td>-0.44814</td><td>1.69728</td><td>&mldr;</td></tr><tr><td>000004.SZ</td><td>2005-01-04</td><td>0.32966</td><td>-1.41654</td><td>-0.13907</td><td>-0.13907</td><td>-0.13907</td><td>-0.34769</td><td>-1.41654</td><td>-0.13650</td><td>&mldr;</td></tr><tr><td>000005.SZ</td><td>2005-01-04</td><td>0.61297</td><td>-1.13066</td><td>1.05339</td><td>1.05339</td><td>1.05339</td><td>-1.20020</td><td>-1.13066</td><td>1.05597</td><td>&mldr;</td></tr><tr><td>000006.SZ</td><td>2005-01-04</td><td>-0.35542</td><td>1.67667</td><td>-0.07726</td><td>-0.07726</td><td>-0.07726</td><td>1.55820</td><td>1.67667</td><td>-0.07469</td><td>&mldr;</td></tr></tbody></table><h3 id=44-基于-lightgbm-的因子选择>4.4 基于 LightGBM 的因子选择<a hidden class=anchor aria-hidden=true href=#44-基于-lightgbm-的因子选择>#</a></h3><h4 id=441-gbdt>4.4.1 GBDT<a hidden class=anchor aria-hidden=true href=#441-gbdt>#</a></h4><p><a href=https://www.jstor.org/stable/2699986>Friedman（2001）</a>$^{[20]}$ 提出的梯度提升决策树（Gradient Boosting Decision Tree，GBDT）是一种基于迭代的回归型决策树。其主要思想是通过逐步添加弱分类器（通常是决策树）来优化模型，使得整体模型能够最小化损失函数。GBDT 的模型可以表示为：</p>$$
\hat{y} = \sum_{m=1}^{M} \gamma_m h_m(\mathbf{x})
$$<p>其中：</p><ul><li>\( M \) 是迭代次数，</li><li>\( \gamma_m \) 是第 \( m \) 个弱分类器的权重，</li><li>\( h_m(\mathbf{x}) \) 是第 \( m \) 个决策树模型。</li></ul><p>GBDT 的训练过程通过逐步拟合负梯度方向来最小化损失函数，具体更新公式为：</p>$$
\gamma_m = \arg\min_\gamma \sum_{i=1}^{N} L\left(y_i, \hat{y}_{i}^{(m-1)} + \gamma h_m(\mathbf{x}_i)\right)
$$<p>其中，\( L \) 是损失函数，\( y_i \) 是真实值，\( \hat{y}_{i}^{(m-1)} \) 是第 \( m-1 \) 次迭代后的预测值。</p><h4 id=442-lightgbm>4.4.2 LightGBM<a hidden class=anchor aria-hidden=true href=#442-lightgbm>#</a></h4><p><a href=https://proceedings.neurips.cc/paper_files/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf>轻量级梯度提升机（Light Gradient Boosting Machine，LightGBM)</a>$^{[21]}$ 是一个高效实现 GBDT 算法的框架，最初由 Microsoft 开发，作为一个免费开源的分布式梯度提升框架。LightGBM 基于决策树算法，广泛应用于排名、分类及其他机器学习任务，开发重点在于性能和可伸缩性。其主要优势包括高效率的并行训练、更快的训练速度、更低的内存消耗、更好的准确率，以及支持分布式计算和快速处理海量数据$^{[22]}$。</p><p>LightGBM 的核心算法基于以下优化目标：</p>$$
L = \sum_{i=1}^{N} l(y_i, \hat{y}_i) + \sum_{m=1}^{M} \Omega(h_m)
$$<p>其中，\( l \) 是损失函数，\( \Omega \) 是正则化项，用于控制模型复杂度，通常表示为：</p>$$
\Omega(h_m) = \gamma T + \frac{1}{2} \lambda \sum_{j=1}^{T} w_j^2
$$<p>这里，\( T \) 是树的叶子数，\( w_j \) 是第 \( j \) 个叶子的权重，\( \gamma \) 和 \( \lambda \) 是正则化参数。</p><p>LightGBM 采用基于梯度的单边采样（Gradient-based One-Side Sampling，GOSS）和互斥特征捆绑（Exclusive Feature Bundling，EFB）等技术，显著提升了训练效率和模型性能。</p><p>在本研究中，训练过程中使用的损失函数为均方误差（Mean Squared Error，MSE），其定义为：</p>$$
L(y, \hat{y}) = \frac{1}{N} \sum_{i=1}^{N} (y_i - \hat{y}_i)^2
$$<p>其中，\( y \) 为真实收益率，\( \hat{y} \) 为模型预测的收益率，\( N \) 为样本数量。</p><h4 id=443-算法流程>4.4.3 算法流程<a hidden class=anchor aria-hidden=true href=#443-算法流程>#</a></h4><p>本小节算法的具体流程如下：</p><ol><li><p><strong>数据准备</strong>：使用一年的每只股票的 50 个因子数据（A 股全市场数据）和历史未来一个月的收益率作为特征。</p></li><li><p><strong>模型训练</strong>：利用网格搜索法（Grid Search）优化 LightGBM 模型的超参数，训练模型以预测未来一个月的收益率。模型训练流程如图4.12所示。</p>$$
\text{参数优化：} \quad \theta^* = \arg\min_\theta \sum_{i=1}^{N} L(y_i, \hat{y}_i(\theta))
$$<p>其中，\( \theta \) 表示模型的超参数集合，\( \theta^* \) 为最优参数。</p></li><li><p><strong>因子重要性计算</strong>：使用 LightGBM 的 <code>feature_importances_</code> 方法计算各因子的特征重要性。特征重要性主要通过两个指标衡量：</p><ul><li><strong>Split</strong>：该特征在所有树中被用于分裂的次数。</li><li><strong>Gain</strong>：该特征在所有分裂中带来的总增益（即损失函数的减少量）。</li></ul><p>因子的特征重要性可以表示为：</p>$$
\text{Importance}_{\text{split}}(f) = \sum_{m=1}^{M} \sum_{j=1}^{T_m} \mathbb{I}(f \text{ 被用于第 } j \text{ 个叶节点的分裂})
$$$$
\text{Importance}_{\text{gain}}(f) = \sum_{m=1}^{M} \sum_{j=1}^{T_m} \Delta L_{m,j} \cdot \mathbb{I}(f \text{ 被用于第 } j \text{ 个叶节点的分裂})
$$<p>其中，\( \mathbb{I} \) 是指示函数，\( \Delta L_{m,j} \) 是因子 \( f \) 在第 \( m \) 棵树的第 \( j \) 个分裂中带来的损失减少量。</p></li><li><p><strong>因子筛选</strong>：根据模型计算的因子重要性进行排序，选择前十个重要性最高的因子作为本横截面分析中使用的因子。所选因子的重要性如表4.4.4所示。</p></li></ol><h4 id=444-部分所选因子重要性排序>4.4.4 部分所选因子重要性排序<a hidden class=anchor aria-hidden=true href=#444-部分所选因子重要性排序>#</a></h4><table><thead><tr><th>importance</th><th>feature_name</th><th>trade_date</th></tr></thead><tbody><tr><td>35</td><td>factor_35</td><td>2010-08-11</td></tr><tr><td>27</td><td>factor_27</td><td>2010-08-11</td></tr><tr><td>33</td><td>factor_33</td><td>2010-08-11</td></tr><tr><td>20</td><td>factor_20</td><td>2010-08-11</td></tr><tr><td>24</td><td>factor_24</td><td>2010-08-11</td></tr><tr><td>45</td><td>factor_45</td><td>2010-08-11</td></tr><tr><td>37</td><td>factor_37</td><td>2010-08-11</td></tr><tr><td>49</td><td>factor_49</td><td>2010-08-11</td></tr><tr><td>19</td><td>factor_19</td><td>2010-08-11</td></tr><tr><td>47</td><td>factor_47</td><td>2010-08-11</td></tr><tr><td>22</td><td>factor_22</td><td>2010-09-09</td></tr><tr><td>20</td><td>factor_20</td><td>2010-09-09</td></tr><tr><td>30</td><td>factor_30</td><td>2010-09-09</td></tr><tr><td>24</td><td>factor_24</td><td>2010-09-09</td></tr></tbody></table><h4 id=445-代码实现片段>4.4.5 代码实现片段<a hidden class=anchor aria-hidden=true href=#445-代码实现片段>#</a></h4><p>以下是训练过程所使用的部分代码，用于因子选择。</p><p><details><summary markdown=span>feature_choice</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>feature_choice</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>days</span><span class=o>=</span><span class=mi>21</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>is_local</span><span class=o>=</span><span class=kc>False</span>
</span></span><span class=line><span class=cl><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>is_local</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>feature_info</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_hdf</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>RESULTS</span><span class=p>,</span> <span class=n>Feature_Info</span> <span class=o>+</span> <span class=s1>&#39;.h5&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>factors</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>get_env</span><span class=p>()</span><span class=o>.</span><span class=n>query_data</span><span class=p>(</span><span class=n>Factors_Data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>factors</span> <span class=o>=</span> <span class=n>factors</span><span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>factors</span><span class=p>[</span><span class=n>COM_DATE</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=s1>&#39;2010-01-01&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>trade_list</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>set</span><span class=p>(</span><span class=n>factors</span><span class=p>[</span><span class=n>COM_DATE</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>        <span class=n>trade_list</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>trade_list</span><span class=p>)</span> <span class=o>%</span> <span class=n>days</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>n</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>trade_list</span><span class=p>)</span> <span class=o>/</span> <span class=n>days</span><span class=p>)</span> <span class=o>-</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>n</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>trade_list</span><span class=p>)</span> <span class=o>/</span> <span class=n>days</span><span class=p>)</span> <span class=o>-</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl>        <span class=n>feature_info</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>begin_index</span> <span class=o>=</span> <span class=mi>147</span>
</span></span><span class=line><span class=cl>        <span class=n>feature</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>factors</span><span class=o>.</span><span class=n>columns</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>feature</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>COM_SEC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>feature</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>COM_DATE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>feature</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>Ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>end_date</span> <span class=o>=</span> <span class=n>days</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=n>begin_index</span> <span class=o>-</span> <span class=mi>21</span>
</span></span><span class=line><span class=cl>            <span class=n>begin_date</span> <span class=o>=</span> <span class=n>days</span> <span class=o>*</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=n>trade_date</span> <span class=o>=</span> <span class=n>days</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=n>begin_index</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>trade_list</span><span class=p>[</span><span class=n>trade_date</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>train_data</span> <span class=o>=</span> <span class=n>factors</span><span class=p>[</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>factors</span><span class=p>[</span><span class=n>COM_DATE</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>trade_list</span><span class=p>[</span><span class=n>end_date</span><span class=p>])</span> <span class=o>&amp;</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>factors</span><span class=p>[</span><span class=n>COM_DATE</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>trade_list</span><span class=p>[</span><span class=n>begin_date</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>model</span> <span class=o>=</span> <span class=n>lgb</span><span class=o>.</span><span class=n>LGBMRegressor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>model</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>train_data</span><span class=p>[</span><span class=n>feature</span><span class=p>],</span> <span class=n>train_data</span><span class=p>[</span><span class=n>Ret</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>feature_info_cell</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>columns</span><span class=o>=</span><span class=n>Info_Fields</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>feature_info_cell</span><span class=p>[</span><span class=n>Importance</span><span class=p>]</span> <span class=o>=</span> <span class=n>model</span><span class=o>.</span><span class=n>feature_importances_</span>
</span></span><span class=line><span class=cl>            <span class=n>feature_info_cell</span><span class=p>[</span><span class=n>Feature_Name</span><span class=p>]</span> <span class=o>=</span> <span class=n>model</span><span class=o>.</span><span class=n>feature_name_</span>
</span></span><span class=line><span class=cl>            <span class=n>feature_info_cell</span> <span class=o>=</span> <span class=n>feature_info_cell</span><span class=o>.</span><span class=n>sort_values</span><span class=p>(</span><span class=n>by</span><span class=o>=</span><span class=n>Importance</span><span class=p>)</span><span class=o>.</span><span class=n>tail</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>feature_info_cell</span><span class=p>[</span><span class=n>COM_DATE</span><span class=p>]</span> <span class=o>=</span> <span class=n>trade_list</span><span class=p>[</span><span class=n>trade_date</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>feature_info</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=p>[</span><span class=n>feature_info</span><span class=p>,</span> <span class=n>feature_info_cell</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                <span class=n>axis</span><span class=o>=</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>h</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>HDFStore</span><span class=p>(</span><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>RESULTS</span><span class=p>,</span> <span class=n>Feature_Info</span> <span class=o>+</span> <span class=s1>&#39;.h5&#39;</span><span class=p>),</span> <span class=s1>&#39;w&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>h</span><span class=p>[</span><span class=s1>&#39;data&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>feature_info</span>
</span></span><span class=line><span class=cl>        <span class=n>h</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>get_env</span><span class=p>()</span><span class=o>.</span><span class=n>add_data</span><span class=p>(</span><span class=n>feature_info</span><span class=p>,</span> <span class=n>Feature_Info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div></details></p><p>通过上述流程，利用 LightGBM 高效地筛选出对预测未来收益率最具影响力的因子，从而提升模型的预测能力和解释性。</p><h3 id=45-基于-bilstm-的因子组合>4.5 基于 BiLSTM 的因子组合<a hidden class=anchor aria-hidden=true href=#45-基于-bilstm-的因子组合>#</a></h3><p>本小节使用 BiLSTM 进行因子组合。BiLSTM 的具体原理在第二章已经介绍了，这里不再赘述。下面先介绍一下使用模型的具体网络结构，本文通过大量反复试验最终 BiLSTM 设置的网络结构如表4.5.1所示。其中层与层之间使用循环神经网络默认的 tanh 和 linear 作为激活函数。并且为了防止过拟合加入 Dropout，但是如果 Dropout 使用过大的丢弃比例会出现欠拟合的现象，因此 Dropout 的丢弃比例取值为 0.01。最终模型的 BiLSTM 循环层的神经元个数为 100，采用一层 BiLSTM 层和三层全连接层，其中 BiLSTM 层和第一个全连接层之间设置了一个 Dropout。</p><h4 id=451-bilstm的网络结构>4.5.1 BiLSTM的网络结构<a hidden class=anchor aria-hidden=true href=#451-bilstm的网络结构>#</a></h4><table><thead><tr><th>Layer(type)</th><th>Output Shape</th><th>Param#</th></tr></thead><tbody><tr><td>bidirectional_1 (Bidirection)</td><td>(None, 100)</td><td>24400</td></tr><tr><td>dropout_1 (Dropout)</td><td>(None, 100)</td><td>0</td></tr><tr><td>dense_1 (Dense)</td><td>(None, 256)</td><td>25856</td></tr><tr><td>dropout_2 (Dropout)</td><td>(None, 256)</td><td>0</td></tr><tr><td>dense_2 (Dense)</td><td>(None, 64)</td><td>16448</td></tr><tr><td>dense_3 (Dense)</td><td>(None, 1)</td><td>0</td></tr></tbody></table><p><strong>Total params</strong>：66,769<br><strong>Trainable params</strong>：66,769<br><strong>Non-trainable params</strong>：0</p><p>因为本次实验使用数据的数据量较大，因此选用 <code>epochs=400</code>，<code>batch_size=1024</code>。模型的损失函数采用均方误差（Mean Square Error，MSE）。其中优化器采用随机梯度下降（Stochastic Gradient Descent，SGD）。随机梯度下降相对于梯度下降（Gradient Descent，GD）有在信息冗余的情况下更能有效地利用信息，前期迭代效果卓越，适合处理大样本的数据这三个优势 $^{[23]}$。由于本实验训练数据量较大，使用 SGD 的话每次仅用一个样本来迭代，训练的速度很快，可以大大减少我们训练所花费的时间。使用其 <code>keras</code> 包中的默认值，即 <code>lr=0.01</code>、<code>momentum=0.0</code>、<code>decay=0.0</code> 和 <code>nesterov=False</code>。</p><p><strong>参数解释：</strong></p><ul><li><code>lr</code>：学习率</li><li><code>momentum</code>：动量参数</li><li><code>decay</code>：每次更新后的学习率衰减值</li><li><code>nesterov</code>：确定是否使用 Nesterov 动量</li></ul><h4 id=452-算法流程>4.5.2 算法流程<a hidden class=anchor aria-hidden=true href=#452-算法流程>#</a></h4><p>本小节算法的具体流程如下：</p><ol><li>使用一年的每只股票的 10 个因子（LightGBM 选出来的因子）和历史未来一个月的收益率的 A 股全市场数据作为特征。</li><li>以一年每支股票未来一个月的收益率为预测目标，利用 BiLSTM 进行训练，如 Fig. 12 所示。</li></ol><figure class=align-center><img loading=lazy src=Rolling_Window.png#center alt="Fig. 12. Rolling Window"><figcaption><p>Fig. 12. Rolling Window</p></figcaption></figure><ol start=3><li>一个月的样本外数据的实时因子数据通过训练好的 BiLSTM 模型，得到实时的未来一月的每只股票预期收益率。收益率如表4.11所示。</li></ol><h4 id=453-部分股票预测收益率表>4.5.3 部分股票预测收益率表<a hidden class=anchor aria-hidden=true href=#453-部分股票预测收益率表>#</a></h4><table><thead><tr><th>sec_code</th><th>trade_date</th><th>y_hat</th></tr></thead><tbody><tr><td>000001.SZ</td><td>2011/5/26</td><td>0.0424621</td></tr><tr><td>000002.SZ</td><td>2011/5/26</td><td>-0.1632174</td></tr><tr><td>000004.SZ</td><td>2011/5/26</td><td>-0.0642319</td></tr><tr><td>000005.SZ</td><td>2011/5/26</td><td>0.08154649</td></tr><tr><td>000006.SZ</td><td>2011/5/26</td><td>0.00093213</td></tr><tr><td>000007.SZ</td><td>2011/5/26</td><td>-0.073218</td></tr><tr><td>000008.SZ</td><td>2011/5/26</td><td>-0.0464256</td></tr><tr><td>000009.SZ</td><td>2011/5/26</td><td>-0.091549</td></tr><tr><td>000010.SZ</td><td>2011/5/26</td><td>0.08154649</td></tr><tr><td>000011.SZ</td><td>2011/5/26</td><td>-0.1219943</td></tr><tr><td>000012.SZ</td><td>2011/5/26</td><td>-0.1448984</td></tr><tr><td>000014.SZ</td><td>2011/5/26</td><td>0.09038845</td></tr><tr><td>000016.SZ</td><td>2011/5/26</td><td>-0.11225</td></tr></tbody></table><h4 id=454-代码实现片段>4.5.4 代码实现片段<a hidden class=anchor aria-hidden=true href=#454-代码实现片段>#</a></h4><p>以下是训练过程所使用的部分代码，用于构建BiLSTM训练网络。</p><p><details><summary markdown=span>build_net_blstm</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>build_net_blstm</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span> <span class=o>=</span> <span class=n>ks</span><span class=o>.</span><span class=n>Sequential</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>add</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>Bidirectional</span><span class=p>(</span><span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>LSTM</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=mi>50</span>
</span></span><span class=line><span class=cl>        <span class=p>),</span><span class=n>input_shape</span><span class=o>=</span><span class=p>(</span><span class=mi>11</span><span class=p>,</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>add</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>Dropout</span><span class=p>(</span><span class=mf>0.01</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>Dense</span><span class=p>(</span><span class=mi>256</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>add</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>Dropout</span><span class=p>(</span><span class=mf>0.01</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>Dense</span><span class=p>(</span><span class=mi>64</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>ks</span><span class=o>.</span><span class=n>layers</span><span class=o>.</span><span class=n>Dense</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>optimizer</span><span class=o>=</span><span class=s1>&#39;sgd&#39;</span><span class=p>,</span> <span class=n>loss</span><span class=o>=</span><span class=s1>&#39;mse&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span><span class=o>.</span><span class=n>summary</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>set_model</span><span class=p>(</span><span class=n>model</span><span class=p>)</span>  
</span></span></code></pre></div></details></p><h3 id=46-量化策略和策略回测>4.6 量化策略和策略回测<a hidden class=anchor aria-hidden=true href=#46-量化策略和策略回测>#</a></h3><h4 id=461-回测指标>4.6.1 回测指标<a hidden class=anchor aria-hidden=true href=#461-回测指标>#</a></h4><p>下面先对策略的一些常见回测指标进行介绍。评价指标包括累计收益率（Total Rate of Return）、年化收益率（Annualized Rate of Return）、年化波动率（Annualized volatility）、夏普比率（Sharpe ratio）、最大回撤率 (Maximum Drawdown，MDD)、年化换手率（Annualized turnover rate）和年化交易成本率（Annualized transaction cost rate），其中假定一年股市开盘252天，无风险利率默认为0.035，手续费默认0.002。</p><ol><li><strong>累计收益率（Total Rate of Return）</strong>：在其他指标相同的情况下，累计收益率越大说明该策略越好，越能带来更大的收益。公式如下：</li></ol>$$
\text{Total Rate of Return} = r_{p} = \frac{P_{1} - P_{0}}{P_{0}}
$$<p>$P_{1}$ ：最终股票和现金的总价值<br>$P_{0}$ ：初始股票和现金的总价值</p><ol start=2><li><strong>年化收益率（Annualized Rate of Return）</strong>：是将累计总收益率换算成以年为单位的几何平均收益率。在其他指标相同的情况下，年化收益率越大，代表该策略越好。公式如下：</li></ol>$$
\text{Annualized Rate of Return} = R_{p} = \left(1 + r_{p}\right)^{\frac{252}{t}} - 1
$$<p>$r_{p}$ ：累计收益率<br>$t$ ：投资策略执行的天数</p><ol start=3><li><strong>年化波动率（Annualized volatility）</strong>：定义为对象资产的年回报率的对数值的标准差。年化波动率用来衡量策略的风险性，波动率越大代表策略的风险越高。公式如下：</li></ol>$$
\begin{aligned}
\text{Annualized volatility} = \sigma_{p} &= \sqrt{\frac{252}{t-1} \sum_{i=1}^{t}\left(r_{d} - \bar{r}_{d}\right)^{2}} \\
\bar{r}_{d} &= \frac{1}{t} \sum_{i=1}^{t} r_{d_{i}}
\end{aligned}
$$<p>$r_{d_{i}}$ ：第 $i$ 天日收益率<br>$\bar{r}_{d}$ ：日平均收益率<br>$t$ ：投资策略执行的天数</p><ol start=4><li><strong>夏普比率（Sharpe ratio）</strong>：是由 <a href=https://doi.org/10.2307/2328485>Sharpe（1966）</a>$^{[24]}$ 提出的。它代表投资者额外承受一单位风险，所获得的超额收益$^{[25]}$。这里给出年化的夏普比率计算公式：</li></ol>$$
S = \frac{R_{p} - R_{f}}{\sigma_{p}}
$$<p>$R_{p}$ ：年化收益率<br>$R_{f}$ ：无风险收益率<br>$\sigma_{p}$ ：年化波动率</p><ol start=5><li><strong>最大回撤率 (Maximum Drawdown，MDD)</strong>：表示表示我们策略运行期间股票和现金的总价值走到最低点时的收益率回撤幅度的最大值。最大回测率用来策略最极端可能的亏损情况。</li></ol>$$
MDD = \frac{\max \left(V_{x} - V_{y}\right)}{V_{x}}
$$<p>$V_{x}$ 和 $V_{y}$ 分别为策略组合在第 $x$ 天和第 $y$ 天的股票和现金的总价值，且 $x &lt; y$。</p><ol start=6><li><strong>年化换手率（Annualized turnover rate）</strong>：用来衡量对投资组合里面的股票买卖的频繁程度。越大说明改投资组合换仓越频繁，交易成本也会越大。</li></ol>$$
\text{change} = \frac{N \times 252}{t}
$$<p>$t$ ：投资策略执行的天数<br>$N$ ：总共买进和卖出的次数</p><ol start=7><li><strong>年化交易成本率（Annualized transaction cost rate）</strong>：用来衡量投资组合策略的交易成本，越大说明交易成本越高。</li></ol>$$
c = \left(1 + \text{commison}\right)^{\text{change}} - 1
$$<p>change：年化换手率<br>commison：手续费</p><h4 id=462-策略及回测结果>4.6.2 策略及回测结果<a hidden class=anchor aria-hidden=true href=#462-策略及回测结果>#</a></h4><p>本文量化交易策略采用每隔一个月进行换仓（即调仓周期为28个交易日），每次换仓采取等额持股的方式买入 BiLSTM 预测出的预期收益率最高的25支股票，卖出原本所持有的股票。本文的回测时间和规则如下：</p><ol><li><strong>回测时间</strong>：从 2012 年 1 月到 2020 年 10 月。</li><li><strong>回测股票池</strong>：全 A 股，剔除特别处理（Special treatment，ST）股票。</li><li><strong>交易手续费</strong>：买入时支付给券商交易佣金千分之二，卖出时支付给券商交易佣金千分之二，其中单笔交易佣金不满5元券商按5元收取交易佣金。</li><li><strong>买卖规则</strong>：当天开盘涨停股票不能买入，跌停股票不能卖出。</li></ol><h5 id=4621-策略回测结果>4.6.2.1 策略回测结果<a hidden class=anchor aria-hidden=true href=#4621-策略回测结果>#</a></h5><table><thead><tr><th></th><th>累计收益率</th><th>年化收益率</th><th>年化波动率</th><th>夏普比率</th><th>最大回撤</th><th>年化换手率</th><th>年化交易成本率</th></tr></thead><tbody><tr><td><strong>策略</strong></td><td>701.00%</td><td>29.18%</td><td>33.44%</td><td>0.77</td><td>51.10%</td><td>51.10%</td><td>11.35%</td></tr><tr><td><strong>基准</strong></td><td>110.40%</td><td>9.70%</td><td>26.01%</td><td>0.24</td><td>58.49%</td><td>58.49%</td><td>0.00%</td></tr></tbody></table><figure class=align-center><img loading=lazy src=res.png#center alt="Fig. 22. Net Profit Curve"><figcaption><p>Fig. 22. Net Profit Curve</p></figcaption></figure><p>回测结果如上表和 Fig.22 所示。我的策略采用的是本章所介绍的 LightGBM-BiLSTM 量化策略。基准采用的中证全指（000985）。由上面的结果可以看到，本策略累计收益率为701.00%，远高于基准110.40%；年化收益率为29.18%，远高于基准9.70%；夏普率为0.77，高于基准0.24。这三项回测指标说明 LightGBM-BiLSTM 量化策略确实能够给投资者带来更大的收益。本策略年化波动率为33.44%大于基准26.01%，最大回撤为51.10%小于基准58.49%，这两项回测指标说明 LightGBM-BiLSTM 量化策略存在一定的风险，特别是很难抵御系统性风险的冲击。年化换手率为11.35%，年化交易成本率为2.29%，说明我们策略不是高频交易策略，交易成本较小。从收益曲线图可以看出 LightGBM-BiLSTM 量化策略在前两年的收益率和基准相差不大，并没有特别的优势。但从2015年4月左右开始 LightGBM-BiLSTM 量化策略的收益率明显好于基准的收益率。总体而言，该 LightGBM-BiLSTM 量化策略的收益率十分可观，但仍然存在一定的风险。</p><h2 id=第五章-总结与展望>第五章 总结与展望<a hidden class=anchor aria-hidden=true href=#第五章-总结与展望>#</a></h2><h3 id=51-总结>5.1 总结<a hidden class=anchor aria-hidden=true href=#51-总结>#</a></h3><p>本文首先介绍了基于深度学习的股票价格预测和量化策略研究的研究背景和研究意义，然后分别介绍了股票价格预测和量化投资策略国内外的研究现状，之后说明了本文的创新点和研究框架。接着本论文在相关理论基础章节大致介绍了本文用到的深度学习模型和量化投资的发展历程。重点介绍了 LSTM，GRU，BiLSTM 这三个模型的基本结构，基本原理和特点。</p><p>随后，本文利用浦发银行和 IBM 的日频数据，通过一系列的数据处理过程和特征提取来对数据进行预处理。然后介绍了 LSTM，GRU，BiLSTM 这三个模型的具体网络结构以及超参数的设定。紧接着我们使用 LSTM，GRU，BiLSTM 分别进行两只股票收盘价的预测和模型评估比较。实验结果表明对于两只股票而言都是 BiLSTM 预测效果更加准确。</p><p>最后，本论文为了进一步说明 BiLSTM 在金融上的运用价值，构建了基于 LightGBM－BiLSTM 的量化投资模型。选取 A 股全市场的股票和多个因子依次进行因子清洗，基于 LightGBM 的因子选择和基于 LSTM 的因子组合等过程。接着，我们构建一定的投资策略并通过累计收益率，年化收益率，年化波动率和夏普比率等评估指标与基准的持有中证全指进行对比。通过对比发现 LightGBM－BiLSTM 量化投资模型能带来更好的收益，说明了利用深度学习构建量化投资策略的有效性。</p><h3 id=52-展望>5.2 展望<a hidden class=anchor aria-hidden=true href=#52-展望>#</a></h3><p>本文虽然分别对比 LSTM，GRU，BiLSTM 这三个模型预测股票收盘价的效果和基于 LightGBM－BiLSTM 量化投资策略取得了一定的成果，但本文研究仍有一些不足之处。结合本文的研究成果，可以进一步进行以下研究和改进：</p><ol><li><strong>预测目标多样化</strong>：本文在预测股票价格方面，选取的股票收盘价作为预测目标，虽然这一结果最直观，但 <a href=http://www.numdam.org/item/ASENS_1900_3_17__21_0/>Bachelier（1900）</a>$^{[26]}$ 提出的随机游走假说（Random Walk Hypothesis，RWH）认为股票的价格服从随机漫步，是不可预测的。虽然之后有许多行为经济学家证明这一观点不完全正确，但这也同时说明单纯预测股票的收盘价难度和可解释性不那么强 $^{[27][28]}$。因此可以选择股票波动率预测，股票涨跌判断和股票收益率预测等作为未来的研究的方向。</li><li><strong>模型多样化对比</strong>：本文在预测股票价格方面，对比了 LSTM，GRU 和 BiLSTM 这三种循环神经网络模型并且说明了 BiLSTM 预测效果比较好，但仍然缺少和其他更多不同模型的对比研究。因此未来可以深入研究与 Autoregressive Integrated Moving Average (ARIMA)，卷积神经网络（Convolutional Neural Networks，CNN），深度神经网络（Deep Neural Networks，DNN）, CNN－LSTM, Transformer 和 TimeGPT 等单一或复合模型之间的对比。</li><li><strong>因子多样化</strong>：本文在构建量化投资策略方面使用的因子都是技术面的价量因子，因子的种类单一。未来可以选择财务因子，情绪因子，成长因子等不同种类的因子，从而提高策略的性能。同时未来研究还可以适当的加入择时策略，在预测大盘上涨时增加仓位，在预测大盘下跌时减少仓位，赚取贝塔（beta，$\beta$）的钱。</li><li><strong>投资组合优化</strong>：本文的因子组合过程仍然不完善，未来可以利用二次规划的方法对投资组合进行优化。</li><li><strong>高频交易策略研究</strong>：本文的量化投资策略方法采取的是低频交易的策略，未来可以利用股票的 tick 数据来研究高频策略和超高频策略。</li></ol><h2 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h2><p>[1] White, H. <a href=https://pages.cs.wisc.edu/~dyer/cs540/handouts/deep-learning-nature2015.pdf>“Economic prediction using neural networks: The case of IBM daily stock returns.”</a> <em>Proc. of ICNN</em>. 1988, 2: 451-458.</p><p>[2] Kimoto, T., Asakawa, K., Yoda, M., et al. <a href=https://web.ist.utl.pt/adriano.simoes/tese/referencias/Papers%20-%20Adriano/NN.pdf>“Stock market prediction system with modular neural networks.”</a> <em>Proc. of 1990 IJCNN International Joint Conference on Neural Networks</em>. IEEE, 1990: 1-6.</p><p>[3] Zhang, G. P. <a href=https://dl.icdst.org/pdfs/files/2c442c738bd6bc178e715f400bec5d5f.pdf>“Time series forecasting using a hybrid ARIMA and neural network model.”</a> <em>Neurocomputing</em>. 2003, 50: 159-175.</p><p>[4] Akita, R., Yoshihara, A., Matsubara, T., et al. <a href=https://ieeexplore.ieee.org/document/7550882>“Deep learning for stock prediction using numerical and textual information.”</a> <em>Proc. of 2016 IEEE/ACIS 15th International Conference on Computer and Information Science (ICIS)</em>. IEEE, 2016: 1-6.</p><p>[5] 宮崎邦洋, 松尾豊. <a href=https://www.ai-gakkai.or.jp/jsai2017/webprogram/2017/pdf/1112.pdf>“Deep Learning を用いた株価予測の分析.”</a> <em>人工知能学会全国大会論文集 第31回全国大会</em>. 一般社団法人 人工知能学会, 2017: 2D3OS19a3-2D3OS19a3.</p><p>[6] Kim, T., Kim, H. Y. <a href="https://journals.plos.org/plosone/article/file?id=10.1371/journal.pone.0212320&amp;type=printable">“Forecasting stock prices with a feature fusion LSTM-CNN model using different representations of the same data.”</a> <em>PLoS ONE</em>. 2019, 14(2): e0212320.</p><p>[7] Hochreiter, S., Schmidhuber, J. <a href=https://www.bioinf.jku.at/publications/older/2604.pdf>“Long short-term memory.”</a> <em>Neural Computation</em>. 1997, 9(8): 1735-1780.</p><p>[8] Cho, K., Van Merriënboer, B., Gulcehre, C., et al. <a href=https://arxiv.org/abs/1406.1078>“Learning phrase representations using RNN encoder-decoder for statistical machine translation.”</a> <em>arXiv preprint arXiv:1406.1078</em>. 2014.</p><p>[9] Chung, J., Gulcehre, C., Cho, K. H., et al. <a href=https://arxiv.org/abs/1412.3555>“Empirical evaluation of gated recurrent neural networks on sequence modeling.”</a> <em>arXiv preprint arXiv:1412.3555</em>. 2014.</p><p>[10] Gruber, N., Jockisch, A. <a href=https://www.frontiersin.org/journals/artificial-intelligence/articles/10.3389/frai.2020.00040/full>“Are GRU cells more specific and LSTM cells more sensitive in motive classification of text?”</a> <em>Frontiers in Artificial Intelligence</em>. 2020, 3(40): 1-6.</p><p>[11] Markowitz, H. <a href=https://www.jstor.org/stable/2975974>“Portfolio Selection.”</a> <em>The Journal of Finance</em>. 1952, 7(1): 77-91. doi:10.2307/2975974.</p><p>[12] Merton, R. C. <a href=https://www.jstor.org/stable/2329621>“An analytic derivation of the efficient portfolio frontier.”</a> <em>Journal of Financial and Quantitative Analysis</em>. 1972: 1851-1872.</p><p>[13] Sharpe, W. F. <a href=https://www.jstor.org/stable/2977928>“Capital asset prices: A theory of market equilibrium under conditions of risk.”</a> <em>The Journal of Finance</em>. 1964, 19(3): 425-442.</p><p>[14] Lintner, J. <a href=https://www.jstor.org/stable/1924119>“The Valuation of Risk Assets and the Selection of Risky Investments in Stock Portfolios and Capital Budgets.”</a> <em>Review of Economics and Statistics</em>. 1965, 47(1): 13-37.</p><p>[15] Mossin, J. <a href=https://www.jstor.org/stable/1910098>“Equilibrium in a capital asset market.”</a> <em>Econometrica: Journal of the Econometric Society</em>. 1966: 768-783.</p><p>[16] Ross, S. A. <a href=https://www.top1000funds.com/wp-content/uploads/2014/05/The-Arbitrage-Theory-of-Capital-Asset-Pricing.pdf>“The arbitrage theory of capital asset pricing.”</a> <em>Journal of Economic Theory</em>. 1976, 13(3): 341-60.</p><p>[17] Fama, E. F., French, K. R. <a href=https://www.bauer.uh.edu/rsusmel/phd/Fama-French_JFE93.pdf>“Common risk factors in the returns on stocks and bonds.”</a> <em>Journal of Financial Economics</em>. 1993, 33(1): 3-56.</p><p>[18] Fama, E. F., French, K. R. <a href=https://tevgeniou.github.io/EquityRiskFactors/bibliography/FiveFactor.pdf>“A five-factor asset pricing model.”</a> <em>Journal of Financial Economics</em>. 2015, 116(1): 1-22.</p><p>[19] Kingma, D. P., Ba, J. <a href=https://arxiv.org/abs/1412.6980>“Adam: A method for stochastic optimization.”</a> <em>arXiv preprint arXiv:1412.6980</em>. 2014.</p><p>[20] Friedman, J. H. <a href=https://www.jstor.org/stable/2699986>“Greedy function approximation: A gradient boosting machine.”</a> <em>Annals of Statistics</em>. 2001: 1189-1232.</p><p>[21] Kopitar, L., Kocbek, P., Cilar, L., et al. <a href=https://www.nature.com/articles/s41598-020-68771-z>“Early detection of type 2 diabetes mellitus using machine learning-based prediction models.”</a> <em>Scientific Reports</em>. 2020, 10(1): 1-12.</p><p>[22] Ke, G., Meng, Q., Finley, T., et al. <a href=https://proceedings.neurips.cc/paper_files/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf>“Lightgbm: A highly efficient gradient boosting decision tree.”</a> <em>Advances in Neural Information Processing Systems</em>. 2017, 30: 3146-3154.</p><p>[23] Bottou, L., Curtis, F. E., Nocedal, J. <a href=https://coral.ise.lehigh.edu/frankecurtis/files/papers/BottCurtNoce18.pdf>“Optimization methods for large-scale machine learning.”</a> <em>SIAM Review</em>. 2018, 60(2): 223-311.</p><p>[24] Sharpe, W. F. <a href=https://finance.martinsewell.com/fund-performance/Sharpe1966.pdf>“Mutual fund performance.”</a> <em>The Journal of Business</em>. 1966, 39(1): 119-138.</p><p>[25] Sharpe, W. F. <a href=https://web.stanford.edu/~wfsharpe/art/sr/sr.htm>“The sharpe ratio.”</a> <em>Journal of Portfolio Management</em>. 1994, 21(1): 49-58.</p><p>[26] Bachelier, L. <a href=http://www.numdam.org/item/ASENS_1900_3_17__21_0/>“Théorie de la spéculation.”</a> <em>Annales Scientifiques de l&rsquo;École Normale Supérieure</em>. 1900, 17: 21-86.</p><p>[27] Fromlet, H. <a href=https://www.jstor.org/stable/23488166>“Behavioral finance-theory and practical application: Systematic analysis of departures from the homo oeconomicus paradigm are essential for realistic financial research and analysis.”</a> <em>Business Economics</em>. 2001: 63-69.</p><p>[28] Lo, A. W. <a href=https://www.pm-research.com/content/iijpormgmt/30/5/15>“The adaptive markets hypothesis.”</a> <em>The Journal of Portfolio Management</em>. 2004, 30(5): 15-29.</p><h3 id=参考博客>参考博客<a hidden class=anchor aria-hidden=true href=#参考博客>#</a></h3><ul><li>Colah&rsquo;s Blog. (2015, August 27). <a href=https://colah.github.io/posts/2015-08-Understanding-LSTMs/><em>Understanding LSTM Networks.</em></a></li></ul><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><blockquote><p><strong>引用</strong>：转载或引用本文内容，请注明原作者与出处。</p></blockquote><p><strong>Cited as:</strong></p><blockquote><p>Yue Shui. (Apr 2021). 基于深度学习的股票价格预测和量化策略.<br><a href=https://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/>https://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/</a></p></blockquote><p>Or</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bibtex data-lang=bibtex><span class=line><span class=cl><span class=nc>@article</span><span class=p>{</span><span class=nl>syhya2021stockprediction</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>title</span>   <span class=p>=</span> <span class=s>&#34;基于深度学习的股票价格预测和量化策略&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>author</span>  <span class=p>=</span> <span class=s>&#34;Yue Shui&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>journal</span> <span class=p>=</span> <span class=s>&#34;syhya.github.io&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>year</span>    <span class=p>=</span> <span class=s>&#34;2021&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>month</span>   <span class=p>=</span> <span class=s>&#34;Apr&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>url</span>     <span class=p>=</span> <span class=s>&#34;https://syhya.github.io/posts/2021-04-21-deep-learning-stock-prediction/&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://syhya.github.io/zh/tags/deep-learning/>Deep Learning</a></li><li><a href=https://syhya.github.io/zh/tags/ai/>AI</a></li><li><a href=https://syhya.github.io/zh/tags/rnn/>RNN</a></li><li><a href=https://syhya.github.io/zh/tags/lstm/>LSTM</a></li><li><a href=https://syhya.github.io/zh/tags/bilstm/>BiLSTM</a></li><li><a href=https://syhya.github.io/zh/tags/gru/>GRU</a></li><li><a href=https://syhya.github.io/zh/tags/lightgbm/>LightGBM</a></li><li><a href=https://syhya.github.io/zh/tags/neural-networks/>Neural Networks</a></li><li><a href=https://syhya.github.io/zh/tags/stock-prediction/>Stock Prediction</a></li><li><a href=https://syhya.github.io/zh/tags/financial-modeling/>Financial Modeling</a></li><li><a href=https://syhya.github.io/zh/tags/machine-learning/>Machine Learning</a></li><li><a href=https://syhya.github.io/zh/tags/quantitative-investment/>Quantitative Investment</a></li><li><a href=https://syhya.github.io/zh/tags/portfolio-management/>Portfolio Management</a></li><li><a href=https://syhya.github.io/zh/tags/financial-engineering/>Financial Engineering</a></li><li><a href=https://syhya.github.io/zh/tags/algorithmic-trading/>Algorithmic Trading</a></li><li><a href=https://syhya.github.io/zh/tags/time-series/>Time Series</a></li></ul><nav class=paginav><a class=prev href=https://syhya.github.io/zh/posts/2024-12-21-build-gpu-server/><span class=title>« 上一页</span><br><span>基于双卡 RTX 4090 搭建家用深度学习主机</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on x" href="https://x.com/intent/tweet/?text=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5&amp;url=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f&amp;hashtags=Deeplearning%2cAI%2cRNN%2cLSTM%2cBiLSTM%2cGRU%2cLightGBM%2cNeuralNetworks%2cStockPrediction%2cFinancialModeling%2cMachineLearning%2cQuantitativeInvestment%2cPortfolioManagement%2cFinancialEngineering%2cAlgorithmicTrading%2cTimeSeries"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f&amp;title=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5&amp;summary=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5&amp;source=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f&title=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5%20-%20https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on telegram" href="https://telegram.me/share/url?text=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5&amp;url=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 基于深度学习的股票价格预测和量化策略 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%82%a1%e7%a5%a8%e4%bb%b7%e6%a0%bc%e9%a2%84%e6%b5%8b%e5%92%8c%e9%87%8f%e5%8c%96%e7%ad%96%e7%95%a5&u=https%3a%2f%2fsyhya.github.io%2fzh%2fposts%2f2021-04-21-deep-learning-stock-prediction%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://syhya.github.io/zh/>Yue Shui 博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>