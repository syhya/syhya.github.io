<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The LLaMA Herd | Yue Shui Blog</title><meta name=keywords content="LLaMA,AI,NLP,LLM,Pre-training,Post-training"><meta name=description content="LLaMA
The LLaMA series of open-source models released by Meta AI has become one of the cornerstones of the large language model community, profoundly impacting the advancement of open research and applications. From the pioneering LLaMA released in early 2023, to the significantly improved LLaMA 2 later that year, to derivative models targeting specific domains (like code, safety), and the subsequent new generations LLaMA 3 and LLaMA 4 launched in 2024 and 2025 respectively, Meta has continuously committed to enhancing the performance of open-source models, gradually bringing them closer to state-of-the-art closed-source models. Below, we will introduce the key technical details of each major model in sequence."><meta name=author content="Yue Shui"><link rel=canonical href=https://syhya.github.io/posts/2025-04-06-llama/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3dc782d653c34c6a0c8f1a261092c93b4c57a4549c8e3b36275bd5d52648e773.css integrity="sha256-PceC1lPDTGoMjxomEJLJO0xXpFScjjs2J1vV1SZI53M=" rel="preload stylesheet" as=style><link rel=icon href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://syhya.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://syhya.github.io/posts/2025-04-06-llama/><link rel=alternate hreflang=zh href=https://syhya.github.io/zh/posts/2025-04-06-llama/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>window.MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SZ2660B91F"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SZ2660B91F")}</script><meta property="og:url" content="https://syhya.github.io/posts/2025-04-06-llama/"><meta property="og:site_name" content="Yue Shui Blog"><meta property="og:title" content="The LLaMA Herd"><meta property="og:description" content="LLaMA The LLaMA series of open-source models released by Meta AI has become one of the cornerstones of the large language model community, profoundly impacting the advancement of open research and applications. From the pioneering LLaMA released in early 2023, to the significantly improved LLaMA 2 later that year, to derivative models targeting specific domains (like code, safety), and the subsequent new generations LLaMA 3 and LLaMA 4 launched in 2024 and 2025 respectively, Meta has continuously committed to enhancing the performance of open-source models, gradually bringing them closer to state-of-the-art closed-source models. Below, we will introduce the key technical details of each major model in sequence."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-06T12:00:00+08:00"><meta property="article:modified_time" content="2025-06-29T21:43:56+08:00"><meta property="article:tag" content="LLaMA"><meta property="article:tag" content="AI"><meta property="article:tag" content="NLP"><meta property="article:tag" content="LLM"><meta property="article:tag" content="Pre-Training"><meta property="article:tag" content="Post-Training"><meta property="og:image" content="https://syhya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://syhya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The LLaMA Herd"><meta name=twitter:description content="LLaMA
The LLaMA series of open-source models released by Meta AI has become one of the cornerstones of the large language model community, profoundly impacting the advancement of open research and applications. From the pioneering LLaMA released in early 2023, to the significantly improved LLaMA 2 later that year, to derivative models targeting specific domains (like code, safety), and the subsequent new generations LLaMA 3 and LLaMA 4 launched in 2024 and 2025 respectively, Meta has continuously committed to enhancing the performance of open-source models, gradually bringing them closer to state-of-the-art closed-source models. Below, we will introduce the key technical details of each major model in sequence."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://syhya.github.io/posts/"},{"@type":"ListItem","position":2,"name":"The LLaMA Herd","item":"https://syhya.github.io/posts/2025-04-06-llama/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The LLaMA Herd","name":"The LLaMA Herd","description":"LLaMA The LLaMA series of open-source models released by Meta AI has become one of the cornerstones of the large language model community, profoundly impacting the advancement of open research and applications. From the pioneering LLaMA released in early 2023, to the significantly improved LLaMA 2 later that year, to derivative models targeting specific domains (like code, safety), and the subsequent new generations LLaMA 3 and LLaMA 4 launched in 2024 and 2025 respectively, Meta has continuously committed to enhancing the performance of open-source models, gradually bringing them closer to state-of-the-art closed-source models. Below, we will introduce the key technical details of each major model in sequence.\n","keywords":["LLaMA","AI","NLP","LLM","Pre-training","Post-training"],"articleBody":"LLaMA The LLaMA series of open-source models released by Meta AI has become one of the cornerstones of the large language model community, profoundly impacting the advancement of open research and applications. From the pioneering LLaMA released in early 2023, to the significantly improved LLaMA 2 later that year, to derivative models targeting specific domains (like code, safety), and the subsequent new generations LLaMA 3 and LLaMA 4 launched in 2024 and 2025 respectively, Meta has continuously committed to enhancing the performance of open-source models, gradually bringing them closer to state-of-the-art closed-source models. Below, we will introduce the key technical details of each major model in sequence.\nLLaMA 1 LLaMA 1 (Touvron et al., 2023a), released in February 2023, was Meta’s first series of open-source foundation language models. LLaMA was offered in four parameter sizes: 7B, 13B, 33B, and 65B. Its core characteristic was being trained entirely on publicly available datasets, without relying on any proprietary data. Despite having a significantly smaller parameter count than the contemporary GPT-3 (175B), the LLaMA 13B model outperformed GPT-3 on most benchmarks, while the 65B model achieved performance comparable to top models like Chinchilla-70B and PaLM-540B.\nFig. 1. Zero-shot performance of LLaMA models on Common Sense Reasoning tasks compared to other foundation models. (Source: Touvron et al., 2023a)\nTraining Data: LLaMA 1 was trained on large-scale public corpora. The 65B and 33B models used approximately 1.4 trillion tokens, while the 7B and 13B models used about 1 trillion tokens. The corpus sources were diverse, primarily including Common Crawl, C4, GitHub, Wikipedia, Books, ArXiv, and StackExchange, covering multiple domains and about 20 languages (predominantly English).\nArchitecture Design: LLaMA 1 employed a standard Transformer decoder architecture, incorporating the following key improvements to enhance performance and training efficiency:\nPre-normalization \u0026 RMSNorm: Adopted a Pre-normalization structure (applying normalization before each sub-layer input) and used RMSNorm (Root Mean Square Normalization) instead of standard LayerNorm. RMSNorm reduces computational complexity by omitting the mean centering step, scaling based only on the root mean square of the vector elements, while effectively maintaining training stability. SwiGLU Activation Function: Replaced the activation function in the feed-forward network (FFN) from ReLU to SwiGLU (Swish-Gated Linear Unit). SwiGLU combines the smooth non-linearity of the Swish activation function with a gating mechanism, enhancing the model’s expressive power. Concurrently, LLaMA adjusted the FFN’s hidden layer dimension (using $ \\frac{2}{3} \\times 4d $ instead of the standard $4d$, where $d$ is the model dimension) to roughly maintain the total parameter count and computational load of the FFN layer while introducing gating parameters. RoPE Rotary Position Embeddings: Utilized Rotary Position Embeddings (RoPE) for positional encoding. RoPE effectively incorporates relative positional information into self-attention calculations by applying position-dependent rotation operations to Query and Key vectors, enhancing the model’s ability to handle long sequences and capture long-range dependencies. LLaMA 1 had a maximum context length of 2048 tokens. Efficient Attention Implementation: Leveraged Meta’s open-source xformers library to implement a memory-efficient and computationally optimized causal multi-head attention mechanism. Fine-tuned Dialogue Models: At its release, LLaMA 1 primarily provided pre-trained model weights (with restricted commercial use) and did not include an official dialogue fine-tuned version. However, the open-source community quickly explored its potential. For instance, the Stanford Alpaca (Taori et al., 2023) project demonstrated that Supervised Fine-tuning (SFT) with only a small amount of instruction data could endow the LLaMA base model with strong conversational abilities, greatly promoting the research and application ecosystem of open-source LLMs.\nFig. 2. The pipeline for generating instruction-following demonstrations and training Alpaca 7B based on LLaMA 7B. (Source: Taori et al., 2023)\nTraining Stability \u0026 Loss Spikes\nFig. 3. Training loss curves over processed tokens for the LLaMA 7B, 13B, 33B, and 65B models. (Source: Touvron et al., 2023a)\nAs observed in Figure 3, the training loss of LLaMA models generally shows a downward trend, indicating relatively stable training. However, during the training of the 13B, 33B, and 65B models, Loss Spikes occurred, where the training loss suddenly and abnormally surged at certain points. The larger the model scale, the more pronounced the spike phenomenon seems to be, and it might occur multiple times during training.\nPhenomenon Description: A Loss Spike refers to a brief, sharp, and abnormal increase in the loss function value during model training. Potential Causes: Often related to multiple factors, including anomalous samples or distribution shifts in the training data, improper learning rate settings (too high or issues with decay strategy), interaction between the optimizer’s internal state (like Adam) and drastic gradient changes, and numerical instability in mixed-precision training (e.g., gradient overflow or underflow). Common Mitigation Strategies: Methods to resolve or mitigate Loss Spikes include: strengthening data cleaning and preprocessing; applying Gradient Clipping to limit the gradient norm; fine-tuning learning rate scheduling strategies (like Warmup, Decay); optimizing mixed-precision training configurations; and, after a spike occurs, resuming training from the nearest checkpoint, possibly skipping the specific data batch that caused the issue. LLaMA 2 LLaMA 2 (Touvron et al., 2023b), launched in July 2023, was a significant upgrade to LLaMA 1. Compared to the first generation, LLaMA 2 featured notable improvements in model scale, training data volume, context length, and model alignment. It also marked the first release of an official dialogue-optimized version, LLaMA 2-Chat, and came with a license permitting commercial use.\nArchitecture \u0026 Optimization: LLaMA 2’s base architecture largely inherited the successful design of LLaMA 1 (e.g., RMSNorm, SwiGLU, RoPE). Key technical updates included:\nGrouped Query Attention (GQA): For the larger 34B and 70B models, Grouped Query Attention (GQA) was adopted. GQA is a compromise between Multi-Head Attention (MHA) and Multi-Query Attention (MQA), allowing multiple Query heads to share the same set of Key and Value heads. This significantly reduces the memory footprint and computational overhead of the KV cache during inference, thereby improving the inference speed and deployment efficiency of large models with minimal impact on performance. Increased Context Length: The maximum context length of the model was extended from LLaMA 1’s 2048 tokens to 4096 tokens. This enabled the model to process longer text inputs, enhancing its capabilities in tasks like long-document question answering, summarization, and extended conversations. Training Data \u0026 Scale: LLaMA 2 was trained on a larger pre-training dataset, totaling approximately 2 trillion tokens, about a 40% increase compared to LLaMA 1. The data sources were more diverse, and underwent more rigorous filtering and cleaning.\nPost-Training (LLaMA 2-Chat): LLaMA 2-Chat is a meticulously aligned dialogue model. Its training process starts with the LLaMA 2 pre-trained base model and primarily involves the following stages:\nSupervised Fine-tuning (SFT): The pre-trained model is fine-tuned using high-quality instruction and dialogue samples, initially equipping it with the ability to follow instructions and engage in dialogue. Reinforcement Learning from Human Feedback (RLHF): This is a crucial step for enhancing the model’s Helpfulness and Safety. Reward Modeling: A large amount of human preference data is collected (i.e., ranking multiple responses generated by the model). One or more reward models are trained to learn to evaluate which response better aligns with human preferences (along dimensions of helpfulness and safety). RL Optimization: Using the trained reward model(s) as a reward signal, the SFT model is further optimized using PPO and Rejection Sampling. PPO aims to maximize the reward signal, while rejection sampling further improves model quality by selecting the highest-reward response from K samples generated by the model for gradient updates. This process is typically iterative, continually collecting new preference data to refine the reward model and the dialogue model itself. It drew inspiration from Anthropic’s Constitutional AI and HH-RLHF (Bai et al., 2022). The relevant HH-RLHF dataset is available on Hugging Face. Fig. 4. Illustration of the Llama 2-Chat fine-tuning process, including SFT and RLHF stages with rejection sampling and PPO. (Source: Touvron et al., 2023b)\nCode Llama Code Llama (Rozière et al., 2023), released by Meta in August 2023, is a family of large language models built upon LLaMA 2, specifically focused on coding capabilities. Through additional continued pre-training on massive amounts of programming code data and specific task fine-tuning, Code Llama demonstrates excellent capabilities in code generation, code completion, code understanding, and debugging.\nFig. 5. The Code Llama specialization pipeline, starting from Llama 2 and involving code-specific training stages. (Source: Rozière et al., 2023)\nTraining \u0026 Data: Code Llama started with LLaMA 2 weights and underwent continued pre-training on 500 billion tokens of code and code-related natural language corpora (for 7B/13B/34B versions) or 1 trillion tokens (for the 70B version). Training data primarily came from public code repositories and datasets. Key technical improvements include:\nLong Context Fine-tuning (LCFT): Code Llama paid special attention to long sequence processing during training, extending the sequence length to 16k tokens. To better handle long-range dependencies, the base period $\\theta$ of RoPE positional encoding was adjusted (increased from LLaMA 2’s 10,000 to 1,000,000), slowing down the decay of attention scores as the token distance increases. This allows the model to stably handle ultra-long contexts of up to 100k tokens during inference. Fig. 6. Effect of RoPE base period scaling on perplexity for long sequences, showing improved performance with a larger base. (Source: Rozière et al., 2023)\nFill-in-the-Middle (FIM): The training incorporated the Fill-in-the-Middle task. The model needs to insert appropriate code snippets given a code prefix and suffix. This capability is crucial for code completion features in Integrated Development Environments (IDEs). Model Variants: Code Llama offers several versions to meet the needs of different scenarios:\nCode Llama (Base): The foundational code model, adept at code completion and generating code from natural language. Code Llama - Python: Built upon the base model, specialized fine-tuning on an additional 100 billion tokens of Python code significantly enhances performance on Python-related tasks. Code Llama - Instruct: Fine-tuned on code-related instructions and human feedback data (approx. 5 billion tokens), enabling it to better understand natural language instructions to generate, explain, or modify code, making it more suitable as a code assistant. Each version is available in 7B, 13B, 34B, and 70B parameter sizes.\nLlama Guard Llama Guard (Inan et al., 2023), introduced by Meta in December 2023, is a model specifically designed for safeguarding the content of human-AI conversations. It aims to perform content review and risk classification for both user inputs (prompts) and model outputs (responses).\nFig. 7. Example task instructions for the Llama Guard prompt and response classification tasks, demonstrating its safety assessment capability. (Source: Inan et al., 2023)\nModel Overview: Llama Guard is based on the LLaMA 2-7B model and is specifically trained via instruction fine-tuning for the task of safety risk classification. It is not a generative model; instead, it takes a text input, determines if its content is safe, and can output specific risk category labels based on a predefined safety risk taxonomy.\nTraining \u0026 Taxonomy: Meta constructed a taxonomy containing various categories of unsafe content (e.g., violence, hate speech, sexual content, promotion of illegal acts) and collected high-quality labeled data for training. Llama Guard can perform multi-label classification, identifying potentially multiple risks present in the text simultaneously. Due to its instruction fine-tuning paradigm, users can flexibly adjust safety policies or customize classification standards by designing different prompts. Llama Guard can be deployed as a filter at the input end (detecting user input risks) and the output end (detecting risks in model-generated content) of a dialogue system.\nLlama Guard 3 Vision Llama Guard 3 Vision (Chi et al., 2024) is the multimodal upgraded version of Llama Guard, built upon the Llama-3.2-Vision model. It can simultaneously assess the safety risks of both image and text content, extending safety protection capabilities to multimodal scenarios. The model uses a special \u003c|image|\u003e token to integrate image information for unified multimodal safety review.\nFig. 8. Llama Guard 3 Vision classifying harmful content in a multimodal response classification task involving both image and text. (Source: Chi et al., 2024)\nLlama Guard 3 Vision adopts the safety risk classification standard defined by ML Commons (Vidgen et al., 2024) and expands upon it, adding detection for code interpreter abuse risks (Category S14).\nFig. 9. The 14 hazard categories used by Llama Guard 3 Vision, based on the MLCommons taxonomy with an added category for code interpreter abuse. (Source: Meta Llama, 2024)\nBenchmark results show that Llama Guard 3 Vision outperforms advanced models like GPT-4o and GPT-4o mini on multiple metrics within the MLCommons safety benchmark, both for detecting risks in user inputs and model outputs.\nFig. 10. Performance comparison of various models on the MLCommons hazard taxonomy internal test set, showing Llama Guard 3 Vision’s strong results. (Source: Chi et al., 2024)\nLLaMA 3 LLaMA 3 (Grattafiori et al., 2024) is the new generation of open-source large model series successively released by Meta starting from April 2024. It features optimizations in performance, scale, multilingual capabilities, multimodal support, and training efficiency.\nModel Scale \u0026 Version Evolution: The LLaMA 3 series covers a wide range of parameter scales, from small to ultra-large:\nLLaMA 3 (Initial Release, 2024/04): First released 8B and 70B scale pre-trained and instruction fine-tuned models. LLaMA 3.1 (2024/07): (Meta AI, 2024) Introduced the 405B parameter flagship model, with performance approaching GPT-4 levels on multiple benchmarks, along with updated 8B and 70B versions. LLaMA 3.2 (2024/10): Introduced lightweight models (e.g., 1B, 3B, 11B, 13B) optimized for edge devices (like phones, watches, smart homes), and released multimodal vision models (e.g., Llama-3.2-11B-Vision and Llama-3.2-90B-Vision). Fig. 11. Overview of the key hyperparameters for Llama 3 models of different scales. (Source: Grattafiori et al., 2024)\nFrom the figure above, it can be observed that training larger-scale LLMs typically requires using smaller peak learning rates. This is primarily due to:\nOptimization Landscape Complexity and Gradient Stability: Larger parameter counts lead to more complex and non-convex loss landscapes, making the model more sensitive to parameter updates. Smaller learning rates help limit the step size of each update, avoiding excessively large gradients in steep regions that could lead to training oscillations or divergence, thus ensuring a more stable convergence process. Avoiding Overfitting and Improving Generalization: Larger models have greater capacity and are more prone to overfitting the training data. Smaller learning rates allow the model to learn patterns in the data more slowly and robustly, reducing the risk of overfitting to noise or local features in the training data, which helps improve generalization performance on unseen data. Fine-grained Search and Parameter Adjustment: In high-dimensional parameter spaces, the optimal solution might reside in narrow regions. Small learning rates enable the optimization algorithm to perform a finer search, gradually approaching the optimum and avoiding “overshooting” the optimal region due to large step sizes, potentially leading to higher final model accuracy. Fig. 12. Comparison of the high-level architecture between Llama 2 and Llama 3. (Source: Umar Jamil’s PyTorch Llama Slides)\nArchitecture \u0026 Technical Innovations: LLaMA 3 incorporates several significant enhancements over LLaMA 2:\nMassive Pre-training Data: The pre-training data volume reached a staggering 15 trillion tokens, 7.5 times that of LLaMA 2. Data sources were broader, of higher quality, more diverse, and significantly increased the proportion of non-English languages (e.g., German, French, Spanish, Hindi, each \u003e5% of total data) and code data. Optimized Tokenizer: Employed a new tokenizer implemented based on the tiktoken library, with the vocabulary size drastically expanded from LLaMA 2’s 32k to 128k. The larger vocabulary improves encoding efficiency for multiple languages (especially non-Latin scripts) and code, reducing input sequence length by about 15% on average, thereby indirectly boosting model processing efficiency and performance. Extended Context Length: The initial LLaMA 3 release (8B, 70B) supported an 8k token context window. LLaMA 3.1 (405B) further increased the maximum context window to 128k tokens, greatly enhancing the model’s ability to handle long documents, long conversation histories, and complex contextual reasoning. This is typically achieved through techniques like RoPE frequency adjustments and attention mechanism optimizations (e.g., FlashAttention). Universally Applied GQA: Unlike LLaMA 2, which only used GQA in larger models, all scales of LLaMA 3 models (including 8B) adopted Grouped Query Attention (GQA) to optimize memory usage and computation speed during inference. Advanced Alignment Techniques: During the instruction fine-tuning (Post-training) phase, LLaMA 3 combined multiple advanced techniques, including Supervised Fine-tuning (SFT), Rejection Sampling, and Direct Preference Optimization (DPO), aiming to comprehensively improve the model’s instruction-following ability, Helpfulness, and Safety. Multimodal Integration (LLaMA 3.2): Introduced a Vision Encoder and performed joint training to achieve fusion processing of images and text, leading to the Llama-3.2-Vision series of vision-language models. Lightweight Models (LLaMA 3.2): Targeted resource-constrained edge computing scenarios by introducing smaller models (1B, 3B, etc.) through model compression techniques (like pruning, distillation), achieving a good balance between performance and resource consumption. Fig. 13. Illustration of the overall post-training approach for Llama 3, involving multiple stages and iterative refinement. (Source: Grattafiori et al., 2024)\nAs shown in the figure above, LLaMA 3’s post-training (instruction fine-tuning) process is a carefully designed multi-stage iterative procedure:\nData Preparation: Collect large amounts of human preference data. This data typically includes a prompt and multiple model-generated responses, which annotators rank (e.g., selecting the best “chosen” response and a worse “rejected” response). High-quality SFT data (prompt-response pairs) are also collected.\nReward Modeling (RM): Utilize the collected human preference data triplets (prompt, chosen, rejected) to train one or more reward models. The goal of the reward model is to learn to predict the degree of human preference for model-generated responses, providing a quantitative signal for subsequent optimization. LLaMA 3 trained two separate reward models focusing on Helpfulness and Safety, respectively.\nRejection Sampling: Use the trained reward model(s) to score candidate responses generated by the model. Select the highest-scoring responses as high-quality samples for subsequent fine-tuning stages. This helps filter out samples of higher quality than the initial SFT data.\nSupervised Finetuning (SFT): Combine the initial human-annotated SFT data with the high-quality data filtered through rejection sampling to fine-tune the pre-trained base model. This stage aims to teach the model the format and style of following instructions and to initially grasp the required knowledge and abilities. LLaMA 3 used a mix of data from various sources in this stage.\nPreference Optimization: Starting from the SFT model, use the preference data (prompt, chosen, rejected) to further align the model via the Direct Preference Optimization (DPO) algorithm. DPO directly optimizes the model to increase the likelihood of the “chosen” response while decreasing the likelihood of the “rejected” response. Compared to RL-based PPO methods, it is simpler to implement and more stable to train. LLaMA 3 made improvements to DPO, such as masking special formatting tokens in the responses during DPO training and introducing a normalized negative log-likelihood (NLL) loss as a regularizer to enhance training stability and generation quality. Its loss function form can be roughly referenced from the loss in RPO (Pang et al., 2024), though LLaMA3’s specific implementation might differ slightly:\n$$ \\begin{aligned} \\mathcal{L}_{\\mathrm{DPO}+\\mathrm{NLL}} \u0026 =\\mathcal{L}_{\\mathrm{DPO}}\\left(y^w, y^l \\mid x\\right)+\\alpha \\mathcal{L}_{\\mathrm{NLL}}\\left(y^w \\mid x\\right) \\\\ \u0026 =-\\log \\sigma\\left(\\beta \\log \\frac{\\pi_\\theta(y^w \\mid x)}{\\pi_{\\mathrm{ref}}(y^w \\mid x)}-\\beta \\log \\frac{\\pi_\\theta(y^l \\mid x)}{\\pi_{\\mathrm{ref}}(y^l \\mid x)}\\right)-\\alpha \\frac{\\log \\pi_\\theta(y^w \\mid x)}{|y^w|} \\end{aligned} $$ Where:\n$x$ is the input prompt. $y^w$ is the preferred (winning/chosen) response, $y^l$ is the dispreferred (losing/rejected) response. $\\pi_\\theta$ is the current model policy being optimized (with parameters $\\theta$). $\\pi_{\\mathrm{ref}}$ is the reference model policy (often the SFT model or the model from the previous iteration). $\\beta$ is a hyperparameter controlling the strength of the preference margin. $\\sigma$ is the Sigmoid function. $\\alpha$ is the weight balancing the DPO loss and the NLL regularization loss. $|y^w|$ is the length of the winning response, used to normalize the NLL loss. This loss function encourages the model $\\pi_\\theta$ to prefer generating $y^w$ over $y^l$ relative to the reference model $\\pi_{\\mathrm{ref}}$, while the NLL regularization term helps maintain the fluency and linguistic quality of the generated text. Iterative Loop: The SFT and DPO (or RLHF variant) processes described above are repeated for multiple rounds (LLaMA 3 underwent five rounds). In each round, the model optimized in the previous round is used to generate new data, new human feedback is collected, new reward models are trained, and the next round of SFT and DPO optimization is performed. This iterative approach allows the model to continuously learn and improve.\nModel Weight Averaging: At certain stages, weight averaging might be performed across multiple model checkpoints trained with different data subsets or hyperparameters to obtain a final model that is more robust and has more balanced performance.\nLLaMA 4 The LLaMA 4 (Meta AI, 2025) series of models, released by Meta AI on April 5, 2025, marks the LLaMA ecosystem’s entry into a new phase of natively multimodal AI innovation. This generation introduces the Mixture-of-Experts (MoE) architecture for the first time and possesses unprecedented ultra-long context processing capabilities, aiming to provide more powerful and efficient open-source foundation models.\nModel Overview: Performance, Scale \u0026 Deployment\nLLaMA 4 initially released three models with different positionings, two of which have open weights:\nModel Name Active Params Num Experts Total Params Key Performance/Positioning Hardware Reference Context Window Llama 4 Scout 17B 16 109B Outperforms peer models like Gemma 3; 10M Token ultra-long context; Strong image understanding; High cost-performance Single H100 GPU (INT4 quantized) 10M Llama 4 Maverick 17B 128 400B Matches or surpasses GPT-4o/Gemini 2.0 Flash (reasoning/coding/multilingual); Fewer active params, high computational efficiency; Leading in image reasoning/understanding; LMArena ELO 1417 Single H100 host (multi-GPU) or distributed deployment 1M Llama 4 Behemoth 288B 16 ~2T Teacher Model (Unreleased); Surpasses GPT-4.5/Claude 3.7/Gemini 2.0 Pro on STEM benchmarks (MATH, GPQA); Improves Scout/Maverick via co-distillation Still in training, not publicly released (Not specified) Performance Highlights: Maverick (17B active parameters) demonstrates competitive strength against top-tier closed-source models like GPT-4o on several mainstream benchmarks, especially in reasoning, coding, and multilingual tasks, while having significantly fewer active parameters, reflecting excellent computational efficiency. Scout stands out among its peers with its astounding 10M token context window. Deployment Threshold: Scout’s INT4 quantized version can run on a single H100, lowering the deployment barrier for high-performance models. Although Maverick requires more compute power (e.g., a single H100 multi-GPU host), it still offers attractive cost-performance relative to its capabilities. (Note: Running these models on consumer-grade GPUs remains challenging) Core Architecture \u0026 Training Innovations\nLLaMA 4 features the following optimizations compared to the previous generation:\nMixture-of-Experts (MoE) Architecture:\nLLaMA 4 is the first Llama series to adopt MoE. MoE allows the model to activate only a small fraction of its total parameters (“active parameters”) during inference, achieving larger model capacity and stronger performance with lower computational cost. This is highly beneficial for compute-cost-sensitive (especially throughput-sensitive) inference scenarios. The Maverick model employs alternating dense and MoE layers. Its MoE layers contain 128 routing experts and one shared expert accessed by all tokens. Each token is routed to the shared expert plus one of the routing experts for processing. Native Multimodality \u0026 Early Fusion:\nMoving beyond ‘stitched’ approaches: Unlike previous methods that “bolted on” visual modules to LLMs using late fusion, LLaMA 4 adopts an early fusion strategy from the ground up. Unified Backbone: Text tokens and visual tokens (from image and video frames) are seamlessly integrated and processed together in the early stages of the model’s backbone network. Deep Understanding: This enables joint pre-training on massive amounts of image-text and video data, allowing the model to learn deeper, more fine-grained cross-modal associations, achieve more natural interaction, and exhibit stronger visual grounding capabilities (accurately mapping text prompts to image regions), going beyond simple “image captioning.” Vision Encoder: Based on MetaCLIP (Xu et al., 2023), improved and co-trained with the Llama model to better suit the LLM’s needs. Ultra-Long Context:\n10M Token Limit: Llama 4 Scout achieves an industry-leading 10 million token context window. Technical Underpinnings: iRoPE Architecture: Combines ideas from RoPE (Rotary Position Embeddings) and NoPE (No Positional Encoding). Implemented via interleaved attention layers, where specific layers use NoPE (Kazemnejad et al., 2023), relying on the attention mechanism to implicitly learn positional relationships, while RoPE is still used in most other layers. (The “i” signifies both interleaved and the goal of infinite context). Scalable-Softmax: Combined with inference-time temperature scaling (Nakanishi et al., 2025), enhancing the model’s generalization ability to unseen lengths. Specialized Training: Underwent mid-training and post-training on specially constructed long-context datasets. Scout was trained on 256k context length and generalized to 10M via iRoPE and Scalable Softmax. Practicality Observation: While 10M tokens are appealing, processing such long contexts in practice may encounter issues like inference efficiency, attention diffusion, and bandwidth bottlenecks. Its effectiveness and efficiency in real-world scenarios remain to be validated by users. Fig. 14. Cumulative average NLL loss per sequence position for code generation, demonstrating Llama 4 Scout’s strong performance over long contexts. (Source: Meta AI, 2025)\nLarge-Scale High-Quality Pre-training: Data Scale: Training data exceeds 30 trillion tokens (more than double LLaMA 3), including text, images, and video. Multilingual Coverage: Covers 200 languages, with over 100 languages having more than 1 billion tokens each. Total multilingual token count is 10 times that of LLaMA 3. Training Efficiency: Trained using FP8 precision. Behemoth achieved high utilization of 390 TFLOPs/GPU on 32K GPUs. Utilized MetaP technology to reliably set hyperparameters. Revolutionary Post-training Process\nLLaMA 4 employs a new three-stage post-training process designed to balance instruction following, emergent intelligence, and dialogue quality:\nLightweight SFT (Supervised Fine-Tuning): Focuses on supervised fine-tuning using a small amount of harder datasets to teach the model basic instruction following and dialogue formats, avoiding overfitting simple patterns and preserving space for subsequent RL exploration. Significantly reduced simple SFT data compared to previous versions (Maverick \u003e50%, Behemoth \u003e95%). Online RL (Reinforcement Learning): The key stage for enhancing the model’s core intelligence and complex task capabilities. Employs a continuous online RL strategy where the model learns through interaction with the environment, explores using carefully selected harder prompts, and alternates between model training and data filtering (retaining medium-to-hard interaction data) to balance computation and effectiveness. Lightweight DPO (Direct Preference Optimization): Performed after RL to fine-tune the model’s response style, safety, and correct corner cases, serving as the final “refinement and polishing” step to ensure the unification of intelligence and smooth conversational experience. Teacher Model \u0026 Co-Distillation\nThe powerful Behemoth (2T), though unreleased, transferred its knowledge to Scout and Maverick during the pre-training phase via a novel co-distillation technique. This co-distillation occurred during pre-training, using a new distillation loss function with dynamically weighted soft targets (teacher model’s logits) and hard targets (true labels). This significantly improved the quality of the student models (especially in math, coding, etc.) while amortizing the training cost of the teacher model. Large-Scale RL Infrastructure\nTo train ultra-large MoE models like Behemoth, Meta completely overhauled its RL infrastructure, adopting a fully asynchronous online RL training framework. This optimized MoE parallelism, enabled flexible GPU resource allocation, and achieved nearly a 10x improvement in training efficiency.\nComparison Feature LLaMA 1 LLaMA 2 Code Llama Llama Guard LLaMA 3 LLaMA 4 Release Date 2023/02 2023/07 2023/08 2023/12+ 2024/04+ 2025/04+ Base Model - - LLaMA 2 LLaMA 2 / LLaMA 3 - - Model Scale 7B - 65B 7B, 13B, 70B 7B - 70B 7B / 8B (+Vision) 1B - 405B (+Vision) 109B, 400B, ~2T (MoE) Training Data Size 1T - 1.4T tokens 2T+ tokens + 0.5T/1T Code ~40k Safety Class. 15T+ tokens 30T+ tokens (Multimodal) Context Length 2k tokens 4k tokens 100k tokens 4k / 8k+ 8k / 128k tokens 1M / 10M tokens Tokenizer SentencePiece (32k) SentencePiece (32k) SentencePiece (32k) Based on LLaMA 2/3 tiktoken (128k) tiktoken (256k) Positional Encoding RoPE RoPE RoPE (Base adjusted) RoPE RoPE iRoPE Attention MHA MHA / GQA (34B, 70B) MHA / GQA (\u003e13B) Based on LLaMA 2/3 GQA GQA Normalization RMSNorm (PreNorm) RMSNorm (PreNorm) RMSNorm (PreNorm) RMSNorm (PreNorm) RMSNorm (PreNorm) RMSNorm (PreNorm) Activation Func. SwiGLU SwiGLU SwiGLU SwiGLU SwiGLU SwiGLU Model Type Text Model Text Model Code Generation Safety Classifier Multimodal Model Multimodal Model Key Technology Analysis Below is an analysis of the key technologies widely adopted in the LLaMA series.\nRMS Normalization (RMSNorm) In deep learning model training, normalization layers are crucial for accelerating convergence, improving generalization, and stabilizing the training process. RMSNorm (Root Mean Square Normalization) (Zhang \u0026 Sennrich, 2019) is a simplified variant of Layer Normalization. It normalizes using only the Root Mean Square (RMS) of the inputs, omitting the mean centering step, thus reducing computation.\nIts mathematical expression is: $$ \\text{RMSNorm}(x) = \\frac{x}{\\text{RMS}(x)} \\cdot \\gamma = \\frac{x}{\\sqrt{\\frac{1}{d} \\sum_{i=1}^{d} x_i^2 + \\epsilon}} \\cdot \\gamma $$ Where:\n$ x \\in \\mathbb{R}^d $ is the input vector. $ d $ is the vector dimension. $ \\text{RMS}(x) = \\sqrt{\\frac{1}{d} \\sum_{i=1}^{d} x_i^2 + \\epsilon} $ calculates the root mean square of the input. $ \\epsilon $ is a small positive number (e.g., $10^{-6}$) to prevent division by zero and increase numerical stability. $ \\gamma \\in \\mathbb{R}^d $ is a learnable scaling parameter vector (gain). RMSNorm typically omits the learnable offset parameter (bias) $ \\beta $ found in LayerNorm. Main reasons for LLaMA series choosing RMSNorm:\nHigh Computational Efficiency: Compared to LayerNorm, RMSNorm requires less computation because it doesn’t need to calculate the mean. This is particularly important for computationally intensive large language model training and inference. Comparable Performance: Practice has shown that RMSNorm often achieves performance comparable to or even better than LayerNorm in architectures like Transformers, while maintaining training stability. Simple Implementation: Its computational logic is relatively simple, making it easy to implement efficiently on various hardware. For a comparison of various Norm techniques and code implementations, refer to the blog post: Normalization in Deep Learning.\nFFN_SwiGLU Swish-Gated Linear Unit (SwiGLU) (Shazeer, 2020) is a key technique used in LLaMA to enhance the non-linear expressive capability of the Feed-Forward Network (FFN). SwiGLU combines the Swish activation function with a gating mechanism, significantly improving the model’s expressiveness and performance. Furthermore, unlike the $4d$ hidden dimension used in PaLM (Chowdhery et al., 2022), LLaMA employs a $\\frac{2}{3} \\times 4d$ hidden dimension, achieving higher parameter efficiency while keeping the parameter count and computational load roughly constant.\nMathematical expression: $$ \\operatorname{FFN}_{\\mathrm{SwiGLU}}\\left(x, W_1, W_3, W_2\\right)=\\left(\\operatorname{Swish}\\left(x W_1\\right) \\otimes x W_3\\right) W_2 $$ Where:\n$ \\text{Swish}(x) = x \\cdot \\sigma(x) $ (Swish activation function). $ \\sigma(x) = \\frac{1}{1 + e^{-x}} $ (Sigmoid function). $ \\otimes $ denotes element-wise multiplication. $ W_1, W_2, W_3 $ are linear transformation matrices. Advantages:\nEnhanced Non-linear Expression: By combining the Swish activation function with a gating mechanism, SwiGLU can more effectively capture complex patterns and relationships, boosting the expressive power of the FFN layer. Parameter Efficiency: Using a $\\frac{2}{3} \\times 4d$ hidden dimension allows the introduction of an additional linear transformation matrix while maintaining the total parameter count, leading to efficient parameter utilization. Performance Improvement: FFN_SwiGLU has shown significant performance improvements on various benchmarks, especially excelling in handling complex tasks and long texts. For example, in text generation and understanding tasks, SwiGLU helps the model better grasp context and long-range dependencies. Implementation Details:\nWeight Matrix Adjustment: To maintain the same parameter count and computational load as traditional FFN layers, SwiGLU reduces the hidden layer dimension (e.g., adjusting the hidden size from $4d$ to $\\frac{2}{3} \\times 4d$), ensuring the overall model efficiency is unaffected despite introducing an extra linear transformation matrix. Compatibility: As a member of the GLU family, SwiGLU can be seamlessly integrated into existing Transformer architectures, replacing traditional ReLU or GELU activation functions to enhance overall model performance. For implementation code, refer to this file: swiglu.py.\nGrouped Query Attention (GQA) Grouped Query Attention (GQA) (Ainslie et al., 2023) is a key optimization technique for the standard Multi-Head Attention (MHA) mechanism, particularly applied in large language models like LLaMA. Its primary goal is to reduce the memory bandwidth and capacity required for loading and storing the KV Cache during inference, thereby achieving a better balance between model performance and computational efficiency.\nGQA is a compromise between MHA and Multi-Query Attention (MQA):\nMHA: Has $H$ Query heads, each with its own independent set of $H$ Key (K) and Value (V) projections. Computation and KV Cache size are proportional to the number of heads $H$. MQA: Still has $H$ Query heads, but all heads share a single set of K and V projections. This drastically reduces the KV Cache size (to $1/H$ of MHA’s), but can potentially degrade model quality. GQA: Divides the $H$ Query heads into $G$ groups ($1 \u003c G \u003c H$, and $H$ is a multiple of $G$). The $H/G$ Query heads within each group share the same set of K and V projections. There are a total of $G$ sets of K and V projections. Fig. 15. Overview of Multi-Head Attention (MHA), Multi-Query Attention (MQA), and Grouped-Query Attention (GQA). GQA groups query heads to share key/value heads. (Source: Ainslie et al., 2023)\nThe computation steps are as follows:\nProjection: Input $X$ is still projected to get $Q, K, V$. $Q$ is split into $H$ heads $Q_1, \\dots, Q_H$. $K$ and $V$ are split into $G$ groups $K^1, \\dots, K^G$ and $V^1, \\dots, V^G$. Grouped Attention: For the $g$-th group ($g=1, \\dots, G$), the corresponding Query heads (e.g., $Q_i$ where $i$ belongs to group $g$) compute attention with the shared $K^g$ and $V^g$: $$ \\text{Attention}_i(Q_i, K^g, V^g) = \\text{softmax}\\left( \\frac{Q_i (K^g)^\\top}{\\sqrt{d_k}} \\right) V^g $$ where $d_k$ is the dimension of each K head (and also Q head). Concatenation \u0026 Output: The outputs of all heads $ \\text{Attention}_1, \\dots, \\text{Attention}_H $ are concatenated and then passed through an output projection matrix $W_O$ to get the final output. Advantages:\nBalances Performance and Efficiency: GQA significantly reduces the KV Cache size (to $G/H$ of MHA’s) while typically maintaining model quality closer to MHA than MQA does. Accelerates Inference: Reducing memory bandwidth requirements can significantly speed up inference for large models, especially in long sequence generation scenarios. For a more detailed comparison between MHA, MQA, and GQA attention mechanisms, along with code examples, refer to the blog post: Attention Mechanisms in Transformers: Comparing MHA, MQA, and GQA.\nRotary Positional Embeddings (RoPE) Rotary Positional Embeddings (RoPE) (Su et al., 2021) is an effective method for injecting positional information into the Transformer attention mechanism, particularly adept at encoding relative positional information. Unlike traditional absolute positional encodings (like sinusoidal or learnable embeddings), RoPE achieves this by applying position-dependent rotation operations to the Query and Key vectors.\nFig. 16. Implementation of Rotary Position Embedding(RoPE). (Source: Su et al., 2021)\nAssume $q_m$ and $k_n$ are the Query vector at position $m$ and the Key vector at position $n$, respectively. RoPE treats a $d$-dimensional vector $x$ ($q$ or $k$) as $d/2$ blocks of 2D vectors $[x^{(1)}, x^{(2)}, \\dots, x^{(d/2)}]$, where $x^{(i)} = [x_{2i-1}, x_{2i}]$. For position $m$, RoPE defines a rotation matrix $R_m$ composed of $d/2$ 2D rotation matrices: $$ R_m = \\text{diag}(R_{m,1}, R_{m,2}, \\dots, R_{m,d/2}) $$where each 2D rotation matrix is: $$ R_{m,i} = \\begin{pmatrix} \\cos(m\\theta_i) \u0026 -\\sin(m\\theta_i) \\\\ \\sin(m\\theta_i) \u0026 \\cos(m\\theta_i) \\end{pmatrix} $$The rotation frequencies are $ \\theta_i = b^{-2(i-1)/d} $, where $b$ is a predefined base (typically 10000 in LLaMA).\nAfter applying RoPE, the new Query and Key vectors are $q’_m = R_m q_m$ and $k’_n = R_n k_n$. The key insight is that their inner product (dot product, which determines attention scores) depends only on the relative position $m-n$:\n$$ (q'_m)^\\top k'_n = (R_m q_m)^\\top (R_n k_n) = q_m^\\top R_m^\\top R_n k_n = q_m^\\top R_{n-m} k_n $$This utilizes the property of rotation matrices $R_m^\\top R_n = R_{n-m}$.\nAdvantages:\nExplicit Relative Position Encoding: The inner product result directly depends on the relative distance $m-n$, which is very natural for capturing relationships between elements in a sequence. Long-Distance Decay Property: As the relative distance $|m-n|$ increases, the change in angle between vectors due to rotation typically causes the inner product value to decay, aligning with the intuition that more distant elements have weaker correlations. Good Extrapolation: Theoretically, RoPE can generalize better to sequence lengths longer than those seen during training because it doesn’t rely on a maximum absolute position. Adjusting the base $b$ (as in Code Llama and LLaMA 4’s iRoPE) can further optimize its performance on ultra-long contexts. No Extra Parameters: RoPE is a fixed, position-based transformation that introduces no additional learnable parameters. Compatibility with Linear Attention: It can be used in conjunction with various linear attention variants. Mixture-of-Experts (MoE) Mixture-of-Experts (MoE) is a neural network architecture paradigm designed to increase model capacity (total parameters) while controlling computational cost (active parameters). It replaces certain layers in the network (typically FFN layers) with multiple parallel expert subnetworks. A lightweight gating network dynamically selects a small number (usually Top-K, with K=1 or 2) of these experts for each input token to perform computation.\nFig. 17. The Illustration of a mixture-of-experts(MoE) in llama4. (Source: Meta AI, 2025)\nAssume an MoE layer has $N$ experts $E_1, E_2, \\dots, E_N$ (e.g., each expert is an independent FFN) and a gating network $G$. For an input token $x$, the computation process of the MoE layer is as follows:\nGating Calculation: The gating network $G$ (often a simple linear layer followed by Softmax) computes the probability or weight for selecting each expert: $p = G(x) = \\text{Softmax}(\\text{Linear}(x))$, where $p \\in \\mathbb{R}^N$. Expert Selection (Top-K Routing): Based on the gating output $p$, the K experts with the highest scores are selected. Let the set of selected expert indices be $\\mathcal{T} = \\text{TopKIndices}(p)$. Expert Computation: Only the selected K experts compute on the input $x$, yielding outputs $E_i(x)$ for $i \\in \\mathcal{T}$. Output Combination: The final output $y$ is the weighted sum of the outputs from the selected experts, using their gating weights (often re-normalized): $$ y = \\sum_{i \\in \\mathcal{T}} \\frac{p_i}{\\sum_{j \\in \\mathcal{T}} p_j} \\cdot E_i(x) $$ Alternatively, in some implementations, the weights $p_i$ might be used directly. Advantages:\nDecoupling Parameters and Computation: MoE allows models to have a massive total parameter count (by increasing the number of experts $N$), but the computational cost of each forward pass depends only on the computation of the activated K experts, which is much lower than that of a dense model with an equivalent total parameter count. This enables training larger capacity, potentially higher-performing models within a limited computational budget. Expert Specialization: Theoretically, different experts can learn to handle specific aspects of different types of data, patterns, or tasks, enabling modular storage and processing of knowledge, thereby enhancing the model’s overall capability and generalization. Challenges:\nLoad Balancing: Ensuring that all experts are utilized roughly equally is necessary to avoid some experts being overloaded while others remain idle. This often requires introducing auxiliary loss functions (like Load Balancing Loss) to encourage uniform routing. Communication Overhead: In distributed training and inference, efficient communication (e.g., All-to-All) is needed between different devices (GPUs) to route tokens to the devices storing the corresponding experts and to gather the results. This increases implementation complexity and communication costs. Training Stability: Training MoE models can be less stable than training dense models, requiring careful tuning of hyperparameters and training strategies. Memory Footprint: Although computation is sparse, the total number of parameters is huge, requiring substantial memory to store all expert weights. For a more detailed explanation of MoE, refer to the Mixture-of-Experts section in the blog post: Parallelism and Memory Optimization Techniques for Training Large Models.\nReferences [1] Touvron, Hugo, et al. “LLaMA: Open and Efficient Foundation Language Models.” arXiv preprint arXiv:2302.13971 (2023).\n[2] Facebook Research. “xformers.” GitHub repository (Accessed 2024).\n[3] Taori, Rohan, et al. “Alpaca: A Strong, Replicable Instruction-Following Model.” Stanford CRFM Blog (2023).\n[4] Touvron, Hugo, et al. “Llama 2: Open Foundation and Fine-Tuned Chat Models.” arXiv preprint arXiv:2307.09288 (2023).\n[5] Bai, Yuntao, et al. “Constitutional AI: Harmlessness from AI Feedback.” arXiv preprint arXiv:2212.08073 (2022).\n[6] Roziere, Baptiste, et al. “Code Llama: Open Foundation Models for Code.” arXiv preprint arXiv:2308.12950 (2023).\n[7] Inan, Hakan, et al. “Llama Guard: LLM-based Input-Output Safeguard for Human-AI Conversations.” arXiv preprint arXiv:2312.06674 (2023).\n[8] Chi, Jianfeng, et al. “Llama Guard 3 Vision: Safeguarding Human-AI Image Understanding Conversations.” arXiv preprint arXiv:2411.10414 (2024).\n[9] Vidgen, Bertie, et al. “Introducing v0.5 of the AI Safety Benchmark from MLCommons.” arXiv preprint arXiv:2404.12241 (2024).\n[10] Meta Llama. “Llama-Guard-3-8B.” Hugging Face Model (Accessed 2024).\n[11] Grattafiori, Aaron, et al. “The Llama 3 Herd of Models.” arXiv preprint arXiv:2407.21783 (2024).\n[12] Meta AI. “Introducing Llama 3.1: Our most capable models to date.” Meta AI Blog (2024).\n[13] Umar Jamil. “pytorch-llama Slides.” GitHub file (Accessed 2024).\n[14] Pang, Richard Yuanzhe, et al. “Iterative reasoning preference optimization.” Advances in Neural Information Processing Systems 37 (2024): 116617-116637.\n[15] Meta AI. “The Llama 4 herd: The beginning of a new era of natively multimodal AI innovation” Meta AI Blog (2025).\n[16] Xu, Hu, et al. “Demystifying clip data.” arXiv preprint arXiv:2309.16671 (2023).\n[17] Kazemnejad, Amirhossein, et al. “The impact of positional encoding on length generalization in transformers.” Advances in Neural Information Processing Systems 36 (2023): 24892-24928.\n[18] Nakanishi, Ken M. “Scalable-Softmax Is Superior for Attention.” arXiv preprint arXiv:2501.19399 (2025).\n[19] Zhang, Biao, and Rico Sennrich. “Root mean square layer normalization.” Advances in Neural Information Processing Systems 32 (2019).\n[20] Shazeer, Noam. “Glu variants improve transformer.” arXiv preprint arXiv:2002.05202 (2020).\n[21] Ainslie, Joshua, et al. “Gqa: Training generalized multi-query transformer models from multi-head checkpoints.” arXiv preprint arXiv:2305.13245 (2023).\n[22] Su, Jianlin, et al. “Roformer: Enhanced transformer with rotary position embedding.” Neurocomputing 568 (2024): 127063.\nCitation Citation: When reproducing or citing the content of this article, please indicate the original author and source.\nCited as:\nYue Shui. (Apr 2025). The LLaMA Herd. https://syhya.github.io/posts/2025-04-06-llama\nOr\n@article{syhya2025llama, title = \"The LLaMA Herd\", author = \"Yue Shui\", journal = \"syhya.github.io\", year = \"2025\", month = \"Apr\", url = \"https://syhya.github.io/posts/2025-04-06-llama\" } ","wordCount":"6862","inLanguage":"en","image":"https://syhya.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-04-06T12:00:00+08:00","dateModified":"2025-06-29T21:43:56+08:00","author":{"@type":"Person","name":"Yue Shui"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://syhya.github.io/posts/2025-04-06-llama/"},"publisher":{"@type":"Organization","name":"Yue Shui Blog","logo":{"@type":"ImageObject","url":"https://syhya.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://syhya.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://syhya.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://syhya.github.io/zh/ title=简体中文 aria-label=简体中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://syhya.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://syhya.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://syhya.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://syhya.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://syhya.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">The LLaMA Herd</h1><div class=post-meta><span title='2025-04-06 12:00:00 +0800 +0800'>2025-04-06</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;6862 words&nbsp;·&nbsp;Yue Shui&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://syhya.github.io/zh/posts/2025-04-06-llama/>Zh</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#llama>LLaMA</a><ul><li><a href=#llama-1>LLaMA 1</a></li><li><a href=#llama-2>LLaMA 2</a></li><li><a href=#code-llama>Code Llama</a></li><li><a href=#llama-guard>Llama Guard</a></li><li><a href=#llama-guard-3-vision>Llama Guard 3 Vision</a></li><li><a href=#llama-3>LLaMA 3</a></li><li><a href=#llama-4>LLaMA 4</a></li><li><a href=#comparison>Comparison</a></li></ul></li><li><a href=#key-technology-analysis>Key Technology Analysis</a><ul><li><a href=#rms-normalization-rmsnorm>RMS Normalization (RMSNorm)</a></li><li><a href=#ffn_swiglu>FFN_SwiGLU</a></li><li><a href=#grouped-query-attention-gqa>Grouped Query Attention (GQA)</a></li><li><a href=#rotary-positional-embeddings-rope>Rotary Positional Embeddings (RoPE)</a></li><li><a href=#mixture-of-experts-moe>Mixture-of-Experts (MoE)</a></li></ul></li><li><a href=#references>References</a></li><li><a href=#citation>Citation</a></li></ul></nav></div></details></div><div class=post-content><h2 id=llama>LLaMA<a hidden class=anchor aria-hidden=true href=#llama>#</a></h2><p>The LLaMA series of open-source models released by Meta AI has become one of the cornerstones of the large language model community, profoundly impacting the advancement of open research and applications. From the pioneering LLaMA released in early 2023, to the significantly improved LLaMA 2 later that year, to derivative models targeting specific domains (like code, safety), and the subsequent new generations LLaMA 3 and LLaMA 4 launched in 2024 and 2025 respectively, Meta has continuously committed to enhancing the performance of open-source models, gradually bringing them closer to state-of-the-art closed-source models. Below, we will introduce the key technical details of each major model in sequence.</p><h3 id=llama-1>LLaMA 1<a hidden class=anchor aria-hidden=true href=#llama-1>#</a></h3><p><strong>LLaMA 1</strong> (<a href=https://arxiv.org/abs/2302.13971>Touvron et al., 2023a</a>), released in February 2023, was Meta&rsquo;s first series of open-source foundation language models. LLaMA was offered in four parameter sizes: 7B, 13B, 33B, and 65B. Its core characteristic was being trained entirely on <strong>publicly available datasets</strong>, without relying on any proprietary data. Despite having a significantly smaller parameter count than the contemporary GPT-3 (175B), the LLaMA 13B model outperformed GPT-3 on most benchmarks, while the 65B model achieved performance comparable to top models like Chinchilla-70B and PaLM-540B.</p><figure class=align-center><img loading=lazy src=llama1_benchmark.png#center alt="Fig. 1. Zero-shot performance of LLaMA models on Common Sense Reasoning tasks compared to other foundation models. (Source: Touvron et al., 2023a)" width=100%><figcaption><p>Fig. 1. Zero-shot performance of LLaMA models on Common Sense Reasoning tasks compared to other foundation models. (Source: <a href=https://arxiv.org/abs/2302.13971>Touvron et al., 2023a</a>)</p></figcaption></figure><p><strong>Training Data:</strong> LLaMA 1 was trained on large-scale public corpora. The 65B and 33B models used approximately <strong>1.4 trillion tokens</strong>, while the 7B and 13B models used about <strong>1 trillion tokens</strong>. The corpus sources were diverse, primarily including Common Crawl, C4, GitHub, Wikipedia, Books, ArXiv, and StackExchange, covering multiple domains and about 20 languages (predominantly English).</p><p><strong>Architecture Design:</strong> LLaMA 1 employed a standard Transformer decoder architecture, incorporating the following key improvements to enhance performance and training efficiency:</p><ul><li><strong>Pre-normalization & RMSNorm:</strong> Adopted a <strong>Pre-normalization</strong> structure (applying normalization before each sub-layer input) and used <strong>RMSNorm (Root Mean Square Normalization)</strong> instead of standard LayerNorm. RMSNorm reduces computational complexity by omitting the mean centering step, scaling based only on the root mean square of the vector elements, while effectively maintaining training stability.</li><li><strong>SwiGLU Activation Function:</strong> Replaced the activation function in the feed-forward network (FFN) from ReLU to <strong>SwiGLU (Swish-Gated Linear Unit)</strong>. SwiGLU combines the smooth non-linearity of the Swish activation function with a gating mechanism, enhancing the model&rsquo;s expressive power. Concurrently, LLaMA adjusted the FFN&rsquo;s hidden layer dimension (using $ \frac{2}{3} \times 4d $ instead of the standard $4d$, where $d$ is the model dimension) to roughly maintain the total parameter count and computational load of the FFN layer while introducing gating parameters.</li><li><strong>RoPE Rotary Position Embeddings:</strong> Utilized <strong>Rotary Position Embeddings (RoPE)</strong> for positional encoding. RoPE effectively incorporates relative positional information into self-attention calculations by applying position-dependent rotation operations to Query and Key vectors, enhancing the model&rsquo;s ability to handle long sequences and capture long-range dependencies. LLaMA 1 had a maximum context length of 2048 tokens.</li><li><strong>Efficient Attention Implementation:</strong> Leveraged Meta&rsquo;s open-source <a href=https://github.com/facebookresearch/xformers>xformers</a> library to implement a memory-efficient and computationally optimized causal multi-head attention mechanism.</li></ul><p><strong>Fine-tuned Dialogue Models:</strong> At its release, LLaMA 1 primarily provided pre-trained model weights (with restricted commercial use) and did not include an official dialogue fine-tuned version. However, the open-source community quickly explored its potential. For instance, the <strong>Stanford Alpaca</strong> (<a href=https://crfm.stanford.edu/2023/03/13/alpaca.html>Taori et al., 2023</a>) project demonstrated that Supervised Fine-tuning (SFT) with only a small amount of instruction data could endow the LLaMA base model with strong conversational abilities, greatly promoting the research and application ecosystem of open-source LLMs.</p><figure class=align-center><img loading=lazy src=alpaca.png#center alt="Fig. 2. The pipeline for generating instruction-following demonstrations and training Alpaca 7B based on LLaMA 7B. (Source: Taori et al., 2023)" width=100%><figcaption><p>Fig. 2. The pipeline for generating instruction-following demonstrations and training Alpaca 7B based on LLaMA 7B. (Source: <a href=https://crfm.stanford.edu/2023/03/13/alpaca.html>Taori et al., 2023</a>)</p></figcaption></figure><p><strong>Training Stability & Loss Spikes</strong></p><figure class=align-center><img loading=lazy src=llama1_train_loss.png#center alt="Fig. 3. Training loss curves over processed tokens for the LLaMA 7B, 13B, 33B, and 65B models. (Source: Touvron et al., 2023a)" width=80%><figcaption><p>Fig. 3. Training loss curves over processed tokens for the LLaMA 7B, 13B, 33B, and 65B models. (Source: <a href=https://arxiv.org/abs/2302.13971>Touvron et al., 2023a</a>)</p></figcaption></figure><p>As observed in Figure 3, the training loss of LLaMA models generally shows a downward trend, indicating relatively stable training. However, during the training of the 13B, 33B, and 65B models, <strong>Loss Spikes</strong> occurred, where the training loss suddenly and abnormally surged at certain points. The larger the model scale, the more pronounced the spike phenomenon seems to be, and it might occur multiple times during training.</p><ul><li><strong>Phenomenon Description:</strong> A Loss Spike refers to a brief, sharp, and abnormal increase in the loss function value during model training.</li><li><strong>Potential Causes:</strong> Often related to multiple factors, including <strong>anomalous samples or distribution shifts</strong> in the training data, <strong>improper learning rate settings</strong> (too high or issues with decay strategy), <strong>interaction between the optimizer&rsquo;s internal state (like Adam) and drastic gradient changes</strong>, and <strong>numerical instability in mixed-precision training</strong> (e.g., gradient overflow or underflow).</li><li><strong>Common Mitigation Strategies:</strong> Methods to resolve or mitigate Loss Spikes include: strengthening data cleaning and preprocessing; applying <strong>Gradient Clipping</strong> to limit the gradient norm; fine-tuning learning rate scheduling strategies (like Warmup, Decay); optimizing mixed-precision training configurations; and, after a spike occurs, resuming training from the nearest checkpoint, possibly skipping the specific data batch that caused the issue.</li></ul><h3 id=llama-2>LLaMA 2<a hidden class=anchor aria-hidden=true href=#llama-2>#</a></h3><p><strong>LLaMA 2</strong> (<a href=https://arxiv.org/abs/2307.09288>Touvron et al., 2023b</a>), launched in July 2023, was a significant upgrade to LLaMA 1. Compared to the first generation, LLaMA 2 featured notable improvements in model scale, training data volume, context length, and model alignment. It also marked the first release of an official dialogue-optimized version, <strong>LLaMA 2-Chat</strong>, and came with a license permitting commercial use.</p><p><strong>Architecture & Optimization:</strong> LLaMA 2&rsquo;s base architecture largely inherited the successful design of LLaMA 1 (e.g., RMSNorm, SwiGLU, RoPE). Key technical updates included:</p><ul><li><strong>Grouped Query Attention (GQA):</strong> For the larger <strong>34B and 70B models</strong>, <strong>Grouped Query Attention (GQA)</strong> was adopted. GQA is a compromise between Multi-Head Attention (MHA) and Multi-Query Attention (MQA), allowing multiple Query heads to share the same set of Key and Value heads. This significantly reduces the memory footprint and computational overhead of the KV cache during inference, thereby improving the inference speed and deployment efficiency of large models with minimal impact on performance.</li><li><strong>Increased Context Length:</strong> The maximum context length of the model was extended from LLaMA 1&rsquo;s 2048 tokens to <strong>4096 tokens</strong>. This enabled the model to process longer text inputs, enhancing its capabilities in tasks like long-document question answering, summarization, and extended conversations.</li></ul><p><strong>Training Data & Scale:</strong> LLaMA 2 was trained on a larger pre-training dataset, totaling approximately <strong>2 trillion tokens</strong>, about a 40% increase compared to LLaMA 1. The data sources were more diverse, and underwent more rigorous filtering and cleaning.</p><p><strong>Post-Training (LLaMA 2-Chat):</strong> <strong>LLaMA 2-Chat</strong> is a meticulously aligned dialogue model. Its training process starts with the LLaMA 2 pre-trained base model and primarily involves the following stages:</p><ol><li><strong>Supervised Fine-tuning (SFT):</strong> The pre-trained model is fine-tuned using high-quality instruction and dialogue samples, initially equipping it with the ability to follow instructions and engage in dialogue.</li><li><strong>Reinforcement Learning from Human Feedback (RLHF):</strong> This is a crucial step for enhancing the model&rsquo;s Helpfulness and Safety.<ul><li><strong>Reward Modeling:</strong> A large amount of human preference data is collected (i.e., ranking multiple responses generated by the model). One or more reward models are trained to learn to evaluate which response better aligns with human preferences (along dimensions of helpfulness and safety).</li><li><strong>RL Optimization:</strong> Using the trained reward model(s) as a reward signal, the SFT model is further optimized using <strong>PPO</strong> and <strong>Rejection Sampling</strong>. PPO aims to maximize the reward signal, while rejection sampling further improves model quality by selecting the highest-reward response from K samples generated by the model for gradient updates. This process is typically iterative, continually collecting new preference data to refine the reward model and the dialogue model itself. It drew inspiration from Anthropic&rsquo;s Constitutional AI and HH-RLHF (<a href=https://arxiv.org/abs/2212.08073>Bai et al., 2022</a>). The relevant <a href=https://huggingface.co/datasets/Anthropic/hh-rlhf>HH-RLHF dataset</a> is available on Hugging Face.</li></ul></li></ol><figure class=align-center><img loading=lazy src=llama2_chat_rlhf.png#center alt="Fig. 4. Illustration of the Llama 2-Chat fine-tuning process, including SFT and RLHF stages with rejection sampling and PPO. (Source: Touvron et al., 2023b)" width=100%><figcaption><p>Fig. 4. Illustration of the Llama 2-Chat fine-tuning process, including SFT and RLHF stages with rejection sampling and PPO. (Source: <a href=https://arxiv.org/abs/2307.09288>Touvron et al., 2023b</a>)</p></figcaption></figure><h3 id=code-llama>Code Llama<a hidden class=anchor aria-hidden=true href=#code-llama>#</a></h3><p><strong>Code Llama</strong> (<a href=https://arxiv.org/abs/2308.12950>Rozière et al., 2023</a>), released by Meta in August 2023, is a family of large language models built upon LLaMA 2, specifically <strong>focused on coding capabilities</strong>. Through additional continued pre-training on massive amounts of programming code data and specific task fine-tuning, Code Llama demonstrates excellent capabilities in code generation, code completion, code understanding, and debugging.</p><figure class=align-center><img loading=lazy src=codellama.png#center alt="Fig. 5. The Code Llama specialization pipeline, starting from Llama 2 and involving code-specific training stages. (Source: Rozière et al., 2023)" width=100%><figcaption><p>Fig. 5. The Code Llama specialization pipeline, starting from Llama 2 and involving code-specific training stages. (Source: <a href=https://arxiv.org/abs/2308.12950>Rozière et al., 2023</a>)</p></figcaption></figure><p><strong>Training & Data:</strong> Code Llama started with LLaMA 2 weights and underwent continued pre-training on <strong>500 billion tokens</strong> of code and code-related natural language corpora (for 7B/13B/34B versions) or <strong>1 trillion tokens</strong> (for the 70B version). Training data primarily came from public code repositories and datasets. Key technical improvements include:</p><ul><li><strong>Long Context Fine-tuning (LCFT):</strong> Code Llama paid special attention to long sequence processing during training, extending the sequence length to <strong>16k tokens</strong>. To better handle long-range dependencies, the base period $\theta$ of RoPE positional encoding was adjusted (increased from LLaMA 2&rsquo;s 10,000 to 1,000,000), slowing down the decay of attention scores as the token distance increases. This allows the model to stably handle ultra-long contexts of up to <strong>100k tokens</strong> during inference.</li></ul><figure class=align-center><img loading=lazy src=codellama_rope.png#center alt="Fig. 6. Effect of RoPE base period scaling on perplexity for long sequences, showing improved performance with a larger base. (Source: Rozière et al., 2023)" width=70%><figcaption><p>Fig. 6. Effect of RoPE base period scaling on perplexity for long sequences, showing improved performance with a larger base. (Source: <a href=https://arxiv.org/abs/2308.12950>Rozière et al., 2023</a>)</p></figcaption></figure><ul><li><strong>Fill-in-the-Middle (FIM):</strong> The training incorporated the <strong>Fill-in-the-Middle</strong> task. The model needs to insert appropriate code snippets given a code prefix and suffix. This capability is crucial for code completion features in Integrated Development Environments (IDEs).</li></ul><p><strong>Model Variants:</strong> Code Llama offers several versions to meet the needs of different scenarios:</p><ul><li><strong>Code Llama (Base):</strong> The foundational code model, adept at code completion and generating code from natural language.</li><li><strong>Code Llama - Python:</strong> Built upon the base model, specialized fine-tuning on an additional 100 billion tokens of Python code significantly enhances performance on Python-related tasks.</li><li><strong>Code Llama - Instruct:</strong> Fine-tuned on code-related instructions and human feedback data (approx. 5 billion tokens), enabling it to better understand natural language instructions to generate, explain, or modify code, making it more suitable as a code assistant.</li></ul><p>Each version is available in 7B, 13B, 34B, and 70B parameter sizes.</p><h3 id=llama-guard>Llama Guard<a hidden class=anchor aria-hidden=true href=#llama-guard>#</a></h3><p><strong>Llama Guard</strong> (<a href=https://arxiv.org/abs/2312.06674>Inan et al., 2023</a>), introduced by Meta in December 2023, is a model specifically designed for safeguarding the content of human-AI conversations. It aims to perform content review and risk classification for both user inputs (prompts) and model outputs (responses).</p><figure class=align-center><img loading=lazy src=llama_guard.png#center alt="Fig. 7. Example task instructions for the Llama Guard prompt and response classification tasks, demonstrating its safety assessment capability. (Source: Inan et al., 2023)" width=100%><figcaption><p>Fig. 7. Example task instructions for the Llama Guard prompt and response classification tasks, demonstrating its safety assessment capability. (Source: <a href=https://arxiv.org/abs/2312.06674>Inan et al., 2023</a>)</p></figcaption></figure><p><strong>Model Overview:</strong> Llama Guard is based on the LLaMA 2-7B model and is specifically trained via <strong>instruction fine-tuning</strong> for the task of <strong>safety risk classification</strong>. It is not a generative model; instead, it takes a text input, determines if its content is safe, and can output specific risk category labels based on a predefined safety risk taxonomy.</p><p><strong>Training & Taxonomy:</strong> Meta constructed a taxonomy containing various categories of unsafe content (e.g., violence, hate speech, sexual content, promotion of illegal acts) and collected high-quality labeled data for training. Llama Guard can perform multi-label classification, identifying potentially multiple risks present in the text simultaneously. Due to its instruction fine-tuning paradigm, users can flexibly adjust safety policies or customize classification standards by designing different prompts. Llama Guard can be deployed as a filter at the input end (detecting user input risks) and the output end (detecting risks in model-generated content) of a dialogue system.</p><h3 id=llama-guard-3-vision>Llama Guard 3 Vision<a hidden class=anchor aria-hidden=true href=#llama-guard-3-vision>#</a></h3><p><strong>Llama Guard 3 Vision</strong> (<a href=https://arxiv.org/abs/2411.10414>Chi et al., 2024</a>) is the multimodal upgraded version of Llama Guard, built upon the <strong>Llama-3.2-Vision</strong> model. It can simultaneously assess the safety risks of both <strong>image and text</strong> content, extending safety protection capabilities to multimodal scenarios. The model uses a special <code>&lt;|image|></code> token to integrate image information for unified multimodal safety review.</p><figure class=align-center><img loading=lazy src=llama_guard_vision.png#center alt="Fig. 8. Llama Guard 3 Vision classifying harmful content in a multimodal response classification task involving both image and text. (Source: Chi et al., 2024)" width=100%><figcaption><p>Fig. 8. Llama Guard 3 Vision classifying harmful content in a multimodal response classification task involving both image and text. (Source: <a href=https://arxiv.org/abs/2411.10414>Chi et al., 2024</a>)</p></figcaption></figure><p>Llama Guard 3 Vision adopts the safety risk classification standard defined by ML Commons (<a href=https://arxiv.org/abs/2404.12241>Vidgen et al., 2024</a>) and expands upon it, adding detection for code interpreter abuse risks (Category S14).</p><figure class=align-center><img loading=lazy src=hazard_categories.png#center alt="Fig. 9. The 14 hazard categories used by Llama Guard 3 Vision, based on the MLCommons taxonomy with an added category for code interpreter abuse. (Source: Meta Llama, 2024)" width=60%><figcaption><p>Fig. 9. The 14 hazard categories used by Llama Guard 3 Vision, based on the MLCommons taxonomy with an added category for code interpreter abuse. (Source: <a href=https://huggingface.co/meta-llama/Llama-Guard-3-8B>Meta Llama, 2024</a>)</p></figcaption></figure><p>Benchmark results show that Llama Guard 3 Vision outperforms advanced models like GPT-4o and GPT-4o mini on multiple metrics within the MLCommons safety benchmark, both for detecting risks in user inputs and model outputs.</p><figure class=align-center><img loading=lazy src=ml_commons_benchmark.png#center alt="Fig. 10. Performance comparison of various models on the MLCommons hazard taxonomy internal test set, showing Llama Guard 3 Vision&rsquo;s strong results. (Source: Chi et al., 2024)" width=100%><figcaption><p>Fig. 10. Performance comparison of various models on the MLCommons hazard taxonomy internal test set, showing Llama Guard 3 Vision&rsquo;s strong results. (Source: <a href=https://arxiv.org/abs/2411.10414>Chi et al., 2024</a>)</p></figcaption></figure><h3 id=llama-3>LLaMA 3<a hidden class=anchor aria-hidden=true href=#llama-3>#</a></h3><p><strong>LLaMA 3</strong> (<a href=https://arxiv.org/abs/2407.21783>Grattafiori et al., 2024</a>) is the new generation of open-source large model series successively released by Meta starting from April 2024. It features optimizations in performance, scale, multilingual capabilities, multimodal support, and training efficiency.</p><p><strong>Model Scale & Version Evolution:</strong> The LLaMA 3 series covers a wide range of parameter scales, from small to ultra-large:</p><ul><li><strong>LLaMA 3 (Initial Release, 2024/04):</strong> First released 8B and 70B scale pre-trained and instruction fine-tuned models.</li><li><strong>LLaMA 3.1 (2024/07):</strong> (<a href=https://ai.meta.com/blog/meta-llama-3-1/>Meta AI, 2024</a>) Introduced the <strong>405B</strong> parameter flagship model, with performance approaching GPT-4 levels on multiple benchmarks, along with updated 8B and 70B versions.</li><li><strong>LLaMA 3.2 (2024/10):</strong> Introduced <strong>lightweight models</strong> (e.g., 1B, 3B, 11B, 13B) optimized for edge devices (like phones, watches, smart homes), and released <strong>multimodal vision models</strong> (e.g., Llama-3.2-11B-Vision and Llama-3.2-90B-Vision).</li></ul><figure class=align-center><img loading=lazy src=llama3_key_hyperparameters.png#center alt="Fig. 11. Overview of the key hyperparameters for Llama 3 models of different scales. (Source: Grattafiori et al., 2024)" width=70%><figcaption><p>Fig. 11. Overview of the key hyperparameters for Llama 3 models of different scales. (Source: <a href=https://arxiv.org/abs/2407.21783>Grattafiori et al., 2024</a>)</p></figcaption></figure><p>From the figure above, it can be observed that training larger-scale LLMs typically requires using smaller peak learning rates. This is primarily due to:</p><ol><li><strong>Optimization Landscape Complexity and Gradient Stability:</strong> Larger parameter counts lead to more complex and non-convex loss landscapes, making the model more sensitive to parameter updates. Smaller learning rates help limit the step size of each update, avoiding excessively large gradients in steep regions that could lead to training oscillations or divergence, thus ensuring a more stable convergence process.</li><li><strong>Avoiding Overfitting and Improving Generalization:</strong> Larger models have greater capacity and are more prone to overfitting the training data. Smaller learning rates allow the model to learn patterns in the data more slowly and robustly, reducing the risk of overfitting to noise or local features in the training data, which helps improve generalization performance on unseen data.</li><li><strong>Fine-grained Search and Parameter Adjustment:</strong> In high-dimensional parameter spaces, the optimal solution might reside in narrow regions. Small learning rates enable the optimization algorithm to perform a finer search, gradually approaching the optimum and avoiding &ldquo;overshooting&rdquo; the optimal region due to large step sizes, potentially leading to higher final model accuracy.</li></ol><figure class=align-center><img loading=lazy src=llama3_architecture.png#center alt="Fig. 12. Comparison of the high-level architecture between Llama 2 and Llama 3. (Source: Umar Jamil&rsquo;s PyTorch Llama Slides)" width=70%><figcaption><p>Fig. 12. Comparison of the high-level architecture between Llama 2 and Llama 3. (Source: <a href=https://github.com/hkproj/pytorch-llama/blob/main/Slides.pdf>Umar Jamil&rsquo;s PyTorch Llama Slides</a>)</p></figcaption></figure><p><strong>Architecture & Technical Innovations:</strong> LLaMA 3 incorporates several significant enhancements over LLaMA 2:</p><ul><li><strong>Massive Pre-training Data:</strong> The pre-training data volume reached a staggering <strong>15 trillion tokens</strong>, 7.5 times that of LLaMA 2. Data sources were broader, of higher quality, more diverse, and significantly increased the proportion of non-English languages (e.g., German, French, Spanish, Hindi, each >5% of total data) and code data.</li><li><strong>Optimized Tokenizer:</strong> Employed a new tokenizer implemented based on the <code>tiktoken</code> library, with the <strong>vocabulary size drastically expanded from LLaMA 2&rsquo;s 32k to 128k</strong>. The larger vocabulary improves encoding efficiency for multiple languages (especially non-Latin scripts) and code, reducing input sequence length by about 15% on average, thereby indirectly boosting model processing efficiency and performance.</li><li><strong>Extended Context Length:</strong> The initial LLaMA 3 release (8B, 70B) supported an 8k token context window. <strong>LLaMA 3.1 (405B) further increased the maximum context window to 128k tokens</strong>, greatly enhancing the model&rsquo;s ability to handle long documents, long conversation histories, and complex contextual reasoning. This is typically achieved through techniques like RoPE frequency adjustments and attention mechanism optimizations (e.g., FlashAttention).</li><li><strong>Universally Applied GQA:</strong> Unlike LLaMA 2, which only used GQA in larger models, <strong>all scales of LLaMA 3 models (including 8B) adopted Grouped Query Attention (GQA)</strong> to optimize memory usage and computation speed during inference.</li><li><strong>Advanced Alignment Techniques:</strong> During the instruction fine-tuning (Post-training) phase, LLaMA 3 combined multiple advanced techniques, including Supervised Fine-tuning (SFT), Rejection Sampling, and Direct Preference Optimization (DPO), aiming to comprehensively improve the model&rsquo;s instruction-following ability, Helpfulness, and Safety.</li><li><strong>Multimodal Integration (LLaMA 3.2):</strong> Introduced a Vision Encoder and performed joint training to achieve fusion processing of images and text, leading to the Llama-3.2-Vision series of vision-language models.</li><li><strong>Lightweight Models (LLaMA 3.2):</strong> Targeted resource-constrained edge computing scenarios by introducing smaller models (1B, 3B, etc.) through model compression techniques (like pruning, distillation), achieving a good balance between performance and resource consumption.</li></ul><figure class=align-center><img loading=lazy src=llama3_post_training.png#center alt="Fig. 13. Illustration of the overall post-training approach for Llama 3, involving multiple stages and iterative refinement. (Source: Grattafiori et al., 2024)" width=100%><figcaption><p>Fig. 13. Illustration of the overall post-training approach for Llama 3, involving multiple stages and iterative refinement. (Source: <a href=https://arxiv.org/abs/2407.21783>Grattafiori et al., 2024</a>)</p></figcaption></figure><p>As shown in the figure above, LLaMA 3&rsquo;s post-training (instruction fine-tuning) process is a carefully designed multi-stage iterative procedure:</p><ol><li><p><strong>Data Preparation:</strong> Collect large amounts of human preference data. This data typically includes a prompt and multiple model-generated responses, which annotators rank (e.g., selecting the best &ldquo;chosen&rdquo; response and a worse &ldquo;rejected&rdquo; response). High-quality SFT data (prompt-response pairs) are also collected.</p></li><li><p><strong>Reward Modeling (RM):</strong> Utilize the collected human preference data triplets (prompt, chosen, rejected) to train one or more reward models. The goal of the reward model is to learn to predict the degree of human preference for model-generated responses, providing a quantitative signal for subsequent optimization. LLaMA 3 trained two separate reward models focusing on Helpfulness and Safety, respectively.</p></li><li><p><strong>Rejection Sampling:</strong> Use the trained reward model(s) to score candidate responses generated by the model. Select the highest-scoring responses as high-quality samples for subsequent fine-tuning stages. This helps filter out samples of higher quality than the initial SFT data.</p></li><li><p><strong>Supervised Finetuning (SFT):</strong> Combine the initial human-annotated SFT data with the high-quality data filtered through rejection sampling to fine-tune the pre-trained base model. This stage aims to teach the model the format and style of following instructions and to initially grasp the required knowledge and abilities. LLaMA 3 used a mix of data from various sources in this stage.</p></li><li><p><strong>Preference Optimization:</strong> Starting from the SFT model, use the preference data (prompt, chosen, rejected) to further align the model via the <strong>Direct Preference Optimization (DPO)</strong> algorithm. DPO directly optimizes the model to increase the likelihood of the &ldquo;chosen&rdquo; response while decreasing the likelihood of the &ldquo;rejected&rdquo; response. Compared to RL-based PPO methods, it is simpler to implement and more stable to train. LLaMA 3 made improvements to DPO, such as masking special formatting tokens in the responses during DPO training and introducing a normalized negative log-likelihood (NLL) loss as a regularizer to enhance training stability and generation quality. Its loss function form can be roughly referenced from the loss in <strong>RPO</strong> (<a href=https://arxiv.org/abs/2404.19733>Pang et al., 2024</a>), though LLaMA3&rsquo;s specific implementation might differ slightly:</p>$$
\begin{aligned}
\mathcal{L}_{\mathrm{DPO}+\mathrm{NLL}} & =\mathcal{L}_{\mathrm{DPO}}\left(y^w, y^l \mid x\right)+\alpha \mathcal{L}_{\mathrm{NLL}}\left(y^w \mid x\right) \\
& =-\log \sigma\left(\beta \log \frac{\pi_\theta(y^w \mid x)}{\pi_{\mathrm{ref}}(y^w \mid x)}-\beta \log \frac{\pi_\theta(y^l \mid x)}{\pi_{\mathrm{ref}}(y^l \mid x)}\right)-\alpha \frac{\log \pi_\theta(y^w \mid x)}{|y^w|}
\end{aligned}
$$<p>Where:</p><ul><li>$x$ is the input prompt.</li><li>$y^w$ is the preferred (winning/chosen) response, $y^l$ is the dispreferred (losing/rejected) response.</li><li>$\pi_\theta$ is the current model policy being optimized (with parameters $\theta$).</li><li>$\pi_{\mathrm{ref}}$ is the reference model policy (often the SFT model or the model from the previous iteration).</li><li>$\beta$ is a hyperparameter controlling the strength of the preference margin.</li><li>$\sigma$ is the Sigmoid function.</li><li>$\alpha$ is the weight balancing the DPO loss and the NLL regularization loss.</li><li>$|y^w|$ is the length of the winning response, used to normalize the NLL loss.
This loss function encourages the model $\pi_\theta$ to prefer generating $y^w$ over $y^l$ relative to the reference model $\pi_{\mathrm{ref}}$, while the NLL regularization term helps maintain the fluency and linguistic quality of the generated text.</li></ul></li><li><p><strong>Iterative Loop:</strong> The SFT and DPO (or RLHF variant) processes described above are repeated for multiple rounds (LLaMA 3 underwent five rounds). In each round, the model optimized in the previous round is used to generate new data, new human feedback is collected, new reward models are trained, and the next round of SFT and DPO optimization is performed. This iterative approach allows the model to continuously learn and improve.</p></li><li><p><strong>Model Weight Averaging:</strong> At certain stages, weight averaging might be performed across multiple model checkpoints trained with different data subsets or hyperparameters to obtain a final model that is more robust and has more balanced performance.</p></li></ol><h3 id=llama-4>LLaMA 4<a hidden class=anchor aria-hidden=true href=#llama-4>#</a></h3><p>The <strong>LLaMA 4</strong> (<a href=https://ai.meta.com/blog/llama-4-multimodal-intelligence/>Meta AI, 2025</a>) series of models, released by Meta AI on April 5, 2025, marks the LLaMA ecosystem&rsquo;s entry into a new phase of natively multimodal AI innovation. This generation introduces the <strong>Mixture-of-Experts (MoE) architecture</strong> for the first time and possesses unprecedented <strong>ultra-long context processing capabilities</strong>, aiming to provide more powerful and efficient open-source foundation models.</p><p><strong>Model Overview: Performance, Scale & Deployment</strong></p><p>LLaMA 4 initially released three models with different positionings, two of which have open weights:</p><table><thead><tr><th style=text-align:left>Model Name</th><th style=text-align:left>Active Params</th><th style=text-align:left>Num Experts</th><th style=text-align:left>Total Params</th><th style=text-align:left>Key Performance/Positioning</th><th style=text-align:left>Hardware Reference</th><th style=text-align:left>Context Window</th></tr></thead><tbody><tr><td style=text-align:left><strong>Llama 4 Scout</strong></td><td style=text-align:left>17B</td><td style=text-align:left>16</td><td style=text-align:left>109B</td><td style=text-align:left>Outperforms peer models like Gemma 3; <strong>10M Token ultra-long context</strong>; Strong image understanding; High cost-performance</td><td style=text-align:left>Single H100 GPU (INT4 quantized)</td><td style=text-align:left><strong>10M</strong></td></tr><tr><td style=text-align:left><strong>Llama 4 Maverick</strong></td><td style=text-align:left>17B</td><td style=text-align:left>128</td><td style=text-align:left>400B</td><td style=text-align:left>Matches or surpasses GPT-4o/Gemini 2.0 Flash (reasoning/coding/multilingual); Fewer active params, high computational efficiency; Leading in image reasoning/understanding; LMArena ELO 1417</td><td style=text-align:left>Single H100 host (multi-GPU) or distributed deployment</td><td style=text-align:left><strong>1M</strong></td></tr><tr><td style=text-align:left><strong>Llama 4 Behemoth</strong></td><td style=text-align:left>288B</td><td style=text-align:left>16</td><td style=text-align:left>~2T</td><td style=text-align:left><strong>Teacher Model (Unreleased)</strong>; Surpasses GPT-4.5/Claude 3.7/Gemini 2.0 Pro on STEM benchmarks (MATH, GPQA); Improves Scout/Maverick via <strong>co-distillation</strong></td><td style=text-align:left>Still in training, not publicly released</td><td style=text-align:left>(Not specified)</td></tr></tbody></table><ul><li><strong>Performance Highlights:</strong> Maverick (17B active parameters) demonstrates competitive strength against top-tier closed-source models like GPT-4o on several mainstream benchmarks, especially in reasoning, coding, and multilingual tasks, while having significantly fewer active parameters, reflecting excellent computational efficiency. Scout stands out among its peers with its astounding 10M token context window.</li><li><strong>Deployment Threshold:</strong> Scout&rsquo;s INT4 quantized version can run on a single H100, lowering the deployment barrier for high-performance models. Although Maverick requires more compute power (e.g., a single H100 multi-GPU host), it still offers attractive cost-performance relative to its capabilities. <em>(Note: Running these models on consumer-grade GPUs remains challenging)</em></li></ul><p><strong>Core Architecture & Training Innovations</strong></p><p>LLaMA 4 features the following optimizations compared to the previous generation:</p><ol><li><p><strong>Mixture-of-Experts (MoE) Architecture:</strong></p><ul><li>LLaMA 4 is the first Llama series to adopt MoE. MoE allows the model to activate only a small fraction of its total parameters (&ldquo;active parameters&rdquo;) during inference, achieving <strong>larger model capacity and stronger performance with lower computational cost</strong>. This is highly beneficial for compute-cost-sensitive (especially throughput-sensitive) inference scenarios.</li><li>The Maverick model employs <strong>alternating dense and MoE layers</strong>. Its MoE layers contain 128 routing experts and one shared expert accessed by all tokens. Each token is routed to the shared expert plus one of the routing experts for processing.</li></ul></li><li><p><strong>Native Multimodality & Early Fusion:</strong></p><ul><li><strong>Moving beyond &lsquo;stitched&rsquo; approaches:</strong> Unlike previous methods that &ldquo;bolted on&rdquo; visual modules to LLMs using late fusion, LLaMA 4 adopts an <strong>early fusion</strong> strategy from the ground up.</li><li><strong>Unified Backbone:</strong> Text tokens and visual tokens (from image and video frames) are seamlessly integrated and processed together in the early stages of the model&rsquo;s backbone network.</li><li><strong>Deep Understanding:</strong> This enables joint pre-training on massive amounts of image-text and video data, allowing the model to learn deeper, more fine-grained cross-modal associations, achieve more natural interaction, and exhibit stronger <strong>visual grounding</strong> capabilities (accurately mapping text prompts to image regions), going beyond simple &ldquo;image captioning.&rdquo;</li><li><strong>Vision Encoder:</strong> Based on <strong>MetaCLIP</strong> (<a href=https://arxiv.org/abs/2309.16671>Xu et al., 2023</a>), improved and co-trained with the Llama model to better suit the LLM&rsquo;s needs.</li></ul></li><li><p><strong>Ultra-Long Context:</strong></p><ul><li><strong>10M Token Limit:</strong> Llama 4 Scout achieves an <strong>industry-leading 10 million token context window</strong>.</li><li><strong>Technical Underpinnings:</strong><ul><li><strong>iRoPE Architecture:</strong> Combines ideas from <strong>RoPE (Rotary Position Embeddings)</strong> and <strong>NoPE (No Positional Encoding)</strong>. Implemented via <strong>interleaved attention layers</strong>, where specific layers use NoPE (<a href=https://arxiv.org/abs/2305.19466>Kazemnejad et al., 2023</a>), relying on the attention mechanism to implicitly learn positional relationships, while RoPE is still used in most other layers. (The &ldquo;i&rdquo; signifies both interleaved and the goal of infinite context).</li><li><strong>Scalable-Softmax:</strong> Combined with inference-time temperature scaling (<a href=https://arxiv.org/abs/2501.19399>Nakanishi et al., 2025</a>), enhancing the model&rsquo;s generalization ability to unseen lengths.</li><li><strong>Specialized Training:</strong> Underwent mid-training and post-training on specially constructed long-context datasets. Scout was trained on 256k context length and generalized to 10M via iRoPE and Scalable Softmax.</li></ul></li><li><strong>Practicality Observation:</strong> While 10M tokens are appealing, processing such long contexts in practice may encounter issues like inference efficiency, attention diffusion, and bandwidth bottlenecks. Its <strong>effectiveness and efficiency in real-world scenarios remain to be validated by users</strong>.</li></ul></li></ol><figure class=align-center><img loading=lazy src=llama4_sequence_position_nll.png#center alt="Fig. 14. Cumulative average NLL loss per sequence position for code generation, demonstrating Llama 4 Scout&rsquo;s strong performance over long contexts. (Source: Meta AI, 2025)" width=100%><figcaption><p>Fig. 14. Cumulative average NLL loss per sequence position for code generation, demonstrating Llama 4 Scout&rsquo;s strong performance over long contexts. (Source: <a href=https://ai.meta.com/blog/llama-4-multimodal-intelligence/>Meta AI, 2025</a>)</p></figcaption></figure><ol start=4><li><strong>Large-Scale High-Quality Pre-training:</strong><ul><li><strong>Data Scale:</strong> Training data exceeds <strong>30 trillion tokens</strong> (more than double LLaMA 3), including text, images, and video.</li><li><strong>Multilingual Coverage:</strong> Covers <strong>200 languages</strong>, with over 100 languages having more than 1 billion tokens each. Total multilingual token count is 10 times that of LLaMA 3.</li><li><strong>Training Efficiency:</strong> Trained using <strong>FP8 precision</strong>. Behemoth achieved high utilization of 390 TFLOPs/GPU on 32K GPUs. Utilized <strong>MetaP</strong> technology to reliably set hyperparameters.</li></ul></li></ol><p><strong>Revolutionary Post-training Process</strong></p><p>LLaMA 4 employs a new three-stage post-training process designed to balance instruction following, emergent intelligence, and dialogue quality:</p><ol><li><strong>Lightweight SFT (Supervised Fine-Tuning):</strong> Focuses on supervised fine-tuning using a small amount of harder datasets to teach the model basic instruction following and dialogue formats, avoiding overfitting simple patterns and preserving space for subsequent RL exploration. <strong>Significantly reduced simple SFT data</strong> compared to previous versions (Maverick >50%, Behemoth >95%).</li><li><strong>Online RL (Reinforcement Learning):</strong> The key stage for enhancing the model&rsquo;s core intelligence and complex task capabilities. Employs a <strong>continuous online RL strategy</strong> where the model learns through interaction with the environment, explores using carefully selected harder prompts, and alternates between model training and data filtering (retaining medium-to-hard interaction data) to balance computation and effectiveness.</li><li><strong>Lightweight DPO (Direct Preference Optimization):</strong> Performed after RL to fine-tune the model&rsquo;s response style, safety, and correct corner cases, serving as the final &ldquo;refinement and polishing&rdquo; step to ensure the unification of intelligence and smooth conversational experience.</li></ol><p><strong>Teacher Model & Co-Distillation</strong></p><ul><li>The powerful <strong>Behemoth (2T)</strong>, though unreleased, transferred its knowledge to Scout and Maverick during the pre-training phase via a <strong>novel co-distillation technique</strong>.</li><li>This <strong>co-distillation</strong> occurred during pre-training, using a new distillation loss function with dynamically weighted soft targets (teacher model&rsquo;s logits) and hard targets (true labels). This significantly improved the quality of the student models (especially in math, coding, etc.) while amortizing the training cost of the teacher model.</li></ul><p><strong>Large-Scale RL Infrastructure</strong></p><p>To train ultra-large MoE models like Behemoth, Meta completely overhauled its RL infrastructure, adopting a <strong>fully asynchronous online RL training framework</strong>. This optimized MoE parallelism, enabled flexible GPU resource allocation, and achieved nearly a 10x improvement in training efficiency.</p><h3 id=comparison>Comparison<a hidden class=anchor aria-hidden=true href=#comparison>#</a></h3><table><thead><tr><th>Feature</th><th>LLaMA 1</th><th>LLaMA 2</th><th>Code Llama</th><th>Llama Guard</th><th>LLaMA 3</th><th>LLaMA 4</th></tr></thead><tbody><tr><td><strong>Release Date</strong></td><td>2023/02</td><td>2023/07</td><td>2023/08</td><td>2023/12+</td><td>2024/04+</td><td>2025/04+</td></tr><tr><td><strong>Base Model</strong></td><td>-</td><td>-</td><td>LLaMA 2</td><td>LLaMA 2 / LLaMA 3</td><td>-</td><td>-</td></tr><tr><td><strong>Model Scale</strong></td><td>7B - 65B</td><td>7B, 13B, 70B</td><td>7B - 70B</td><td>7B / 8B (+Vision)</td><td>1B - 405B (+Vision)</td><td>109B, 400B, ~2T (MoE)</td></tr><tr><td><strong>Training Data Size</strong></td><td>1T - 1.4T tokens</td><td>2T+ tokens</td><td>+ 0.5T/1T Code</td><td>~40k Safety Class.</td><td>15T+ tokens</td><td>30T+ tokens (Multimodal)</td></tr><tr><td><strong>Context Length</strong></td><td>2k tokens</td><td>4k tokens</td><td>100k tokens</td><td>4k / 8k+</td><td>8k / 128k tokens</td><td>1M / 10M tokens</td></tr><tr><td><strong>Tokenizer</strong></td><td>SentencePiece (32k)</td><td>SentencePiece (32k)</td><td>SentencePiece (32k)</td><td>Based on LLaMA 2/3</td><td>tiktoken (128k)</td><td>tiktoken (256k)</td></tr><tr><td><strong>Positional Encoding</strong></td><td>RoPE</td><td>RoPE</td><td>RoPE (Base adjusted)</td><td>RoPE</td><td>RoPE</td><td>iRoPE</td></tr><tr><td><strong>Attention</strong></td><td>MHA</td><td>MHA / GQA (34B, 70B)</td><td>MHA / GQA (>13B)</td><td>Based on LLaMA 2/3</td><td>GQA</td><td>GQA</td></tr><tr><td><strong>Normalization</strong></td><td>RMSNorm (PreNorm)</td><td>RMSNorm (PreNorm)</td><td>RMSNorm (PreNorm)</td><td>RMSNorm (PreNorm)</td><td>RMSNorm (PreNorm)</td><td>RMSNorm (PreNorm)</td></tr><tr><td><strong>Activation Func.</strong></td><td>SwiGLU</td><td>SwiGLU</td><td>SwiGLU</td><td>SwiGLU</td><td>SwiGLU</td><td>SwiGLU</td></tr><tr><td><strong>Model Type</strong></td><td>Text Model</td><td>Text Model</td><td>Code Generation</td><td>Safety Classifier</td><td>Multimodal Model</td><td>Multimodal Model</td></tr></tbody></table><h2 id=key-technology-analysis>Key Technology Analysis<a hidden class=anchor aria-hidden=true href=#key-technology-analysis>#</a></h2><p>Below is an analysis of the key technologies widely adopted in the LLaMA series.</p><h3 id=rms-normalization-rmsnorm>RMS Normalization (RMSNorm)<a hidden class=anchor aria-hidden=true href=#rms-normalization-rmsnorm>#</a></h3><p>In deep learning model training, normalization layers are crucial for accelerating convergence, improving generalization, and stabilizing the training process. <strong>RMSNorm (Root Mean Square Normalization)</strong> (<a href=https://arxiv.org/abs/1910.07467>Zhang & Sennrich, 2019</a>) is a simplified variant of Layer Normalization. It normalizes using only the Root Mean Square (RMS) of the inputs, omitting the mean centering step, thus reducing computation.</p><p>Its mathematical expression is:</p>$$
\text{RMSNorm}(x) = \frac{x}{\text{RMS}(x)} \cdot \gamma = \frac{x}{\sqrt{\frac{1}{d} \sum_{i=1}^{d} x_i^2 + \epsilon}} \cdot \gamma
$$<p>Where:</p><ul><li>$ x \in \mathbb{R}^d $ is the input vector.</li><li>$ d $ is the vector dimension.</li><li>$ \text{RMS}(x) = \sqrt{\frac{1}{d} \sum_{i=1}^{d} x_i^2 + \epsilon} $ calculates the root mean square of the input.</li><li>$ \epsilon $ is a small positive number (e.g., $10^{-6}$) to prevent division by zero and increase numerical stability.</li><li>$ \gamma \in \mathbb{R}^d $ is a learnable scaling parameter vector (gain). RMSNorm typically omits the learnable offset parameter (bias) $ \beta $ found in LayerNorm.</li></ul><p><strong>Main reasons for LLaMA series choosing RMSNorm:</strong></p><ul><li><strong>High Computational Efficiency:</strong> Compared to LayerNorm, RMSNorm requires less computation because it doesn&rsquo;t need to calculate the mean. This is particularly important for computationally intensive large language model training and inference.</li><li><strong>Comparable Performance:</strong> Practice has shown that RMSNorm often achieves performance comparable to or even better than LayerNorm in architectures like Transformers, while maintaining training stability.</li><li><strong>Simple Implementation:</strong> Its computational logic is relatively simple, making it easy to implement efficiently on various hardware.</li></ul><blockquote><p>For a comparison of various Norm techniques and code implementations, refer to the blog post: <a href=https://syhya.github.io/posts/2025-02-01-normalization/>Normalization in Deep Learning</a>.</p></blockquote><h3 id=ffn_swiglu>FFN_SwiGLU<a hidden class=anchor aria-hidden=true href=#ffn_swiglu>#</a></h3><p><strong>Swish-Gated Linear Unit (SwiGLU)</strong> (<a href=https://arxiv.org/abs/2002.05202v1>Shazeer, 2020</a>) is a key technique used in LLaMA to enhance the non-linear expressive capability of the Feed-Forward Network (FFN). SwiGLU combines the Swish activation function with a gating mechanism, significantly improving the model&rsquo;s expressiveness and performance. Furthermore, unlike the $4d$ hidden dimension used in PaLM (<a href=https://arxiv.org/abs/2204.02311>Chowdhery et al., 2022</a>), LLaMA employs a $\frac{2}{3} \times 4d$ hidden dimension, achieving higher parameter efficiency while keeping the parameter count and computational load roughly constant.</p><p>Mathematical expression:</p>$$
\operatorname{FFN}_{\mathrm{SwiGLU}}\left(x, W_1, W_3, W_2\right)=\left(\operatorname{Swish}\left(x W_1\right) \otimes x W_3\right) W_2
$$<p>Where:</p><ul><li>$ \text{Swish}(x) = x \cdot \sigma(x) $ (Swish activation function).</li><li>$ \sigma(x) = \frac{1}{1 + e^{-x}} $ (Sigmoid function).</li><li>$ \otimes $ denotes element-wise multiplication.</li><li>$ W_1, W_2, W_3 $ are linear transformation matrices.</li></ul><p><strong>Advantages</strong>:</p><ul><li><strong>Enhanced Non-linear Expression</strong>: By combining the Swish activation function with a gating mechanism, SwiGLU can more effectively capture complex patterns and relationships, boosting the expressive power of the FFN layer.</li><li><strong>Parameter Efficiency</strong>: Using a $\frac{2}{3} \times 4d$ hidden dimension allows the introduction of an additional linear transformation matrix while maintaining the total parameter count, leading to efficient parameter utilization.</li><li><strong>Performance Improvement</strong>: FFN_SwiGLU has shown significant performance improvements on various benchmarks, especially excelling in handling complex tasks and long texts. For example, in text generation and understanding tasks, SwiGLU helps the model better grasp context and long-range dependencies.</li></ul><p><strong>Implementation Details</strong>:</p><ul><li><strong>Weight Matrix Adjustment</strong>: To maintain the same parameter count and computational load as traditional FFN layers, SwiGLU reduces the hidden layer dimension (e.g., adjusting the hidden size from $4d$ to $\frac{2}{3} \times 4d$), ensuring the overall model efficiency is unaffected despite introducing an extra linear transformation matrix.</li><li><strong>Compatibility</strong>: As a member of the GLU family, SwiGLU can be seamlessly integrated into existing Transformer architectures, replacing traditional ReLU or GELU activation functions to enhance overall model performance.</li></ul><blockquote><p>For implementation code, refer to this file: <a href=https://github.com/syhya/syhya.github.io/blob/main/content/zh/posts/2025-04-06-llama/swiglu.py>swiglu.py</a>.</p></blockquote><h3 id=grouped-query-attention-gqa>Grouped Query Attention (GQA)<a hidden class=anchor aria-hidden=true href=#grouped-query-attention-gqa>#</a></h3><p><strong>Grouped Query Attention (GQA)</strong> (<a href=https://arxiv.org/abs/2305.13245>Ainslie et al., 2023</a>) is a key optimization technique for the standard Multi-Head Attention (MHA) mechanism, particularly applied in large language models like LLaMA. Its primary goal is to reduce the memory bandwidth and capacity required for loading and storing the <strong>KV Cache</strong> during inference, thereby achieving a better balance between model performance and computational efficiency.</p><p>GQA is a compromise between MHA and Multi-Query Attention (MQA):</p><ul><li><strong>MHA:</strong> Has $H$ Query heads, each with its own independent set of $H$ Key (K) and Value (V) projections. Computation and KV Cache size are proportional to the number of heads $H$.</li><li><strong>MQA:</strong> Still has $H$ Query heads, but all heads share a single set of K and V projections. This drastically reduces the KV Cache size (to $1/H$ of MHA&rsquo;s), but can potentially degrade model quality.</li><li><strong>GQA:</strong> Divides the $H$ Query heads into $G$ groups ($1 &lt; G &lt; H$, and $H$ is a multiple of $G$). The $H/G$ Query heads within each group share the same set of K and V projections. There are a total of $G$ sets of K and V projections.</li></ul><figure class=align-center><img loading=lazy src=attention_comparison.png#center alt="Fig. 15. Overview of Multi-Head Attention (MHA), Multi-Query Attention (MQA), and Grouped-Query Attention (GQA). GQA groups query heads to share key/value heads. (Source: Ainslie et al., 2023)" width=100%><figcaption><p>Fig. 15. Overview of Multi-Head Attention (MHA), Multi-Query Attention (MQA), and Grouped-Query Attention (GQA). GQA groups query heads to share key/value heads. (Source: <a href=https://arxiv.org/abs/2305.13245>Ainslie et al., 2023</a>)</p></figcaption></figure><p>The computation steps are as follows:</p><ol><li><strong>Projection:</strong> Input $X$ is still projected to get $Q, K, V$. $Q$ is split into $H$ heads $Q_1, \dots, Q_H$. $K$ and $V$ are split into $G$ groups $K^1, \dots, K^G$ and $V^1, \dots, V^G$.</li><li><strong>Grouped Attention:</strong> For the $g$-th group ($g=1, \dots, G$), the corresponding Query heads (e.g., $Q_i$ where $i$ belongs to group $g$) compute attention with the shared $K^g$ and $V^g$:
$$
\text{Attention}_i(Q_i, K^g, V^g) = \text{softmax}\left( \frac{Q_i (K^g)^\top}{\sqrt{d_k}} \right) V^g
$$
where $d_k$ is the dimension of each K head (and also Q head).</li><li><strong>Concatenation & Output:</strong> The outputs of all heads $ \text{Attention}_1, \dots, \text{Attention}_H $ are concatenated and then passed through an output projection matrix $W_O$ to get the final output.</li></ol><p><strong>Advantages:</strong></p><ul><li><strong>Balances Performance and Efficiency:</strong> GQA significantly reduces the KV Cache size (to $G/H$ of MHA&rsquo;s) while typically maintaining model quality closer to MHA than MQA does.</li><li><strong>Accelerates Inference:</strong> Reducing memory bandwidth requirements can significantly speed up inference for large models, especially in long sequence generation scenarios.</li></ul><blockquote><p>For a more detailed comparison between <strong>MHA</strong>, <strong>MQA</strong>, and <strong>GQA</strong> attention mechanisms, along with code examples, refer to the blog post: <a href=https://syhya.github.io/posts/2025-01-16-group-query-attention/#grouped-query-attention-gqa>Attention Mechanisms in Transformers: Comparing MHA, MQA, and GQA</a>.</p></blockquote><h3 id=rotary-positional-embeddings-rope>Rotary Positional Embeddings (RoPE)<a hidden class=anchor aria-hidden=true href=#rotary-positional-embeddings-rope>#</a></h3><p><strong>Rotary Positional Embeddings (RoPE)</strong> (<a href=https://arxiv.org/abs/2104.09864>Su et al., 2021</a>) is an effective method for injecting positional information into the Transformer attention mechanism, particularly adept at encoding relative positional information. Unlike traditional absolute positional encodings (like sinusoidal or learnable embeddings), RoPE achieves this by applying position-dependent rotation operations to the Query and Key vectors.</p><figure class=align-center><img loading=lazy src=rope.png#center alt="Fig. 16. Implementation of Rotary Position Embedding(RoPE). (Source: Su et al., 2021)" width=90%><figcaption><p>Fig. 16. Implementation of Rotary Position Embedding(RoPE). (Source: <a href=https://arxiv.org/abs/2104.09864>Su et al., 2021</a>)</p></figcaption></figure><p>Assume $q_m$ and $k_n$ are the Query vector at position $m$ and the Key vector at position $n$, respectively. RoPE treats a $d$-dimensional vector $x$ ($q$ or $k$) as $d/2$ blocks of 2D vectors $[x^{(1)}, x^{(2)}, \dots, x^{(d/2)}]$, where $x^{(i)} = [x_{2i-1}, x_{2i}]$. For position $m$, RoPE defines a rotation matrix $R_m$ composed of $d/2$ 2D rotation matrices:</p>$$
R_m = \text{diag}(R_{m,1}, R_{m,2}, \dots, R_{m,d/2})
$$<p>where each 2D rotation matrix is:</p>$$
R_{m,i} = \begin{pmatrix} \cos(m\theta_i) & -\sin(m\theta_i) \\ \sin(m\theta_i) & \cos(m\theta_i) \end{pmatrix}
$$<p>The rotation frequencies are $ \theta_i = b^{-2(i-1)/d} $, where $b$ is a predefined base (typically 10000 in LLaMA).</p><p>After applying RoPE, the new Query and Key vectors are $q&rsquo;_m = R_m q_m$ and $k&rsquo;_n = R_n k_n$. The key insight is that their inner product (dot product, which determines attention scores) depends only on the relative position $m-n$:</p>$$
(q'_m)^\top k'_n = (R_m q_m)^\top (R_n k_n) = q_m^\top R_m^\top R_n k_n = q_m^\top R_{n-m} k_n
$$<p>This utilizes the property of rotation matrices $R_m^\top R_n = R_{n-m}$.</p><p><strong>Advantages:</strong></p><ul><li><strong>Explicit Relative Position Encoding:</strong> The inner product result directly depends on the relative distance $m-n$, which is very natural for capturing relationships between elements in a sequence.</li><li><strong>Long-Distance Decay Property:</strong> As the relative distance $|m-n|$ increases, the change in angle between vectors due to rotation typically causes the inner product value to decay, aligning with the intuition that more distant elements have weaker correlations.</li><li><strong>Good Extrapolation:</strong> Theoretically, RoPE can generalize better to sequence lengths longer than those seen during training because it doesn&rsquo;t rely on a maximum absolute position. Adjusting the base $b$ (as in Code Llama and LLaMA 4&rsquo;s iRoPE) can further optimize its performance on ultra-long contexts.</li><li><strong>No Extra Parameters:</strong> RoPE is a fixed, position-based transformation that introduces no additional learnable parameters.</li><li><strong>Compatibility with Linear Attention:</strong> It can be used in conjunction with various linear attention variants.</li></ul><h3 id=mixture-of-experts-moe>Mixture-of-Experts (MoE)<a hidden class=anchor aria-hidden=true href=#mixture-of-experts-moe>#</a></h3><p><strong>Mixture-of-Experts (MoE)</strong> is a neural network architecture paradigm designed to increase model capacity (total parameters) while controlling computational cost (active parameters). It replaces certain layers in the network (typically FFN layers) with multiple parallel expert subnetworks. A lightweight gating network dynamically selects a small number (usually Top-K, with K=1 or 2) of these experts for each input token to perform computation.</p><figure class=align-center><img loading=lazy src=llama4_moe.png#center alt="Fig. 17. The Illustration of a mixture-of-experts(MoE) in llama4. (Source: Meta AI, 2025)" width=100%><figcaption><p>Fig. 17. The Illustration of a mixture-of-experts(MoE) in llama4. (Source: <a href=https://ai.meta.com/blog/llama-4-multimodal-intelligence/>Meta AI, 2025</a>)</p></figcaption></figure><p>Assume an MoE layer has $N$ experts $E_1, E_2, \dots, E_N$ (e.g., each expert is an independent FFN) and a gating network $G$. For an input token $x$, the computation process of the MoE layer is as follows:</p><ol><li><strong>Gating Calculation:</strong> The gating network $G$ (often a simple linear layer followed by Softmax) computes the probability or weight for selecting each expert: $p = G(x) = \text{Softmax}(\text{Linear}(x))$, where $p \in \mathbb{R}^N$.</li><li><strong>Expert Selection (Top-K Routing):</strong> Based on the gating output $p$, the K experts with the highest scores are selected. Let the set of selected expert indices be $\mathcal{T} = \text{TopKIndices}(p)$.</li><li><strong>Expert Computation:</strong> Only the selected K experts compute on the input $x$, yielding outputs $E_i(x)$ for $i \in \mathcal{T}$.</li><li><strong>Output Combination:</strong> The final output $y$ is the weighted sum of the outputs from the selected experts, using their gating weights (often re-normalized):
$$
y = \sum_{i \in \mathcal{T}} \frac{p_i}{\sum_{j \in \mathcal{T}} p_j} \cdot E_i(x)
$$
Alternatively, in some implementations, the weights $p_i$ might be used directly.</li></ol><p><strong>Advantages:</strong></p><ul><li><strong>Decoupling Parameters and Computation:</strong> MoE allows models to have a massive total parameter count (by increasing the number of experts $N$), but the computational cost of each forward pass depends only on the computation of the activated K experts, which is much lower than that of a dense model with an equivalent total parameter count. This enables training larger capacity, potentially higher-performing models within a limited computational budget.</li><li><strong>Expert Specialization:</strong> Theoretically, different experts can learn to handle specific aspects of different types of data, patterns, or tasks, enabling modular storage and processing of knowledge, thereby enhancing the model&rsquo;s overall capability and generalization.</li></ul><p><strong>Challenges:</strong></p><ul><li><strong>Load Balancing:</strong> Ensuring that all experts are utilized roughly equally is necessary to avoid some experts being overloaded while others remain idle. This often requires introducing auxiliary loss functions (like Load Balancing Loss) to encourage uniform routing.</li><li><strong>Communication Overhead:</strong> In distributed training and inference, efficient communication (e.g., All-to-All) is needed between different devices (GPUs) to route tokens to the devices storing the corresponding experts and to gather the results. This increases implementation complexity and communication costs.</li><li><strong>Training Stability:</strong> Training MoE models can be less stable than training dense models, requiring careful tuning of hyperparameters and training strategies.</li><li><strong>Memory Footprint:</strong> Although computation is sparse, the total number of parameters is huge, requiring substantial memory to store all expert weights.</li></ul><blockquote><p>For a more detailed explanation of MoE, refer to the Mixture-of-Experts section in the blog post: <a href=https://syhya.github.io/posts/2025-03-01-train-llm/#mixture-of-experts-model>Parallelism and Memory Optimization Techniques for Training Large Models</a>.</p></blockquote><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] Touvron, Hugo, et al. <a href=https://arxiv.org/abs/2302.13971>&ldquo;LLaMA: Open and Efficient Foundation Language Models.&rdquo;</a> arXiv preprint arXiv:2302.13971 (2023).</p><p>[2] Facebook Research. <a href=https://github.com/facebookresearch/xformers>&ldquo;xformers.&rdquo;</a> GitHub repository (Accessed 2024).</p><p>[3] Taori, Rohan, et al. <a href=https://crfm.stanford.edu/2023/03/13/alpaca.html>&ldquo;Alpaca: A Strong, Replicable Instruction-Following Model.&rdquo;</a> Stanford CRFM Blog (2023).</p><p>[4] Touvron, Hugo, et al. <a href=https://arxiv.org/abs/2307.09288>&ldquo;Llama 2: Open Foundation and Fine-Tuned Chat Models.&rdquo;</a> arXiv preprint arXiv:2307.09288 (2023).</p><p>[5] Bai, Yuntao, et al. <a href=https://arxiv.org/abs/2212.08073>&ldquo;Constitutional AI: Harmlessness from AI Feedback.&rdquo;</a> arXiv preprint arXiv:2212.08073 (2022).</p><p>[6] Roziere, Baptiste, et al. <a href=https://arxiv.org/abs/2308.12950>&ldquo;Code Llama: Open Foundation Models for Code.&rdquo;</a> arXiv preprint arXiv:2308.12950 (2023).</p><p>[7] Inan, Hakan, et al. <a href=https://arxiv.org/abs/2312.06674>&ldquo;Llama Guard: LLM-based Input-Output Safeguard for Human-AI Conversations.&rdquo;</a> arXiv preprint arXiv:2312.06674 (2023).</p><p>[8] Chi, Jianfeng, et al. <a href=https://arxiv.org/abs/2411.10414>&ldquo;Llama Guard 3 Vision: Safeguarding Human-AI Image Understanding Conversations.&rdquo;</a> arXiv preprint arXiv:2411.10414 (2024).</p><p>[9] Vidgen, Bertie, et al. <a href=https://arxiv.org/abs/2404.12241>&ldquo;Introducing v0.5 of the AI Safety Benchmark from MLCommons.&rdquo;</a> arXiv preprint arXiv:2404.12241 (2024).</p><p>[10] Meta Llama. <a href=https://huggingface.co/meta-llama/Llama-Guard-3-8B>&ldquo;Llama-Guard-3-8B.&rdquo;</a> Hugging Face Model (Accessed 2024).</p><p>[11] Grattafiori, Aaron, et al. <a href=https://arxiv.org/abs/2407.21783>&ldquo;The Llama 3 Herd of Models.&rdquo;</a> arXiv preprint arXiv:2407.21783 (2024).</p><p>[12] Meta AI. <a href=https://ai.meta.com/blog/meta-llama-3-1/>&ldquo;Introducing Llama 3.1: Our most capable models to date.&rdquo;</a> Meta AI Blog (2024).</p><p>[13] Umar Jamil. <a href=https://github.com/hkproj/pytorch-llama/blob/main/Slides.pdf>&ldquo;pytorch-llama Slides.&rdquo;</a> GitHub file (Accessed 2024).</p><p>[14] Pang, Richard Yuanzhe, et al. <a href=https://arxiv.org/abs/2404.19733>&ldquo;Iterative reasoning preference optimization.&rdquo;</a> Advances in Neural Information Processing Systems 37 (2024): 116617-116637.</p><p>[15] Meta AI. <a href=https://ai.meta.com/blog/llama-4-multimodal-intelligence/>&ldquo;The Llama 4 herd: The beginning of a new era of natively multimodal AI innovation&rdquo;</a> Meta AI Blog (2025).</p><p>[16] Xu, Hu, et al. <a href=https://arxiv.org/abs/2309.16671>&ldquo;Demystifying clip data.&rdquo;</a> arXiv preprint arXiv:2309.16671 (2023).</p><p>[17] Kazemnejad, Amirhossein, et al. <a href=https://arxiv.org/abs/2305.19466>&ldquo;The impact of positional encoding on length generalization in transformers.&rdquo;</a> Advances in Neural Information Processing Systems 36 (2023): 24892-24928.</p><p>[18] Nakanishi, Ken M. <a href=https://arxiv.org/abs/2501.19399>&ldquo;Scalable-Softmax Is Superior for Attention.&rdquo;</a> arXiv preprint arXiv:2501.19399 (2025).</p><p>[19] Zhang, Biao, and Rico Sennrich. <a href=https://arxiv.org/abs/1910.07467>&ldquo;Root mean square layer normalization.&rdquo;</a> Advances in Neural Information Processing Systems 32 (2019).</p><p>[20] Shazeer, Noam. <a href=https://arxiv.org/abs/2002.05202v1>&ldquo;Glu variants improve transformer.&rdquo;</a> arXiv preprint arXiv:2002.05202 (2020).</p><p>[21] Ainslie, Joshua, et al. <a href=https://arxiv.org/abs/2305.13245>&ldquo;Gqa: Training generalized multi-query transformer models from multi-head checkpoints.&rdquo;</a> arXiv preprint arXiv:2305.13245 (2023).</p><p>[22] Su, Jianlin, et al. <a href=https://arxiv.org/abs/2104.09864>&ldquo;Roformer: Enhanced transformer with rotary position embedding.&rdquo;</a> Neurocomputing 568 (2024): 127063.</p><h2 id=citation>Citation<a hidden class=anchor aria-hidden=true href=#citation>#</a></h2><blockquote><p><strong>Citation</strong>: When reproducing or citing the content of this article, please indicate the original author and source.</p></blockquote><p><strong>Cited as:</strong></p><blockquote><p>Yue Shui. (Apr 2025). The LLaMA Herd. <a href=https://syhya.github.io/posts/2025-04-06-llama>https://syhya.github.io/posts/2025-04-06-llama</a></p></blockquote><p>Or</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bibtex data-lang=bibtex><span class=line><span class=cl><span class=nc>@article</span><span class=p>{</span><span class=nl>syhya2025llama</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>title</span>   <span class=p>=</span> <span class=s>&#34;The LLaMA Herd&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>author</span>  <span class=p>=</span> <span class=s>&#34;Yue Shui&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>journal</span> <span class=p>=</span> <span class=s>&#34;syhya.github.io&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>year</span>    <span class=p>=</span> <span class=s>&#34;2025&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>month</span>   <span class=p>=</span> <span class=s>&#34;Apr&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=na>url</span>     <span class=p>=</span> <span class=s>&#34;https://syhya.github.io/posts/2025-04-06-llama&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://syhya.github.io/tags/llama/>LLaMA</a></li><li><a href=https://syhya.github.io/tags/ai/>AI</a></li><li><a href=https://syhya.github.io/tags/nlp/>NLP</a></li><li><a href=https://syhya.github.io/tags/llm/>LLM</a></li><li><a href=https://syhya.github.io/tags/pre-training/>Pre-Training</a></li><li><a href=https://syhya.github.io/tags/post-training/>Post-Training</a></li></ul><nav class=paginav><a class=prev href=https://syhya.github.io/posts/2025-04-18-deepseek-v2-v3/><span class=title>« Prev</span><br><span>DeepSeek-V2 vs V3</span>
</a><a class=next href=https://syhya.github.io/posts/2025-03-27-llm-agent/><span class=title>Next »</span><br><span>Large Language Model Agents</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on x" href="https://x.com/intent/tweet/?text=The%20LLaMA%20Herd&amp;url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f&amp;hashtags=LLaMA%2cAI%2cNLP%2cLLM%2cPre-training%2cPost-training"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f&amp;title=The%20LLaMA%20Herd&amp;summary=The%20LLaMA%20Herd&amp;source=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f&title=The%20LLaMA%20Herd"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on whatsapp" href="https://api.whatsapp.com/send?text=The%20LLaMA%20Herd%20-%20https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on telegram" href="https://telegram.me/share/url?text=The%20LLaMA%20Herd&amp;url=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The LLaMA Herd on ycombinator" href="https://news.ycombinator.com/submitlink?t=The%20LLaMA%20Herd&u=https%3a%2f%2fsyhya.github.io%2fposts%2f2025-04-06-llama%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://syhya.github.io/>Yue Shui Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>